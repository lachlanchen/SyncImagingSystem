===== .//BasicDemo/BasicDemo.py =====
# -*- coding: utf-8 -*-
import sys
from PyQt5.QtWidgets import *
from CamOperation_class import CameraOperation
from MvCameraControl_class import *
from MvErrorDefine_const import *
from CameraParams_header import *
from PyUICBasicDemo import Ui_MainWindow
import ctypes


# 获取选取设备信息的索引，通过[]之间的字符去解析
def TxtWrapBy(start_str, end, all):
    start = all.find(start_str)
    if start >= 0:
        start += len(start_str)
        end = all.find(end, start)
        if end >= 0:
            return all[start:end].strip()


# 将返回的错误码转换为十六进制显示
def ToHexStr(num):
    chaDic = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}
    hexStr = ""
    if num < 0:
        num = num + 2 ** 32
    while num >= 16:
        digit = num % 16
        hexStr = chaDic.get(digit, str(digit)) + hexStr
        num //= 16
    hexStr = chaDic.get(num, str(num)) + hexStr
    return hexStr


if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    global deviceList
    deviceList = MV_CC_DEVICE_INFO_LIST()
    global cam
    cam = MvCamera()
    global nSelCamIndex
    nSelCamIndex = 0
    global obj_cam_operation
    obj_cam_operation = 0
    global isOpen
    isOpen = False
    global isGrabbing
    isGrabbing = False
    global isCalibMode  # 是否是标定模式（获取原始图像）
    isCalibMode = True

    # 绑定下拉列表至设备信息索引
    def xFunc(event):
        global nSelCamIndex
        nSelCamIndex = TxtWrapBy("[", "]", ui.ComboDevices.get())

    # Decoding Characters
    def decoding_char(c_ubyte_value):
        c_char_p_value = ctypes.cast(c_ubyte_value, ctypes.c_char_p)
        try:
            decode_str = c_char_p_value.value.decode('gbk')  # Chinese characters
        except UnicodeDecodeError:
            decode_str = str(c_char_p_value.value)
        return decode_str

    # ch:枚举相机 | en:enum devices
    def enum_devices():
        global deviceList
        global obj_cam_operation

        deviceList = MV_CC_DEVICE_INFO_LIST()
        n_layer_type = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                        | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
        ret = MvCamera.MV_CC_EnumDevices(n_layer_type, deviceList)
        if ret != 0:
            strError = "Enum devices fail! ret = :" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
            return ret

        if deviceList.nDeviceNum == 0:
            QMessageBox.warning(mainWindow, "Info", "Find no device", QMessageBox.Ok)
            return ret
        print("Find %d devices!" % deviceList.nDeviceNum)

        devList = []
        for i in range(0, deviceList.nDeviceNum):
            mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
            if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
                print("\ngige device: [%d]" % i)
                user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stGigEInfo.chUserDefinedName)
                model_name = decoding_char(mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName)
                print("device user define name: " + user_defined_name)
                print("device model name: " + model_name)

                nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
                nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
                nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
                nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
                print("current ip: %d.%d.%d.%d " % (nip1, nip2, nip3, nip4))
                devList.append(
                    "[" + str(i) + "]GigE: " + user_defined_name + " " + model_name + "(" + str(nip1) + "." + str(
                        nip2) + "." + str(nip3) + "." + str(nip4) + ")")
            elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
                print("\nu3v device: [%d]" % i)
                user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stUsb3VInfo.chUserDefinedName)
                model_name = decoding_char(mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName)
                print("device user define name: " + user_defined_name)
                print("device model name: " + model_name)

                strSerialNumber = ""
                for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                    if per == 0:
                        break
                    strSerialNumber = strSerialNumber + chr(per)
                print("user serial number: " + strSerialNumber)
                devList.append("[" + str(i) + "]USB: " + user_defined_name + " " + model_name
                               + "(" + str(strSerialNumber) + ")")
            elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
                print("\nCML device: [%d]" % i)
                user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stCMLInfo.chUserDefinedName)
                model_name = decoding_char(mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName)
                print("device user define name: " + user_defined_name)
                print("device model name: " + model_name)

                strSerialNumber = ""
                for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                    if per == 0:
                        break
                    strSerialNumber = strSerialNumber + chr(per)
                print("user serial number: " + strSerialNumber)
                devList.append("[" + str(i) + "]CML: " + user_defined_name + " " + model_name
                               + "(" + str(strSerialNumber) + ")")
            elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
                print("\nCXP device: [%d]" % i)
                user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stCXPInfo.chUserDefinedName)
                model_name = decoding_char(mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName)
                print("device user define name: " + user_defined_name)
                print("device model name: " + model_name)

                strSerialNumber = ""
                for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                    if per == 0:
                        break
                    strSerialNumber = strSerialNumber + chr(per)
                print("user serial number: " + strSerialNumber)
                devList.append("[" + str(i) + "]CXP: " + user_defined_name + " " + model_name
                               + "(" + str(strSerialNumber) + ")")
            elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
                print("\nXoF device: [%d]" % i)
                user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stXoFInfo.chUserDefinedName)
                model_name = decoding_char(mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName)
                print("device user define name: " + user_defined_name)
                print("device model name: " + model_name)

                strSerialNumber = ""
                for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                    if per == 0:
                        break
                    strSerialNumber = strSerialNumber + chr(per)
                print("user serial number: " + strSerialNumber)
                devList.append("[" + str(i) + "]XoF: " + user_defined_name + " " + model_name
                               + "(" + str(strSerialNumber) + ")")

        ui.ComboDevices.clear()
        ui.ComboDevices.addItems(devList)
        ui.ComboDevices.setCurrentIndex(0)

    # ch:打开相机 | en:open device
    def open_device():
        global deviceList
        global nSelCamIndex
        global obj_cam_operation
        global isOpen
        if isOpen:
            QMessageBox.warning(mainWindow, "Error", 'Camera is Running!', QMessageBox.Ok)
            return MV_E_CALLORDER

        nSelCamIndex = ui.ComboDevices.currentIndex()
        if nSelCamIndex < 0:
            QMessageBox.warning(mainWindow, "Error", 'Please select a camera!', QMessageBox.Ok)
            return MV_E_CALLORDER

        obj_cam_operation = CameraOperation(cam, deviceList, nSelCamIndex)
        ret = obj_cam_operation.Open_device()
        if 0 != ret:
            strError = "Open device failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
            isOpen = False
        else:
            set_continue_mode()

            get_param()

            isOpen = True
            enable_controls()

    # ch:开始取流 | en:Start grab image
    def start_grabbing():
        global obj_cam_operation
        global isGrabbing

        ret = obj_cam_operation.Start_grabbing(ui.widgetDisplay.winId())
        if ret != 0:
            strError = "Start grabbing failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            isGrabbing = True
            enable_controls()

    # ch:停止取流 | en:Stop grab image
    def stop_grabbing():
        global obj_cam_operation
        global isGrabbing
        ret = obj_cam_operation.Stop_grabbing()
        if ret != 0:
            strError = "Stop grabbing failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            isGrabbing = False
            enable_controls()

    # ch:关闭设备 | Close device
    def close_device():
        global isOpen
        global isGrabbing
        global obj_cam_operation

        if isOpen:
            obj_cam_operation.Close_device()
            isOpen = False

        isGrabbing = False

        enable_controls()

    # ch:设置触发模式 | en:set trigger mode
    def set_continue_mode():
        ret = obj_cam_operation.Set_trigger_mode(False)
        if ret != 0:
            strError = "Set continue mode failed ret:" + ToHexStr(ret) + " mode is " + str(is_trigger_mode)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            ui.radioContinueMode.setChecked(True)
            ui.radioTriggerMode.setChecked(False)
            ui.bnSoftwareTrigger.setEnabled(False)

    # ch:设置软触发模式 | en:set software trigger mode
    def set_software_trigger_mode():
        ret = obj_cam_operation.Set_trigger_mode(True)
        if ret != 0:
            strError = "Set trigger mode failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            ui.radioContinueMode.setChecked(False)
            ui.radioTriggerMode.setChecked(True)
            ui.bnSoftwareTrigger.setEnabled(isGrabbing)

    # ch:设置触发命令 | en:set trigger software
    def trigger_once():
        ret = obj_cam_operation.Trigger_once()
        if ret != 0:
            strError = "TriggerSoftware failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)

    # ch:存图 | en:save image
    def save_bmp():
        ret = obj_cam_operation.Save_Bmp()
        if ret != MV_OK:
            strError = "Save BMP failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            print("Save image success")
            
    def is_float(str):
        try:
            float(str)
            return True
        except ValueError:
            return False
    

    # ch: 获取参数 | en:get param
    def get_param():
        ret = obj_cam_operation.Get_parameter()
        if ret != MV_OK:
            strError = "Get param failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            ui.edtExposureTime.setText("{0:.2f}".format(obj_cam_operation.exposure_time))
            ui.edtGain.setText("{0:.2f}".format(obj_cam_operation.gain))
            ui.edtFrameRate.setText("{0:.2f}".format(obj_cam_operation.frame_rate))

    # ch: 设置参数 | en:set param
    def set_param():
        frame_rate = ui.edtFrameRate.text()
        exposure = ui.edtExposureTime.text()
        gain = ui.edtGain.text()

        if is_float(frame_rate)!=True or is_float(exposure)!=True or is_float(gain)!=True:
            strError = "Set param failed ret:" + ToHexStr(MV_E_PARAMETER)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
            return MV_E_PARAMETER
        
        ret = obj_cam_operation.Set_parameter(frame_rate, exposure, gain)
        if ret != MV_OK:
            strError = "Set param failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)

        return MV_OK

    # ch: 设置控件状态 | en:set enable status
    def enable_controls():
        global isGrabbing
        global isOpen

        # 先设置group的状态，再单独设置各控件状态
        ui.groupGrab.setEnabled(isOpen)
        ui.groupParam.setEnabled(isOpen)

        ui.bnOpen.setEnabled(not isOpen)
        ui.bnClose.setEnabled(isOpen)

        ui.bnStart.setEnabled(isOpen and (not isGrabbing))
        ui.bnStop.setEnabled(isOpen and isGrabbing)
        ui.bnSoftwareTrigger.setEnabled(isGrabbing and ui.radioTriggerMode.isChecked())

        ui.bnSaveImage.setEnabled(isOpen and isGrabbing)

    # ch: 初始化app, 绑定控件与函数 | en: Init app, bind ui and api
    app = QApplication(sys.argv)
    mainWindow = QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(mainWindow)
    ui.bnEnum.clicked.connect(enum_devices)
    ui.bnOpen.clicked.connect(open_device)
    ui.bnClose.clicked.connect(close_device)
    ui.bnStart.clicked.connect(start_grabbing)
    ui.bnStop.clicked.connect(stop_grabbing)

    ui.bnSoftwareTrigger.clicked.connect(trigger_once)
    ui.radioTriggerMode.clicked.connect(set_software_trigger_mode)
    ui.radioContinueMode.clicked.connect(set_continue_mode)

    ui.bnGetParam.clicked.connect(get_param)
    ui.bnSetParam.clicked.connect(set_param)

    ui.bnSaveImage.clicked.connect(save_bmp)

    mainWindow.show()

    app.exec_()

    close_device()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()

    sys.exit()


===== .//BasicDemo/CamOperation_class.py =====
# -- coding: utf-8 --
import sys
import threading
import msvcrt
import numpy as np
import time
import sys, os
import datetime
import inspect
import ctypes
import random
from ctypes import *

sys.path.append("../MvImport")

from CameraParams_header import *
from MvCameraControl_class import *

# 强制关闭线程
def Async_raise(tid, exctype):
    tid = ctypes.c_long(tid)
    if not inspect.isclass(exctype):
        exctype = type(exctype)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))
    if res == 0:
        raise ValueError("invalid thread id")
    elif res != 1:
        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)
        raise SystemError("PyThreadState_SetAsyncExc failed")


# 停止线程
def Stop_thread(thread):
    Async_raise(thread.ident, SystemExit)


# 转为16进制字符串
def To_hex_str(num):
    chaDic = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}
    hexStr = ""
    if num < 0:
        num = num + 2 ** 32
    while num >= 16:
        digit = num % 16
        hexStr = chaDic.get(digit, str(digit)) + hexStr
        num //= 16
    hexStr = chaDic.get(num, str(num)) + hexStr
    return hexStr


# 是否是Mono图像
def Is_mono_data(enGvspPixelType):
    if PixelType_Gvsp_Mono8 == enGvspPixelType or PixelType_Gvsp_Mono10 == enGvspPixelType \
            or PixelType_Gvsp_Mono10_Packed == enGvspPixelType or PixelType_Gvsp_Mono12 == enGvspPixelType \
            or PixelType_Gvsp_Mono12_Packed == enGvspPixelType:
        return True
    else:
        return False


# 是否是彩色图像
def Is_color_data(enGvspPixelType):
    if PixelType_Gvsp_BayerGR8 == enGvspPixelType or PixelType_Gvsp_BayerRG8 == enGvspPixelType \
            or PixelType_Gvsp_BayerGB8 == enGvspPixelType or PixelType_Gvsp_BayerBG8 == enGvspPixelType \
            or PixelType_Gvsp_BayerGR10 == enGvspPixelType or PixelType_Gvsp_BayerRG10 == enGvspPixelType \
            or PixelType_Gvsp_BayerGB10 == enGvspPixelType or PixelType_Gvsp_BayerBG10 == enGvspPixelType \
            or PixelType_Gvsp_BayerGR12 == enGvspPixelType or PixelType_Gvsp_BayerRG12 == enGvspPixelType \
            or PixelType_Gvsp_BayerGB12 == enGvspPixelType or PixelType_Gvsp_BayerBG12 == enGvspPixelType \
            or PixelType_Gvsp_BayerGR10_Packed == enGvspPixelType or PixelType_Gvsp_BayerRG10_Packed == enGvspPixelType \
            or PixelType_Gvsp_BayerGB10_Packed == enGvspPixelType or PixelType_Gvsp_BayerBG10_Packed == enGvspPixelType \
            or PixelType_Gvsp_BayerGR12_Packed == enGvspPixelType or PixelType_Gvsp_BayerRG12_Packed == enGvspPixelType \
            or PixelType_Gvsp_BayerGB12_Packed == enGvspPixelType or PixelType_Gvsp_BayerBG12_Packed == enGvspPixelType \
            or PixelType_Gvsp_YUV422_Packed == enGvspPixelType or PixelType_Gvsp_YUV422_YUYV_Packed == enGvspPixelType:
        return True
    else:
        return False


# Mono图像转为python数组
def Mono_numpy(data, nWidth, nHeight):
    data_ = np.frombuffer(data, count=int(nWidth * nHeight), dtype=np.uint8, offset=0)
    data_mono_arr = data_.reshape(nHeight, nWidth)
    numArray = np.zeros([nHeight, nWidth, 1], "uint8")
    numArray[:, :, 0] = data_mono_arr
    return numArray


# 彩色图像转为python数组
def Color_numpy(data, nWidth, nHeight):
    data_ = np.frombuffer(data, count=int(nWidth * nHeight * 3), dtype=np.uint8, offset=0)
    data_r = data_[0:nWidth * nHeight * 3:3]
    data_g = data_[1:nWidth * nHeight * 3:3]
    data_b = data_[2:nWidth * nHeight * 3:3]

    data_r_arr = data_r.reshape(nHeight, nWidth)
    data_g_arr = data_g.reshape(nHeight, nWidth)
    data_b_arr = data_b.reshape(nHeight, nWidth)
    numArray = np.zeros([nHeight, nWidth, 3], "uint8")

    numArray[:, :, 0] = data_r_arr
    numArray[:, :, 1] = data_g_arr
    numArray[:, :, 2] = data_b_arr
    return numArray


# 相机操作类
class CameraOperation:

    def __init__(self, obj_cam, st_device_list, n_connect_num=0, b_open_device=False, b_start_grabbing=False,
                 h_thread_handle=None,
                 b_thread_closed=False, st_frame_info=None, b_exit=False, b_save_bmp=False, b_save_jpg=False,
                 buf_save_image=None,
                 n_save_image_size=0, n_win_gui_id=0, frame_rate=0, exposure_time=0, gain=0):

        self.obj_cam = obj_cam
        self.st_device_list = st_device_list
        self.n_connect_num = n_connect_num
        self.b_open_device = b_open_device
        self.b_start_grabbing = b_start_grabbing
        self.b_thread_closed = b_thread_closed
        self.st_frame_info = st_frame_info
        self.b_exit = b_exit
        self.b_save_bmp = b_save_bmp
        self.b_save_jpg = b_save_jpg
        self.buf_save_image = buf_save_image
        self.n_save_image_size = n_save_image_size
        self.h_thread_handle = h_thread_handle
        self.b_thread_closed
        self.frame_rate = frame_rate
        self.exposure_time = exposure_time
        self.gain = gain
        self.buf_lock = threading.Lock()  # 取图和存图的buffer锁

    # 打开相机
    def Open_device(self):
        if not self.b_open_device:
            if self.n_connect_num < 0:
                return MV_E_CALLORDER

            # ch:选择设备并创建句柄 | en:Select device and create handle
            nConnectionNum = int(self.n_connect_num)
            stDeviceList = cast(self.st_device_list.pDeviceInfo[int(nConnectionNum)],
                                POINTER(MV_CC_DEVICE_INFO)).contents
            self.obj_cam = MvCamera()
            ret = self.obj_cam.MV_CC_CreateHandle(stDeviceList)
            if ret != 0:
                self.obj_cam.MV_CC_DestroyHandle()
                return ret

            ret = self.obj_cam.MV_CC_OpenDevice()
            if ret != 0:
                return ret
            print("open device successfully!")
            self.b_open_device = True
            self.b_thread_closed = False

            # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
            if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
                nPacketSize = self.obj_cam.MV_CC_GetOptimalPacketSize()
                if int(nPacketSize) > 0:
                    ret = self.obj_cam.MV_CC_SetIntValue("GevSCPSPacketSize", nPacketSize)
                    if ret != 0:
                        print("warning: set packet size fail! ret[0x%x]" % ret)
                else:
                    print("warning: set packet size fail! ret[0x%x]" % nPacketSize)

            stBool = c_bool(False)
            ret = self.obj_cam.MV_CC_GetBoolValue("AcquisitionFrameRateEnable", stBool)
            if ret != 0:
                print("get acquisition frame rate enable fail! ret[0x%x]" % ret)

            # ch:设置触发模式为off | en:Set trigger mode as off
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
            if ret != 0:
                print("set trigger mode fail! ret[0x%x]" % ret)
            return MV_OK

    # 开始取图
    def Start_grabbing(self, winHandle):
        if not self.b_start_grabbing and self.b_open_device:
            self.b_exit = False
            ret = self.obj_cam.MV_CC_StartGrabbing()
            if ret != 0:
                return ret
            self.b_start_grabbing = True
            print("start grabbing successfully!")
            try:
                thread_id = random.randint(1, 10000)
                self.h_thread_handle = threading.Thread(target=CameraOperation.Work_thread, args=(self, winHandle))
                self.h_thread_handle.start()
                self.b_thread_closed = True
            finally:
                pass
            return MV_OK

        return MV_E_CALLORDER

    # 停止取图
    def Stop_grabbing(self):
        if self.b_start_grabbing and self.b_open_device:
            # 退出线程
            if self.b_thread_closed:
                Stop_thread(self.h_thread_handle)
                self.b_thread_closed = False
            ret = self.obj_cam.MV_CC_StopGrabbing()
            if ret != 0:
                return ret
            print("stop grabbing successfully!")
            self.b_start_grabbing = False
            self.b_exit = True
            return MV_OK
        else:
            return MV_E_CALLORDER

    # 关闭相机
    def Close_device(self):
        if self.b_open_device:
            # 退出线程
            if self.b_thread_closed:
                Stop_thread(self.h_thread_handle)
                self.b_thread_closed = False
            ret = self.obj_cam.MV_CC_CloseDevice()
            if ret != 0:
                return ret

        # ch:销毁句柄 | Destroy handle
        self.obj_cam.MV_CC_DestroyHandle()
        self.b_open_device = False
        self.b_start_grabbing = False
        self.b_exit = True
        print("close device successfully!")

        return MV_OK

    # 设置触发模式
    def Set_trigger_mode(self, is_trigger_mode):
        if not self.b_open_device:
            return MV_E_CALLORDER

        if not is_trigger_mode:
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerMode", 0)
            if ret != 0:
                return ret
        else:
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerMode", 1)
            if ret != 0:
                return ret
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerSource", 7)
            if ret != 0:
                return ret

        return MV_OK

    # 软触发一次
    def Trigger_once(self):
        if self.b_open_device:
            return self.obj_cam.MV_CC_SetCommandValue("TriggerSoftware")

    # 获取参数
    def Get_parameter(self):
        if self.b_open_device:
            stFloatParam_FrameRate = MVCC_FLOATVALUE()
            memset(byref(stFloatParam_FrameRate), 0, sizeof(MVCC_FLOATVALUE))
            stFloatParam_exposureTime = MVCC_FLOATVALUE()
            memset(byref(stFloatParam_exposureTime), 0, sizeof(MVCC_FLOATVALUE))
            stFloatParam_gain = MVCC_FLOATVALUE()
            memset(byref(stFloatParam_gain), 0, sizeof(MVCC_FLOATVALUE))
            ret = self.obj_cam.MV_CC_GetFloatValue("AcquisitionFrameRate", stFloatParam_FrameRate)
            if ret != 0:
                return ret
            self.frame_rate = stFloatParam_FrameRate.fCurValue

            ret = self.obj_cam.MV_CC_GetFloatValue("ExposureTime", stFloatParam_exposureTime)
            if ret != 0:
                return ret
            self.exposure_time = stFloatParam_exposureTime.fCurValue

            ret = self.obj_cam.MV_CC_GetFloatValue("Gain", stFloatParam_gain)
            if ret != 0:
                return ret
            self.gain = stFloatParam_gain.fCurValue

            return MV_OK

    # 设置参数
    def Set_parameter(self, frameRate, exposureTime, gain):
        if '' == frameRate or '' == exposureTime or '' == gain:
            print('show info', 'please type in the text box !')
            return MV_E_PARAMETER
        if self.b_open_device:
            ret = self.obj_cam.MV_CC_SetEnumValue("ExposureAuto", 0)
            time.sleep(0.2)
            ret = self.obj_cam.MV_CC_SetFloatValue("ExposureTime", float(exposureTime))
            if ret != 0:
                print('show error', 'set exposure time fail! ret = ' + To_hex_str(ret))
                return ret

            ret = self.obj_cam.MV_CC_SetFloatValue("Gain", float(gain))
            if ret != 0:
                print('show error', 'set gain fail! ret = ' + To_hex_str(ret))
                return ret

            ret = self.obj_cam.MV_CC_SetFloatValue("AcquisitionFrameRate", float(frameRate))
            if ret != 0:
                print('show error', 'set acquistion frame rate fail! ret = ' + To_hex_str(ret))
                return ret

            print('show info', 'set parameter success!')

            return MV_OK

    # 取图线程函数
    def Work_thread(self, winHandle):
        stOutFrame = MV_FRAME_OUT()
        memset(byref(stOutFrame), 0, sizeof(stOutFrame))

        while True:
            ret = self.obj_cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
            if 0 == ret:
                # 拷贝图像和图像信息
                if self.buf_save_image is None:
                    self.buf_save_image = (c_ubyte * stOutFrame.stFrameInfo.nFrameLen)()
                self.st_frame_info = stOutFrame.stFrameInfo

                # 获取缓存锁
                self.buf_lock.acquire()
                cdll.msvcrt.memcpy(byref(self.buf_save_image), stOutFrame.pBufAddr, self.st_frame_info.nFrameLen)
                self.buf_lock.release()

                print("get one frame: Width[%d], Height[%d], nFrameNum[%d]"
                      % (self.st_frame_info.nWidth, self.st_frame_info.nHeight, self.st_frame_info.nFrameNum))
                # 释放缓存
                self.obj_cam.MV_CC_FreeImageBuffer(stOutFrame)
            else:
                print("no data, ret = " + To_hex_str(ret))
                continue

            # 使用Display接口显示图像
            stDisplayParam = MV_DISPLAY_FRAME_INFO()
            memset(byref(stDisplayParam), 0, sizeof(stDisplayParam))
            stDisplayParam.hWnd = int(winHandle)
            stDisplayParam.nWidth = self.st_frame_info.nWidth
            stDisplayParam.nHeight = self.st_frame_info.nHeight
            stDisplayParam.enPixelType = self.st_frame_info.enPixelType
            stDisplayParam.pData = self.buf_save_image
            stDisplayParam.nDataLen = self.st_frame_info.nFrameLen
            self.obj_cam.MV_CC_DisplayOneFrame(stDisplayParam)

            # 是否退出
            if self.b_exit:
                if self.buf_save_image is not None:
                    del self.buf_save_image
                break

    # 存jpg图像
    def Save_jpg(self):

        if self.buf_save_image is None:
            return

        # 获取缓存锁
        self.buf_lock.acquire()

        file_path = str(self.st_frame_info.nFrameNum) + ".jpg"
        c_file_path = file_path.encode('ascii')
        stSaveParam = MV_SAVE_IMAGE_TO_FILE_PARAM_EX()
        stSaveParam.enPixelType = self.st_frame_info.enPixelType  # ch:相机对应的像素格式 | en:Camera pixel type
        stSaveParam.nWidth = self.st_frame_info.nWidth  # ch:相机对应的宽 | en:Width
        stSaveParam.nHeight = self.st_frame_info.nHeight  # ch:相机对应的高 | en:Height
        stSaveParam.nDataLen = self.st_frame_info.nFrameLen
        stSaveParam.pData = cast(self.buf_save_image, POINTER(c_ubyte))
        stSaveParam.enImageType = MV_Image_Jpeg  # ch:需要保存的图像类型 | en:Image format to save
        stSaveParam.nQuality = 80
        stSaveParam.pcImagePath = ctypes.create_string_buffer(c_file_path)
        stSaveParam.iMethodValue = 1
        ret = self.obj_cam.MV_CC_SaveImageToFileEx(stSaveParam)

        self.buf_lock.release()
        return ret

    # 存BMP图像
    def Save_Bmp(self):

        if 0 == self.buf_save_image:
            return

        # 获取缓存锁
        self.buf_lock.acquire()

        file_path = str(self.st_frame_info.nFrameNum) + ".bmp"
        c_file_path = file_path.encode('ascii')

        stSaveParam = MV_SAVE_IMAGE_TO_FILE_PARAM_EX()
        stSaveParam.enPixelType = self.st_frame_info.enPixelType  # ch:相机对应的像素格式 | en:Camera pixel type
        stSaveParam.nWidth = self.st_frame_info.nWidth  # ch:相机对应的宽 | en:Width
        stSaveParam.nHeight = self.st_frame_info.nHeight  # ch:相机对应的高 | en:Height
        stSaveParam.nDataLen = self.st_frame_info.nFrameLen
        stSaveParam.pData = cast(self.buf_save_image, POINTER(c_ubyte))
        stSaveParam.enImageType = MV_Image_Bmp  # ch:需要保存的图像类型 | en:Image format to save
        stSaveParam.pcImagePath = ctypes.create_string_buffer(c_file_path)
        stSaveParam.iMethodValue = 1
        ret = self.obj_cam.MV_CC_SaveImageToFileEx(stSaveParam)

        self.buf_lock.release()

        return ret



===== .//BasicDemo/PyUICBasicDemo.py =====
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'PyUICBasicDemo.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(747, 486)
        self.centralWidget = QtWidgets.QWidget(MainWindow)
        self.centralWidget.setObjectName("centralWidget")
        self.ComboDevices = QtWidgets.QComboBox(self.centralWidget)
        self.ComboDevices.setGeometry(QtCore.QRect(10, 20, 511, 22))
        self.ComboDevices.setObjectName("ComboDevices")
        self.widgetDisplay = QtWidgets.QWidget(self.centralWidget)
        self.widgetDisplay.setGeometry(QtCore.QRect(10, 60, 511, 401))
        self.widgetDisplay.setObjectName("widgetDisplay")
        self.groupInit = QtWidgets.QGroupBox(self.centralWidget)
        self.groupInit.setGeometry(QtCore.QRect(530, 20, 211, 101))
        self.groupInit.setObjectName("groupInit")
        self.gridLayoutWidget = QtWidgets.QWidget(self.groupInit)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(9, 19, 201, 81))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setContentsMargins(11, 11, 11, 11)
        self.gridLayout.setSpacing(6)
        self.gridLayout.setObjectName("gridLayout")
        self.bnClose = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.bnClose.setEnabled(False)
        self.bnClose.setObjectName("bnClose")
        self.gridLayout.addWidget(self.bnClose, 2, 2, 1, 1)
        self.bnOpen = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.bnOpen.setObjectName("bnOpen")
        self.gridLayout.addWidget(self.bnOpen, 2, 1, 1, 1)
        self.bnEnum = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.bnEnum.setObjectName("bnEnum")
        self.gridLayout.addWidget(self.bnEnum, 1, 1, 1, 2)
        self.groupGrab = QtWidgets.QGroupBox(self.centralWidget)
        self.groupGrab.setEnabled(False)
        self.groupGrab.setGeometry(QtCore.QRect(530, 130, 211, 171))
        self.groupGrab.setObjectName("groupGrab")
        self.gridLayoutWidget_2 = QtWidgets.QWidget(self.groupGrab)
        self.gridLayoutWidget_2.setGeometry(QtCore.QRect(9, 19, 202, 141))
        self.gridLayoutWidget_2.setObjectName("gridLayoutWidget_2")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.gridLayoutWidget_2)
        self.gridLayout_2.setContentsMargins(11, 11, 11, 11)
        self.gridLayout_2.setSpacing(6)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.bnSaveImage = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnSaveImage.setEnabled(False)
        self.bnSaveImage.setObjectName("bnSaveImage")
        self.gridLayout_2.addWidget(self.bnSaveImage, 4, 0, 1, 2)
        self.radioContinueMode = QtWidgets.QRadioButton(self.gridLayoutWidget_2)
        self.radioContinueMode.setObjectName("radioContinueMode")
        self.gridLayout_2.addWidget(self.radioContinueMode, 0, 0, 1, 1)
        self.radioTriggerMode = QtWidgets.QRadioButton(self.gridLayoutWidget_2)
        self.radioTriggerMode.setObjectName("radioTriggerMode")
        self.gridLayout_2.addWidget(self.radioTriggerMode, 0, 1, 1, 1)
        self.bnStop = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnStop.setEnabled(False)
        self.bnStop.setObjectName("bnStop")
        self.gridLayout_2.addWidget(self.bnStop, 2, 1, 1, 1)
        self.bnStart = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnStart.setEnabled(False)
        self.bnStart.setObjectName("bnStart")
        self.gridLayout_2.addWidget(self.bnStart, 2, 0, 1, 1)
        self.bnSoftwareTrigger = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnSoftwareTrigger.setEnabled(False)
        self.bnSoftwareTrigger.setObjectName("bnSoftwareTrigger")
        self.gridLayout_2.addWidget(self.bnSoftwareTrigger, 3, 0, 1, 2)
        self.groupParam = QtWidgets.QGroupBox(self.centralWidget)
        self.groupParam.setEnabled(False)
        self.groupParam.setGeometry(QtCore.QRect(530, 310, 211, 151))
        self.groupParam.setObjectName("groupParam")
        self.gridLayoutWidget_3 = QtWidgets.QWidget(self.groupParam)
        self.gridLayoutWidget_3.setGeometry(QtCore.QRect(10, 20, 201, 131))
        self.gridLayoutWidget_3.setObjectName("gridLayoutWidget_3")
        self.gridLayoutParam = QtWidgets.QGridLayout(self.gridLayoutWidget_3)
        self.gridLayoutParam.setContentsMargins(11, 11, 11, 11)
        self.gridLayoutParam.setSpacing(6)
        self.gridLayoutParam.setObjectName("gridLayoutParam")
        self.label_6 = QtWidgets.QLabel(self.gridLayoutWidget_3)
        self.label_6.setObjectName("label_6")
        self.gridLayoutParam.addWidget(self.label_6, 3, 0, 1, 1)
        self.edtGain = QtWidgets.QLineEdit(self.gridLayoutWidget_3)
        self.edtGain.setObjectName("edtGain")
        self.gridLayoutParam.addWidget(self.edtGain, 1, 1, 1, 1)
        self.label_5 = QtWidgets.QLabel(self.gridLayoutWidget_3)
        self.label_5.setObjectName("label_5")
        self.gridLayoutParam.addWidget(self.label_5, 1, 0, 1, 1)
        self.label_4 = QtWidgets.QLabel(self.gridLayoutWidget_3)
        self.label_4.setObjectName("label_4")
        self.gridLayoutParam.addWidget(self.label_4, 0, 0, 1, 1)
        self.edtExposureTime = QtWidgets.QLineEdit(self.gridLayoutWidget_3)
        self.edtExposureTime.setObjectName("edtExposureTime")
        self.gridLayoutParam.addWidget(self.edtExposureTime, 0, 1, 1, 1)
        self.bnGetParam = QtWidgets.QPushButton(self.gridLayoutWidget_3)
        self.bnGetParam.setObjectName("bnGetParam")
        self.gridLayoutParam.addWidget(self.bnGetParam, 4, 0, 1, 1)
        self.bnSetParam = QtWidgets.QPushButton(self.gridLayoutWidget_3)
        self.bnSetParam.setObjectName("bnSetParam")
        self.gridLayoutParam.addWidget(self.bnSetParam, 4, 1, 1, 1)
        self.edtFrameRate = QtWidgets.QLineEdit(self.gridLayoutWidget_3)
        self.edtFrameRate.setObjectName("edtFrameRate")
        self.gridLayoutParam.addWidget(self.edtFrameRate, 3, 1, 1, 1)
        self.gridLayoutParam.setColumnStretch(0, 2)
        self.gridLayoutParam.setColumnStretch(1, 3)
        MainWindow.setCentralWidget(self.centralWidget)
        self.statusBar = QtWidgets.QStatusBar(MainWindow)
        self.statusBar.setObjectName("statusBar")
        MainWindow.setStatusBar(self.statusBar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.groupInit.setTitle(_translate("MainWindow", "初始化"))
        self.bnClose.setText(_translate("MainWindow", "关闭设备"))
        self.bnOpen.setText(_translate("MainWindow", "打开设备"))
        self.bnEnum.setText(_translate("MainWindow", "查找设备"))
        self.groupGrab.setTitle(_translate("MainWindow", "采集"))
        self.bnSaveImage.setText(_translate("MainWindow", "保存图像"))
        self.radioContinueMode.setText(_translate("MainWindow", "连续模式"))
        self.radioTriggerMode.setText(_translate("MainWindow", "触发模式"))
        self.bnStop.setText(_translate("MainWindow", "停止采集"))
        self.bnStart.setText(_translate("MainWindow", "开始采集"))
        self.bnSoftwareTrigger.setText(_translate("MainWindow", "软触发一次"))
        self.groupParam.setTitle(_translate("MainWindow", "参数"))
        self.label_6.setText(_translate("MainWindow", "帧率"))
        self.edtGain.setText(_translate("MainWindow", "0"))
        self.label_5.setText(_translate("MainWindow", "增益"))
        self.label_4.setText(_translate("MainWindow", "曝光"))
        self.edtExposureTime.setText(_translate("MainWindow", "0"))
        self.bnGetParam.setText(_translate("MainWindow", "获取参数"))
        self.bnSetParam.setText(_translate("MainWindow", "设置参数"))
        self.edtFrameRate.setText(_translate("MainWindow", "0"))


===== .//BasicDemoByGenTL/BasicDemoByGenTL.py =====
# -- coding: utf-8 --
import os

from PyQt5.QtWidgets import *
from CamOperation_class import CameraOperation
from MvCameraControl_class import *
from MvErrorDefine_const import *
from CameraParams_header import *
from PyUICBasicDemoByGenTL import Ui_MainWindow


# 获取选取设备信息的索引，通过[]之间的字符去解析
def TxtWrapBy(start_str, end, all):
    start = all.find(start_str)
    if start >= 0:
        start += len(start_str)
        end = all.find(end, start)
        if end >= 0:
            return all[start:end].strip()


# 将返回的错误码转换为十六进制显示
def ToHexStr(num):
    chaDic = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}
    hexStr = ""
    if num < 0:
        num = num + 2 ** 32
    while num >= 16:
        digit = num % 16
        hexStr = chaDic.get(digit, str(digit)) + hexStr
        num //= 16
    hexStr = chaDic.get(num, str(num)) + hexStr
    return hexStr


if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    global deviceList
    deviceList = MV_GENTL_DEV_INFO_LIST()

    global interfaceList
    interfaceList = MV_GENTL_IF_INFO_LIST()

    global cam
    cam = MvCamera()
    global nSelCamIndex
    nSelCamIndex = 0
    global obj_cam_operation
    obj_cam_operation = 0
    global isOpen
    isOpen = False
    global isGrabbing
    isGrabbing = False
    global isCalibMode  # 是否是标定模式（获取原始图像）
    isCalibMode = True


    # 绑定下拉列表至设备信息索引
    def xFunc(event):
        global nSelCamIndex
        nSelCamIndex = TxtWrapBy("[", "]", ui.comboDevice.get())

    # ch:枚举采集卡 | en:enum interfaces
    def enum_interfaces():
        global interfaceList
        global obj_cam_operation

        # 对话框选择cti文件
        fileName, fileType = QFileDialog.getOpenFileName(mainWindow, "选择cti文件",
                                                         directory="C:\\Program Files (x86)\\Common "
                                                                   "Files\\VisionEye\\Runtime\\Win64_x64",
                                                         filter="Cti文件(*cti)")
        if fileName is None or len(fileName) == 0:
            return -1

        interfaceList = MV_GENTL_IF_INFO_LIST()
        ret = MvCamera.MV_CC_EnumInterfacesByGenTL(interfaceList, fileName)
        if ret != 0:
            strError = "Enum interfaces fail! ret = :" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
            return ret

        if interfaceList.nInterfaceNum == 0:
            QMessageBox.warning(mainWindow, "Info", "Find no interface", QMessageBox.Ok)
            return ret
        print("Find %d interfaces!" % interfaceList.nInterfaceNum)

        ifListTemp = []
        for i in range(0, interfaceList.nInterfaceNum):
            ifInfoTemp = cast(interfaceList.pIFInfo[i], POINTER(MV_GENTL_IF_INFO)).contents
            chTLType = ""
            for per in ifInfoTemp.chTLType:
                if 0 == per:
                    break
                chTLType = chTLType + chr(per)

            chInterfaceID = ""
            for per in ifInfoTemp.chInterfaceID:
                if 0 == per:
                    break
                chInterfaceID = chInterfaceID + chr(per)

            chDisplayName = ""
            for per in ifInfoTemp.chDisplayName:
                if 0 == per:
                    break
                chDisplayName = chDisplayName + chr(per)

            ifListTemp.append("[" + str(i) + "] " + chTLType + ": " + chInterfaceID + " " + chDisplayName)

        ui.comboInterface.clear()
        ui.comboInterface.addItems(ifListTemp)
        ui.comboInterface.setCurrentIndex(0)

    # ch:枚举相机 | en:enum devices
    def enum_devices():
        global deviceList
        global interfaceList
        global obj_cam_operation

        deviceList = MV_GENTL_DEV_INFO_LIST()
        nIFIndex = ui.comboInterface.currentIndex()
        ret = MvCamera.MV_CC_EnumDevicesByGenTL(interfaceList.pIFInfo[nIFIndex], deviceList)
        if ret != 0:
            strError = "Enum devices fail! ret = :" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
            return ret

        if deviceList.nDeviceNum == 0:
            QMessageBox.warning(mainWindow, "Info", "Find no device", QMessageBox.Ok)
            return ret
        print("Find %d devices!" % deviceList.nDeviceNum)

        devListTemp = []
        for i in range(0, deviceList.nDeviceNum):
            devInfoTemp = cast(deviceList.pDeviceInfo[i], POINTER(MV_GENTL_DEV_INFO)).contents

            chDeviceID = ""
            for per in devInfoTemp.chDeviceID:
                if 0 == per:
                    break
                chDeviceID = chDeviceID + chr(per)
            devListTemp.append("[" + str(i) + "] " + chDeviceID)

        ui.comboDevice.clear()
        ui.comboDevice.addItems(devListTemp)
        ui.comboDevice.setCurrentIndex(0)

    # ch:打开相机 | en:open device
    def open_device():
        global deviceList
        global nSelCamIndex
        global obj_cam_operation
        global isOpen
        if isOpen:
            QMessageBox.warning(mainWindow, "Error", 'Camera is Running!', QMessageBox.Ok)
            return MV_E_CALLORDER

        nSelCamIndex = ui.comboDevice.currentIndex()
        if nSelCamIndex < 0:
            QMessageBox.warning(mainWindow, "Error", 'Please select a camera!', QMessageBox.Ok)
            return MV_E_CALLORDER

        obj_cam_operation = CameraOperation(cam, deviceList, nSelCamIndex)
        ret = obj_cam_operation.Open_device()
        if 0 != ret:
            strError = "Open device failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
            isOpen = False
        else:
            set_continue_mode()

            get_param()

            isOpen = True
            enable_controls()

    # ch:开始取流 | en:Start grab image
    def start_grabbing():
        global obj_cam_operation
        global isGrabbing

        ret = obj_cam_operation.Start_grabbing(ui.widgetDisplay.winId())
        if ret != 0:
            strError = "Start grabbing failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            isGrabbing = True
            enable_controls()

    # ch:停止取流 | en:Stop grab image
    def stop_grabbing():
        global obj_cam_operation
        global isGrabbing
        ret = obj_cam_operation.Stop_grabbing()
        if ret != 0:
            strError = "Stop grabbing failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            isGrabbing = False
            enable_controls()

    # ch:关闭设备 | Close device
    def close_device():
        global isOpen
        global isGrabbing
        global obj_cam_operation

        if isOpen:
            obj_cam_operation.Close_device()
            isOpen = False

        isGrabbing = False

        enable_controls()

    # ch:设置触发模式 | en:set trigger mode
    def set_continue_mode():
        strError = None

        ret = obj_cam_operation.Set_trigger_mode(False)
        if ret != 0:
            strError = "Set continue mode failed ret:" + ToHexStr(ret) + " mode is " + str(is_trigger_mode)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            ui.radioContinueMode.setChecked(True)
            ui.radioTriggerMode.setChecked(False)
            ui.bnSoftwareTrigger.setEnabled(False)

    # 设置软触发模式
    def set_software_trigger_mode():

        ret = obj_cam_operation.Set_trigger_mode(True)
        if ret != 0:
            strError = "Set trigger mode failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            ui.radioContinueMode.setChecked(False)
            ui.radioTriggerMode.setChecked(True)
            ui.bnSoftwareTrigger.setEnabled(isGrabbing)

    # ch:设置触发命令 | en:set trigger software
    def trigger_once():
        ret = obj_cam_operation.Trigger_once()
        if ret != 0:
            strError = "TriggerSoftware failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)

    # ch:存图
    def save_bmp():
        ret = obj_cam_operation.Save_Bmp()
        if ret != MV_OK:
            strError = "Save BMP failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            print("Save image success")

    # ch: 获取参数
    def get_param():
        ret = obj_cam_operation.Get_parameter()
        if ret != MV_OK:
            strError = "Get param failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)
        else:
            ui.edtExposureTime.setText("{0:.2f}".format(obj_cam_operation.exposure_time))
            ui.edtGain.setText("{0:.2f}".format(obj_cam_operation.gain))
            ui.edtFrameRate.setText("{0:.2f}".format(obj_cam_operation.frame_rate))

    # ch: 设置参数
    def set_param():
        frame_rate = ui.edtFrameRate.text()
        exposure = ui.edtExposureTime.text()
        gain = ui.edtGain.text()
        ret = obj_cam_operation.Set_parameter(frame_rate, exposure, gain)
        if ret != MV_OK:
            strError = "Set param failed ret:" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", strError, QMessageBox.Ok)

        return MV_OK

    # 设置控件状态
    def enable_controls():
        global isGrabbing
        global isOpen

        # 先设置group的状态，再单独设置各控件状态
        ui.groupGrab.setEnabled(isOpen)
        ui.groupParam.setEnabled(isOpen)

        ui.bnOpen.setEnabled(not isOpen)
        ui.bnClose.setEnabled(isOpen)

        ui.bnStart.setEnabled(isOpen and (not isGrabbing))
        ui.bnStop.setEnabled(isOpen and isGrabbing)
        ui.bnSoftwareTrigger.setEnabled(isGrabbing and ui.radioTriggerMode.isChecked())

        ui.bnSaveImage.setEnabled(isOpen and isGrabbing)

    # 初始化app, 绑定控件与函数
    app = QApplication(sys.argv)
    mainWindow = QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(mainWindow)
    ui.bnEnumInterface.clicked.connect(enum_interfaces)
    ui.bnEnumDevice.clicked.connect(enum_devices)
    ui.bnOpen.clicked.connect(open_device)
    ui.bnClose.clicked.connect(close_device)
    ui.bnStart.clicked.connect(start_grabbing)
    ui.bnStop.clicked.connect(stop_grabbing)

    ui.bnSoftwareTrigger.clicked.connect(trigger_once)
    ui.radioTriggerMode.clicked.connect(set_software_trigger_mode)
    ui.radioContinueMode.clicked.connect(set_continue_mode)

    ui.bnGetParam.clicked.connect(get_param)
    ui.bnSetParam.clicked.connect(set_param)

    ui.bnSaveImage.clicked.connect(save_bmp)

    mainWindow.show()

    app.exec_()

    close_device()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()

    sys.exit()


===== .//BasicDemoByGenTL/CamOperation_class.py =====
# -- coding: utf-8 --
import sys
import threading
import msvcrt
import numpy as np
import time
import sys, os
import datetime
import inspect
import ctypes
import random
from ctypes import *

sys.path.append("../MvImport")

from CameraParams_header import *
from MvCameraControl_class import *

# 强制关闭线程
def Async_raise(tid, exctype):
    tid = ctypes.c_long(tid)
    if not inspect.isclass(exctype):
        exctype = type(exctype)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))
    if res == 0:
        raise ValueError("invalid thread id")
    elif res != 1:
        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)
        raise SystemError("PyThreadState_SetAsyncExc failed")


# 停止线程
def Stop_thread(thread):
    Async_raise(thread.ident, SystemExit)


# 转为16进制字符串
def To_hex_str(num):
    chaDic = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}
    hexStr = ""
    if num < 0:
        num = num + 2 ** 32
    while num >= 16:
        digit = num % 16
        hexStr = chaDic.get(digit, str(digit)) + hexStr
        num //= 16
    hexStr = chaDic.get(num, str(num)) + hexStr
    return hexStr


# 是否是Mono图像
def Is_mono_data(enGvspPixelType):
    if PixelType_Gvsp_Mono8 == enGvspPixelType or PixelType_Gvsp_Mono10 == enGvspPixelType \
            or PixelType_Gvsp_Mono10_Packed == enGvspPixelType or PixelType_Gvsp_Mono12 == enGvspPixelType \
            or PixelType_Gvsp_Mono12_Packed == enGvspPixelType:
        return True
    else:
        return False


# 是否是彩色图像
def Is_color_data(enGvspPixelType):
    if PixelType_Gvsp_BayerGR8 == enGvspPixelType or PixelType_Gvsp_BayerRG8 == enGvspPixelType \
            or PixelType_Gvsp_BayerGB8 == enGvspPixelType or PixelType_Gvsp_BayerBG8 == enGvspPixelType \
            or PixelType_Gvsp_BayerGR10 == enGvspPixelType or PixelType_Gvsp_BayerRG10 == enGvspPixelType \
            or PixelType_Gvsp_BayerGB10 == enGvspPixelType or PixelType_Gvsp_BayerBG10 == enGvspPixelType \
            or PixelType_Gvsp_BayerGR12 == enGvspPixelType or PixelType_Gvsp_BayerRG12 == enGvspPixelType \
            or PixelType_Gvsp_BayerGB12 == enGvspPixelType or PixelType_Gvsp_BayerBG12 == enGvspPixelType \
            or PixelType_Gvsp_BayerGR10_Packed == enGvspPixelType or PixelType_Gvsp_BayerRG10_Packed == enGvspPixelType \
            or PixelType_Gvsp_BayerGB10_Packed == enGvspPixelType or PixelType_Gvsp_BayerBG10_Packed == enGvspPixelType \
            or PixelType_Gvsp_BayerGR12_Packed == enGvspPixelType or PixelType_Gvsp_BayerRG12_Packed == enGvspPixelType \
            or PixelType_Gvsp_BayerGB12_Packed == enGvspPixelType or PixelType_Gvsp_BayerBG12_Packed == enGvspPixelType \
            or PixelType_Gvsp_YUV422_Packed == enGvspPixelType or PixelType_Gvsp_YUV422_YUYV_Packed == enGvspPixelType:
        return True
    else:
        return False


# Mono图像转为python数组
def Mono_numpy(data, nWidth, nHeight):
    data_ = np.frombuffer(data, count=int(nWidth * nHeight), dtype=np.uint8, offset=0)
    data_mono_arr = data_.reshape(nHeight, nWidth)
    numArray = np.zeros([nHeight, nWidth, 1], "uint8")
    numArray[:, :, 0] = data_mono_arr
    return numArray


# 彩色图像转为python数组
def Color_numpy(data, nWidth, nHeight):
    data_ = np.frombuffer(data, count=int(nWidth * nHeight * 3), dtype=np.uint8, offset=0)
    data_r = data_[0:nWidth * nHeight * 3:3]
    data_g = data_[1:nWidth * nHeight * 3:3]
    data_b = data_[2:nWidth * nHeight * 3:3]

    data_r_arr = data_r.reshape(nHeight, nWidth)
    data_g_arr = data_g.reshape(nHeight, nWidth)
    data_b_arr = data_b.reshape(nHeight, nWidth)
    numArray = np.zeros([nHeight, nWidth, 3], "uint8")

    numArray[:, :, 0] = data_r_arr
    numArray[:, :, 1] = data_g_arr
    numArray[:, :, 2] = data_b_arr
    return numArray


# 相机操作类
class CameraOperation:

    def __init__(self, obj_cam, st_device_list, n_connect_num=0, b_open_device=False, b_start_grabbing=False,
                 h_thread_handle=None,
                 b_thread_closed=False, st_frame_info=None, b_exit=False, b_save_bmp=False, b_save_jpg=False,
                 buf_save_image=None,
                 n_save_image_size=0, n_win_gui_id=0, frame_rate=0, exposure_time=0, gain=0):

        self.obj_cam = obj_cam
        self.st_device_list = st_device_list
        self.n_connect_num = n_connect_num
        self.b_open_device = b_open_device
        self.b_start_grabbing = b_start_grabbing
        self.b_thread_closed = b_thread_closed
        self.st_frame_info = st_frame_info
        self.b_exit = b_exit
        self.b_save_bmp = b_save_bmp
        self.b_save_jpg = b_save_jpg
        self.buf_save_image = buf_save_image
        self.n_save_image_size = n_save_image_size
        self.h_thread_handle = h_thread_handle
        self.b_thread_closed
        self.frame_rate = frame_rate
        self.exposure_time = exposure_time
        self.gain = gain
        self.buf_lock = threading.Lock()  # 取图和存图的buffer锁

    # 打开相机
    def Open_device(self):
        if not self.b_open_device:
            if self.n_connect_num < 0:
                return MV_E_CALLORDER

            # ch:选择设备并创建句柄 | en:Select device and create handle
            nConnectionNum = int(self.n_connect_num)
            stDeviceInfo = cast(self.st_device_list.pDeviceInfo[int(nConnectionNum)],
                                POINTER(MV_GENTL_DEV_INFO)).contents
            self.obj_cam = MvCamera()
            ret = self.obj_cam.MV_CC_CreateHandleByGenTL(stDeviceInfo)
            if ret != 0:
                self.obj_cam.MV_CC_DestroyHandle()
                return ret

            ret = self.obj_cam.MV_CC_OpenDevice()
            if ret != 0:
                return ret
            print("open device successfully!")
            self.b_open_device = True
            self.b_thread_closed = False

            stBool = c_bool(False)
            ret = self.obj_cam.MV_CC_GetBoolValue("AcquisitionFrameRateEnable", stBool)
            if ret != 0:
                print("get acquisition frame rate enable fail! ret[0x%x]" % ret)

            # ch:设置触发模式为off | en:Set trigger mode as off
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
            if ret != 0:
                print("set trigger mode fail! ret[0x%x]" % ret)
            return MV_OK

    # 开始取图
    def Start_grabbing(self, winHandle):
        if not self.b_start_grabbing and self.b_open_device:
            self.b_exit = False
            ret = self.obj_cam.MV_CC_StartGrabbing()
            if ret != 0:
                return ret
            self.b_start_grabbing = True
            print("start grabbing successfully!")
            try:
                thread_id = random.randint(1, 10000)
                self.h_thread_handle = threading.Thread(target=CameraOperation.Work_thread, args=(self, winHandle))
                self.h_thread_handle.start()
                self.b_thread_closed = True
            finally:
                pass
            return MV_OK

        return MV_E_CALLORDER

    # 停止取图
    def Stop_grabbing(self):
        if self.b_start_grabbing and self.b_open_device:
            # 退出线程
            if self.b_thread_closed:
                Stop_thread(self.h_thread_handle)
                self.b_thread_closed = False
            ret = self.obj_cam.MV_CC_StopGrabbing()
            if ret != 0:
                return ret
            print("stop grabbing successfully!")
            self.b_start_grabbing = False
            self.b_exit = True
            return MV_OK
        else:
            return MV_E_CALLORDER

    # 关闭相机
    def Close_device(self):
        if self.b_open_device:
            # 退出线程
            if self.b_thread_closed:
                Stop_thread(self.h_thread_handle)
                self.b_thread_closed = False
            ret = self.obj_cam.MV_CC_CloseDevice()
            if ret != 0:
                return ret

        # ch:销毁句柄 | Destroy handle
        self.obj_cam.MV_CC_DestroyHandle()
        self.b_open_device = False
        self.b_start_grabbing = False
        self.b_exit = True
        print("close device successfully!")

        return MV_OK

    # 设置触发模式
    def Set_trigger_mode(self, is_trigger_mode):
        if not self.b_open_device:
            return MV_E_CALLORDER

        if not is_trigger_mode:
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerMode", 0)
            if ret != 0:
                return ret
        else:
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerMode", 1)
            if ret != 0:
                return ret
            ret = self.obj_cam.MV_CC_SetEnumValue("TriggerSource", 7)
            if ret != 0:
                return ret

        return MV_OK

    # 软触发一次
    def Trigger_once(self):
        if self.b_open_device:
            return self.obj_cam.MV_CC_SetCommandValue("TriggerSoftware")

    # 获取参数
    def Get_parameter(self):
        if self.b_open_device:
            stFloatParam_FrameRate = MVCC_FLOATVALUE()
            memset(byref(stFloatParam_FrameRate), 0, sizeof(MVCC_FLOATVALUE))
            stFloatParam_exposureTime = MVCC_FLOATVALUE()
            memset(byref(stFloatParam_exposureTime), 0, sizeof(MVCC_FLOATVALUE))
            stFloatParam_gain = MVCC_FLOATVALUE()
            memset(byref(stFloatParam_gain), 0, sizeof(MVCC_FLOATVALUE))
            ret = self.obj_cam.MV_CC_GetFloatValue("AcquisitionFrameRate", stFloatParam_FrameRate)
            if ret != 0:
                return ret
            self.frame_rate = stFloatParam_FrameRate.fCurValue

            ret = self.obj_cam.MV_CC_GetFloatValue("ExposureTime", stFloatParam_exposureTime)
            if ret != 0:
                return ret
            self.exposure_time = stFloatParam_exposureTime.fCurValue

            ret = self.obj_cam.MV_CC_GetFloatValue("Gain", stFloatParam_gain)
            if ret != 0:
                return ret
            self.gain = stFloatParam_gain.fCurValue

            return MV_OK

    # 设置参数
    def Set_parameter(self, frameRate, exposureTime, gain):
        if '' == frameRate or '' == exposureTime or '' == gain:
            print('show info', 'please type in the text box !')
            return MV_E_PARAMETER
        if self.b_open_device:
            ret = self.obj_cam.MV_CC_SetEnumValue("ExposureAuto", 0)
            time.sleep(0.2)
            ret = self.obj_cam.MV_CC_SetFloatValue("ExposureTime", float(exposureTime))
            if ret != 0:
                print('show error', 'set exposure time fail! ret = ' + To_hex_str(ret))
                return ret

            ret = self.obj_cam.MV_CC_SetFloatValue("Gain", float(gain))
            if ret != 0:
                print('show error', 'set gain fail! ret = ' + To_hex_str(ret))
                return ret

            ret = self.obj_cam.MV_CC_SetFloatValue("AcquisitionFrameRate", float(frameRate))
            if ret != 0:
                print('show error', 'set acquistion frame rate fail! ret = ' + To_hex_str(ret))
                return ret

            print('show info', 'set parameter success!')

            return MV_OK

    # 取图线程函数
    def Work_thread(self, winHandle):
        stOutFrame = MV_FRAME_OUT()
        memset(byref(stOutFrame), 0, sizeof(stOutFrame))
        while True:

            ret = self.obj_cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
            if 0 == ret:
                # 拷贝图像和图像信息
                if self.buf_save_image is None:
                    self.buf_save_image = (c_ubyte * stOutFrame.stFrameInfo.nFrameLen)()
                self.st_frame_info = stOutFrame.stFrameInfo

                # 获取缓存锁
                self.buf_lock.acquire()
                cdll.msvcrt.memcpy(byref(self.buf_save_image), stOutFrame.pBufAddr, self.st_frame_info.nFrameLen)
                self.buf_lock.release()

                print("get one frame: Width[%d], Height[%d], nFrameNum[%d]"
                      % (self.st_frame_info.nWidth, self.st_frame_info.nHeight, self.st_frame_info.nFrameNum))
                # 释放缓存
                self.obj_cam.MV_CC_FreeImageBuffer(stOutFrame)
            else:
                print("no data, ret = " + To_hex_str(ret))
                continue

            # 使用Display接口显示图像
            stDisplayParam = MV_DISPLAY_FRAME_INFO()
            memset(byref(stDisplayParam), 0, sizeof(stDisplayParam))
            stDisplayParam.hWnd = int(winHandle)
            stDisplayParam.nWidth = self.st_frame_info.nWidth
            stDisplayParam.nHeight = self.st_frame_info.nHeight
            stDisplayParam.enPixelType = self.st_frame_info.enPixelType
            stDisplayParam.pData = self.buf_save_image
            stDisplayParam.nDataLen = self.st_frame_info.nFrameLen
            self.obj_cam.MV_CC_DisplayOneFrame(stDisplayParam)

            # 是否退出
            if self.b_exit:
                if self.buf_save_image is not None:
                    del self.buf_save_image
                break

    # 存jpg图像
    def Save_jpg(self):

        if self.buf_save_image is None:
            return

        # 获取缓存锁
        self.buf_lock.acquire()

        file_path = str(self.st_frame_info.nFrameNum) + ".jpg"
        c_file_path = file_path.encode('ascii')
        stSaveParam = MV_SAVE_IMAGE_TO_FILE_PARAM_EX()
        stSaveParam.enPixelType = self.st_frame_info.enPixelType  # ch:相机对应的像素格式 | en:Camera pixel type
        stSaveParam.nWidth = self.st_frame_info.nWidth  # ch:相机对应的宽 | en:Width
        stSaveParam.nHeight = self.st_frame_info.nHeight  # ch:相机对应的高 | en:Height
        stSaveParam.nDataLen = self.st_frame_info.nFrameLen
        stSaveParam.pData = cast(self.buf_save_image, POINTER(c_ubyte))
        stSaveParam.enImageType = MV_Image_Jpeg  # ch:需要保存的图像类型 | en:Image format to save
        stSaveParam.nQuality = 80
        stSaveParam.pcImagePath = ctypes.create_string_buffer(c_file_path)
        stSaveParam.iMethodValue = 1
        ret = self.obj_cam.MV_CC_SaveImageToFileEx(stSaveParam)

        self.buf_lock.release()
        return ret

    # 存BMP图像
    def Save_Bmp(self):

        if 0 == self.buf_save_image:
            return

        # 获取缓存锁
        self.buf_lock.acquire()

        file_path = str(self.st_frame_info.nFrameNum) + ".bmp"
        c_file_path = file_path.encode('ascii')
        stSaveParam = MV_SAVE_IMAGE_TO_FILE_PARAM_EX()
        stSaveParam.enPixelType = self.st_frame_info.enPixelType  # ch:相机对应的像素格式 | en:Camera pixel type
        stSaveParam.nWidth = self.st_frame_info.nWidth  # ch:相机对应的宽 | en:Width
        stSaveParam.nHeight = self.st_frame_info.nHeight  # ch:相机对应的高 | en:Height
        stSaveParam.nDataLen = self.st_frame_info.nFrameLen
        stSaveParam.pData = cast(self.buf_save_image, POINTER(c_ubyte))
        stSaveParam.enImageType = MV_Image_Bmp  # ch:需要保存的图像类型 | en:Image format to save
        stSaveParam.pcImagePath = ctypes.create_string_buffer(c_file_path)
        stSaveParam.iMethodValue = 1
        ret = self.obj_cam.MV_CC_SaveImageToFileEx(stSaveParam)

        self.buf_lock.release()

        return ret



===== .//BasicDemoByGenTL/PyUICBasicDemoByGenTL.py =====
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'PyUICBasicDemoByGenTL.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(747, 486)
        self.centralWidget = QtWidgets.QWidget(MainWindow)
        self.centralWidget.setObjectName("centralWidget")
        self.comboInterface = QtWidgets.QComboBox(self.centralWidget)
        self.comboInterface.setGeometry(QtCore.QRect(70, 10, 451, 22))
        self.comboInterface.setObjectName("comboInterface")
        self.widgetDisplay = QtWidgets.QWidget(self.centralWidget)
        self.widgetDisplay.setGeometry(QtCore.QRect(10, 70, 511, 391))
        self.widgetDisplay.setObjectName("widgetDisplay")
        self.groupInit = QtWidgets.QGroupBox(self.centralWidget)
        self.groupInit.setGeometry(QtCore.QRect(530, 0, 211, 131))
        self.groupInit.setObjectName("groupInit")
        self.gridLayoutWidget = QtWidgets.QWidget(self.groupInit)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(9, 19, 201, 111))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setContentsMargins(11, 11, 11, 11)
        self.gridLayout.setSpacing(6)
        self.gridLayout.setObjectName("gridLayout")
        self.bnOpen = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.bnOpen.setObjectName("bnOpen")
        self.gridLayout.addWidget(self.bnOpen, 3, 1, 1, 1)
        self.bnClose = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.bnClose.setEnabled(False)
        self.bnClose.setObjectName("bnClose")
        self.gridLayout.addWidget(self.bnClose, 3, 2, 1, 1)
        self.bnEnumDevice = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.bnEnumDevice.setObjectName("bnEnumDevice")
        self.gridLayout.addWidget(self.bnEnumDevice, 1, 1, 1, 2)
        self.bnEnumInterface = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.bnEnumInterface.setObjectName("bnEnumInterface")
        self.gridLayout.addWidget(self.bnEnumInterface, 0, 1, 1, 2)
        self.groupGrab = QtWidgets.QGroupBox(self.centralWidget)
        self.groupGrab.setEnabled(False)
        self.groupGrab.setGeometry(QtCore.QRect(530, 140, 211, 171))
        self.groupGrab.setObjectName("groupGrab")
        self.gridLayoutWidget_2 = QtWidgets.QWidget(self.groupGrab)
        self.gridLayoutWidget_2.setGeometry(QtCore.QRect(9, 19, 202, 141))
        self.gridLayoutWidget_2.setObjectName("gridLayoutWidget_2")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.gridLayoutWidget_2)
        self.gridLayout_2.setContentsMargins(11, 11, 11, 11)
        self.gridLayout_2.setSpacing(6)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.bnSaveImage = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnSaveImage.setEnabled(False)
        self.bnSaveImage.setObjectName("bnSaveImage")
        self.gridLayout_2.addWidget(self.bnSaveImage, 4, 0, 1, 2)
        self.radioContinueMode = QtWidgets.QRadioButton(self.gridLayoutWidget_2)
        self.radioContinueMode.setObjectName("radioContinueMode")
        self.gridLayout_2.addWidget(self.radioContinueMode, 0, 0, 1, 1)
        self.radioTriggerMode = QtWidgets.QRadioButton(self.gridLayoutWidget_2)
        self.radioTriggerMode.setObjectName("radioTriggerMode")
        self.gridLayout_2.addWidget(self.radioTriggerMode, 0, 1, 1, 1)
        self.bnStop = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnStop.setEnabled(False)
        self.bnStop.setObjectName("bnStop")
        self.gridLayout_2.addWidget(self.bnStop, 2, 1, 1, 1)
        self.bnStart = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnStart.setEnabled(False)
        self.bnStart.setObjectName("bnStart")
        self.gridLayout_2.addWidget(self.bnStart, 2, 0, 1, 1)
        self.bnSoftwareTrigger = QtWidgets.QPushButton(self.gridLayoutWidget_2)
        self.bnSoftwareTrigger.setEnabled(False)
        self.bnSoftwareTrigger.setObjectName("bnSoftwareTrigger")
        self.gridLayout_2.addWidget(self.bnSoftwareTrigger, 3, 0, 1, 2)
        self.groupParam = QtWidgets.QGroupBox(self.centralWidget)
        self.groupParam.setEnabled(False)
        self.groupParam.setGeometry(QtCore.QRect(530, 310, 211, 151))
        self.groupParam.setObjectName("groupParam")
        self.gridLayoutWidget_3 = QtWidgets.QWidget(self.groupParam)
        self.gridLayoutWidget_3.setGeometry(QtCore.QRect(10, 20, 201, 131))
        self.gridLayoutWidget_3.setObjectName("gridLayoutWidget_3")
        self.gridLayoutParam = QtWidgets.QGridLayout(self.gridLayoutWidget_3)
        self.gridLayoutParam.setContentsMargins(11, 11, 11, 11)
        self.gridLayoutParam.setSpacing(6)
        self.gridLayoutParam.setObjectName("gridLayoutParam")
        self.label_6 = QtWidgets.QLabel(self.gridLayoutWidget_3)
        self.label_6.setObjectName("label_6")
        self.gridLayoutParam.addWidget(self.label_6, 3, 0, 1, 1)
        self.edtGain = QtWidgets.QLineEdit(self.gridLayoutWidget_3)
        self.edtGain.setObjectName("edtGain")
        self.gridLayoutParam.addWidget(self.edtGain, 1, 1, 1, 1)
        self.label_5 = QtWidgets.QLabel(self.gridLayoutWidget_3)
        self.label_5.setObjectName("label_5")
        self.gridLayoutParam.addWidget(self.label_5, 1, 0, 1, 1)
        self.label_4 = QtWidgets.QLabel(self.gridLayoutWidget_3)
        self.label_4.setObjectName("label_4")
        self.gridLayoutParam.addWidget(self.label_4, 0, 0, 1, 1)
        self.edtExposureTime = QtWidgets.QLineEdit(self.gridLayoutWidget_3)
        self.edtExposureTime.setObjectName("edtExposureTime")
        self.gridLayoutParam.addWidget(self.edtExposureTime, 0, 1, 1, 1)
        self.bnGetParam = QtWidgets.QPushButton(self.gridLayoutWidget_3)
        self.bnGetParam.setObjectName("bnGetParam")
        self.gridLayoutParam.addWidget(self.bnGetParam, 4, 0, 1, 1)
        self.bnSetParam = QtWidgets.QPushButton(self.gridLayoutWidget_3)
        self.bnSetParam.setObjectName("bnSetParam")
        self.gridLayoutParam.addWidget(self.bnSetParam, 4, 1, 1, 1)
        self.edtFrameRate = QtWidgets.QLineEdit(self.gridLayoutWidget_3)
        self.edtFrameRate.setObjectName("edtFrameRate")
        self.gridLayoutParam.addWidget(self.edtFrameRate, 3, 1, 1, 1)
        self.gridLayoutParam.setColumnStretch(0, 2)
        self.gridLayoutParam.setColumnStretch(1, 3)
        self.label = QtWidgets.QLabel(self.centralWidget)
        self.label.setGeometry(QtCore.QRect(10, 10, 54, 12))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralWidget)
        self.label_2.setGeometry(QtCore.QRect(10, 40, 54, 12))
        self.label_2.setObjectName("label_2")
        self.comboDevice = QtWidgets.QComboBox(self.centralWidget)
        self.comboDevice.setGeometry(QtCore.QRect(70, 40, 451, 22))
        self.comboDevice.setObjectName("comboDevice")
        MainWindow.setCentralWidget(self.centralWidget)
        self.statusBar = QtWidgets.QStatusBar(MainWindow)
        self.statusBar.setObjectName("statusBar")
        MainWindow.setStatusBar(self.statusBar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.groupInit.setTitle(_translate("MainWindow", "初始化"))
        self.bnOpen.setText(_translate("MainWindow", "打开设备"))
        self.bnClose.setText(_translate("MainWindow", "关闭设备"))
        self.bnEnumDevice.setText(_translate("MainWindow", "查找设备"))
        self.bnEnumInterface.setText(_translate("MainWindow", "查找Interface"))
        self.groupGrab.setTitle(_translate("MainWindow", "采集"))
        self.bnSaveImage.setText(_translate("MainWindow", "保存图像"))
        self.radioContinueMode.setText(_translate("MainWindow", "连续模式"))
        self.radioTriggerMode.setText(_translate("MainWindow", "触发模式"))
        self.bnStop.setText(_translate("MainWindow", "停止采集"))
        self.bnStart.setText(_translate("MainWindow", "开始采集"))
        self.bnSoftwareTrigger.setText(_translate("MainWindow", "软触发一次"))
        self.groupParam.setTitle(_translate("MainWindow", "参数"))
        self.label_6.setText(_translate("MainWindow", "帧率"))
        self.edtGain.setText(_translate("MainWindow", "0"))
        self.label_5.setText(_translate("MainWindow", "增益"))
        self.label_4.setText(_translate("MainWindow", "曝光"))
        self.edtExposureTime.setText(_translate("MainWindow", "0"))
        self.bnGetParam.setText(_translate("MainWindow", "获取参数"))
        self.bnSetParam.setText(_translate("MainWindow", "设置参数"))
        self.edtFrameRate.setText(_translate("MainWindow", "0"))
        self.label.setText(_translate("MainWindow", "Interface"))
        self.label_2.setText(_translate("MainWindow", "Device"))


===== .//BasicDemoLineScan/BasicDemoLineScanCamera.py =====
# -- coding: utf-8 --

import sys
import msvcrt
import ctypes

sys.path.append("../MvImport")
from MvCameraControl_class import *

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    t_layer_type = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                    | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)

    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(t_layer_type, deviceList)
    if ret != 0:
        print("error: enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print("find no device!")
        sys.exit()

    print("find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print("gige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if 0 == per:
                    break
                strModeName = strModeName + chr(per)
            print("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print("current ip: %d.%d.%d.%d" % (nip1, nip2, nip3, nip4))
            
            chUserDefinedName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chUserDefinedName:
                if 0 == per:
                    break
                chUserDefinedName = chUserDefinedName + chr(per)
            print("device user define name: %s" % chUserDefinedName)
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print("u3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print("user serial number: %s" % strSerialNumber)
            
            strUserDefinedName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chUserDefinedName:
                if per == 0:
                    break
                strUserDefinedName = strUserDefinedName + chr(per)
            print("device user define name: %s" % strUserDefinedName)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print("XoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print("user serial number: %s" % strSerialNumber)

            strUserDefinedName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chUserDefinedName:
                if per == 0:
                    break
                strUserDefinedName = strUserDefinedName + chr(per)
            print("device user define name: %s" % strUserDefinedName)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print("CXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print("user serial number: %s" % strSerialNumber)

            strUserDefinedName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chUserDefinedName:
                if per == 0:
                    break
                strUserDefinedName = strUserDefinedName + chr(per)
            print("device user define name: %s" % strUserDefinedName)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print("CML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print("user serial number: %s" % strSerialNumber)

            strUserDefinedName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chUserDefinedName:
                if per == 0:
                    break
                strUserDefinedName = strUserDefinedName + chr(per)
            print("device user define name: %s" % strUserDefinedName)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print("error: input error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print("error: create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print("error: open device fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize", nPacketSize)
            if ret != 0:
                print("warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print("warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print("error: set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    # ch 设置数字增益 | en: Set digital shift
    ret = cam.MV_CC_SetBoolValue("DigitalShiftEnable", True)
    if ret != 0:
        print("error: set digital shift enable fail! ret[0x%x]" % ret)

    ret = cam.MV_CC_SetFloatValue("DigitalShift", 0)
    if ret != 0:
        print("error: set digital shift fail! ret[0x%x]" % ret)

    # ch 设置行频 | en: Set  acquisition line rate
    ret = cam.MV_CC_SetIntValue("AcquisitionLineRate", 10000)
    if ret != 0:
        print("error: set acquisition line rate fail! ret[0x%x]" % ret)

    ret = cam.MV_CC_SetBoolValue("AcquisitionLineRateEnable", True)
    if ret != 0:
        print("error: set acquisition line rate enable fail! ret[0x%x]" % ret)

    # ch 设置HB模式 | en: Set image compression mode:HB
    ret = cam.MV_CC_SetEnumValueByString("ImageCompressionMode", "HB")
    if ret != 0:
        print("error: set  image compression mode: HB fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:获取数据包大小 | en:Get payload size
    stParam = MVCC_INTVALUE()
    memset(byref(stParam), 0, sizeof(MVCC_INTVALUE))

    ret = cam.MV_CC_GetIntValue("PayloadSize", stParam)
    if ret != 0:
        print("get payload size fail! ret[0x%x]" % ret)
        sys.exit()
    nPayloadSize = stParam.nCurValue

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print("error: start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    stOutFrame = MV_FRAME_OUT()
    memset(byref(stOutFrame), 0, sizeof(stOutFrame))

    ret = cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
    if None != stOutFrame.pBufAddr and 0 == ret:
        print("get one frame: Width[%d], Height[%d], nFrameNum[%d]" % (
            stOutFrame.stFrameInfo.nWidth, stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum))

        # ch:无损解码 | High Bandwidth decode
        dst_size = nPayloadSize
        HB_decode_param = MV_CC_HB_DECODE_PARAM()
        HB_decode_param.pSrcBuf = stOutFrame.pBufAddr
        HB_decode_param.nSrcLen = stOutFrame.stFrameInfo.nFrameLen
        HB_decode_param.nDstBufSize = dst_size
        HB_decode_param.pDstBuf = (c_ubyte * dst_size)()
        ret = cam.MV_CC_HBDecode(HB_decode_param)
        if ret != 0:
            print("error: high bandwidth decode fail! ret[0x%x]" % ret)
            sys.exit()
        else:
            print("high bandwidth decode ok, dst pixel type is [%d]" % HB_decode_param.enDstPixelType)

        # ch:保存图像 | en:Save image

        c_file_path = "image.bmp".encode('ascii')
        nRGBSize = stOutFrame.stFrameInfo.nWidth * stOutFrame.stFrameInfo.nHeight * 4 + 2048
        stSaveParam = MV_SAVE_IMAGE_TO_FILE_PARAM_EX()
        memset(byref(stSaveParam), 0, sizeof(stSaveParam))
        stSaveParam.nWidth = stOutFrame.stFrameInfo.nWidth
        stSaveParam.nHeight = stOutFrame.stFrameInfo.nHeight
        stSaveParam.pData = HB_decode_param.pDstBuf
        stSaveParam.enImageType = MV_Image_Bmp
        stSaveParam.nDataLen = HB_decode_param.nDstBufLen
        stSaveParam.enPixelType = HB_decode_param.enDstPixelType
        stSaveParam.nQuality = 80
        stSaveParam.iMethodValue = 3
        stSaveParam.pcImagePath = ctypes.create_string_buffer(c_file_path)
        ret = cam.MV_CC_SaveImageToFileEx(stSaveParam)
        if ret != 0:
            print("error: save image to file fail! ret[0x%x]" % ret)
            sys.exit()
        else:
            print("save image to file is OK")

        cam.MV_CC_FreeImageBuffer(stOutFrame)

    else:
        print("error: get one frame fail, ret[0x%x]" % ret)

    print("press a key to continue.")
    msvcrt.getch()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print("error: stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print("error: close device fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print("error: destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()


===== .//ConnectSpecCamera/ConnectSpecCamera.py =====
# -- coding: utf-8 --

import time
import sys
import threading
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

g_bExit = False

# 为线程定义一个函数
def work_thread(cam, pData):
    stOutFrame = MV_FRAME_OUT()  
    memset(byref(stOutFrame), 0, sizeof(stOutFrame))
    while True:
        ret = cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
        if None != stOutFrame.pBufAddr and 0 == ret:
            print ("get one frame: Width[%d], Height[%d], nFrameNum[%d]"  % (stOutFrame.stFrameInfo.nWidth, stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum))
            nRet = cam.MV_CC_FreeImageBuffer(stOutFrame)
        else:
            print ("no data[0x%x]" % ret)
        if g_bExit == True:
            break

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    stDevInfo = MV_CC_DEVICE_INFO()
    stGigEDev = MV_GIGE_DEVICE_INFO()

    if sys.version >= '3':
        deviceIp = input("please input current camera ip : ")
        netIp = input("please input net export ip : ")
    else:
        deviceIp = raw_input("please input current camera ip : ")
        netIp = raw_input("please input net export ip : ")
    
    deviceIpList = deviceIp.split('.')
    stGigEDev.nCurrentIp = (int(deviceIpList[0]) << 24) | (int(deviceIpList[1]) << 16) | (int(deviceIpList[2]) << 8) | int(deviceIpList[3])

    netIpList = netIp.split('.')
    stGigEDev.nNetExport =  (int(netIpList[0]) << 24) | (int(netIpList[1]) << 16) | (int(netIpList[2]) << 8) | int(netIpList[3])

    stDevInfo.nTLayerType = MV_GIGE_DEVICE
    stDevInfo.SpecialInfo.stGigEInfo = stGigEDev

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    ret = cam.MV_CC_CreateHandle(stDevInfo)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()
    
    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDevInfo.nTLayerType == MV_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print ("set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()
    try:
        hThreadHandle = threading.Thread(target=work_thread, args=(cam, None))
        hThreadHandle.start()
    except:
        print ("error: unable to start thread")
        
    print ("press a key to stop grabbing.")
    msvcrt.getch()

    g_bExit = True
    hThreadHandle.join()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()


===== .//ConvertPixelType/ConvertPixelType.py =====
# -- coding: utf-8 --

import sys
import copy
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                  | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print ("\nCML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print ("\nCXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print ("\nXoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print ("set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()
    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    stOutFrame = MV_FRAME_OUT()  
    memset(byref(stOutFrame), 0, sizeof(stOutFrame))

    ret = cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
    if None != stOutFrame.pBufAddr and 0 == ret :
        print ("get one frame: Width[%d], Height[%d], nFrameNum[%d]"  % (stOutFrame.stFrameInfo.nWidth, stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum))

        nRGBSize = stOutFrame.stFrameInfo.nWidth * stOutFrame.stFrameInfo.nHeight * 3
        stConvertParam = MV_CC_PIXEL_CONVERT_PARAM_EX()
        memset(byref(stConvertParam), 0, sizeof(stConvertParam))
        stConvertParam.nWidth = stOutFrame.stFrameInfo.nWidth
        stConvertParam.nHeight = stOutFrame.stFrameInfo.nHeight
        stConvertParam.pSrcData = stOutFrame.pBufAddr
        stConvertParam.nSrcDataLen = stOutFrame.stFrameInfo.nFrameLen
        stConvertParam.enSrcPixelType = stOutFrame.stFrameInfo.enPixelType  
        stConvertParam.enDstPixelType = PixelType_Gvsp_RGB8_Packed
        stConvertParam.pDstBuffer = (c_ubyte * nRGBSize)()
        stConvertParam.nDstBufferSize = nRGBSize

        ret = cam.MV_CC_ConvertPixelTypeEx(stConvertParam)
        if ret != 0:
            print ("convert pixel fail! ret[0x%x]" % ret)
            sys.exit()

        cam.MV_CC_FreeImageBuffer(stOutFrame)

        file_path = "AfterConvert_RGB.raw"   
        file_open = open(file_path.encode('ascii'), 'wb+')
        try:
            img_buff = (c_ubyte * stConvertParam.nDstLen)()
            cdll.msvcrt.memcpy(byref(img_buff), stConvertParam.pDstBuffer, stConvertParam.nDstLen)
            file_open.write(img_buff)
        except:
            raise Exception("save file executed failed:%s" % e.message)
        finally:
            file_open.close() 
    else:
        print ("get one frame fail, ret[0x%x]" % ret)
    
    print ("convert pixeltype succeed!")

    print ("press a key to continue.")
    msvcrt.getch()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()


===== .//Events/Events.py =====
# -- coding: utf-8 --

import sys
import copy
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

from ctypes import WINFUNCTYPE
winfun_ctype = WINFUNCTYPE

stEventInfo = POINTER(MV_EVENT_OUT_INFO)
pData = POINTER(c_ubyte)
EventInfoCallBack = winfun_ctype(None, stEventInfo, c_void_p)

def event_callback(pEventInfo, pUser):
    stPEventInfo = cast(pEventInfo, POINTER(MV_EVENT_OUT_INFO)).contents
    nBlockId = stPEventInfo.nBlockIdHigh
    nBlockId = (nBlockId << 32) + stPEventInfo.nBlockIdLow
    nTimestamp = stPEventInfo.nTimestampHigh
    nTimestamp = (nTimestamp << 32) + stPEventInfo.nTimestampLow
    if stPEventInfo:
        print ("EventName[%s], EventId[%u], BlockId[%d], Timestamp[%d]" % (stPEventInfo.EventName, stPEventInfo.nEventID, nBlockId, nTimestamp))

CALL_BACK_FUN = EventInfoCallBack(event_callback)

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                  | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print ("\nCML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print ("\nCXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print ("\nXoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()
    
    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print ("set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:开启Event | en:Set Event of ExposureEnd On
    ret = cam.MV_CC_SetEnumValueByString("EventSelector","ExposureEnd")
    if ret != 0:
        print ("set enum value by string fail! ret[0x%x]" % ret)
        sys.exit()

    ret = cam.MV_CC_SetEnumValueByString("EventNotification","On")
    if ret != 0:
        print ("set enum value by string fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:注册事件回调 | en:Register event callback
    ret = cam.MV_CC_RegisterEventCallBackEx("ExposureEnd", CALL_BACK_FUN,None)
    if ret != 0:
        print ("register event callback fail! ret [0x%x]" % ret)
        sys.exit()

    # ch:开始取流 | en:Start grab image
    cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    print ("press a key to stop grabbing.")
    msvcrt.getch()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()


===== .//GrabImage/GrabImage.py =====
# -- coding: utf-8 --

import sys
import threading
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

g_bExit = False

# 为线程定义一个函数
def work_thread(cam=0, pData=0, nDataSize=0):
    stOutFrame = MV_FRAME_OUT()  
    memset(byref(stOutFrame), 0, sizeof(stOutFrame))
    while True:
        ret = cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
        if None != stOutFrame.pBufAddr and 0 == ret:
            print ("get one frame: Width[%d], Height[%d], nFrameNum[%d]"  % (stOutFrame.stFrameInfo.nWidth, stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum))
            nRet = cam.MV_CC_FreeImageBuffer(stOutFrame)
        else:
            print ("no data[0x%x]" % ret)
        if g_bExit == True:
            break

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                  | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("Find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print ("\nCML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print ("\nCXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print ("\nXoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()
    
    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()
    
    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    stBool = c_bool(False)
    ret =cam.MV_CC_GetBoolValue("AcquisitionFrameRateEnable", stBool)
    if ret != 0:
        print ("get AcquisitionFrameRateEnable fail! ret[0x%x]" % ret)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print ("set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    try:
        hThreadHandle = threading.Thread(target=work_thread, args=(cam, None, None))
        hThreadHandle.start()
    except:
        print ("error: unable to start thread")
        
    print ("press a key to stop grabbing.")
    msvcrt.getch()

    g_bExit = True
    hThreadHandle.join()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()



===== .//Grab_Callback/Grab_Callback.py =====
# -- coding: utf-8 --

import sys
import copy
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

winfun_ctype = WINFUNCTYPE

stFrameInfo = POINTER(MV_FRAME_OUT_INFO_EX)
pData = POINTER(c_ubyte)
FrameInfoCallBack = winfun_ctype(None, pData, stFrameInfo, c_void_p)

def image_callback(pData, pFrameInfo, pUser):
        stFrameInfo = cast(pFrameInfo, POINTER(MV_FRAME_OUT_INFO_EX)).contents
        if stFrameInfo:
            print ("get one frame: Width[%d], Height[%d], nFrameNum[%d]" % (stFrameInfo.nWidth, stFrameInfo.nHeight, stFrameInfo.nFrameNum))

CALL_BACK_FUN = FrameInfoCallBack(image_callback)

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                  | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()
    
    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print ("\nCML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print ("\nCXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print ("\nXoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()
    
    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()
    
    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print ("set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:注册抓图回调 | en:Register image callback
    ret = cam.MV_CC_RegisterImageCallBackEx(CALL_BACK_FUN,None)
    if ret != 0:
        print ("register image callback fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    print ("press a key to stop grabbing.")
    msvcrt.getch()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()

===== .//Grab_LineStart/Grab_LineStart.py =====
# -- coding: utf-8 --

import sys
import threading
import msvcrt

sys.path.append("../MvImport")
from MvCameraControl_class import *

g_bExit = False


# 为线程定义一个函数
def work_thread(cam=0, pData=0, nDataSize=0):
    out_frame_info = MV_FRAME_OUT()
    memset(byref(out_frame_info), 0, sizeof(out_frame_info))
    while True:
        ret = cam.MV_CC_GetImageBuffer(out_frame_info, 1000)
        if out_frame_info.pBufAddr is not None and 0 == ret:
            print("get one frame: Width[%d], Height[%d], nFrameNum[%d]" % (
                out_frame_info.stFrameInfo.nWidth, out_frame_info.stFrameInfo.nHeight,
                out_frame_info.stFrameInfo.nFrameNum))
            ret = cam.MV_CC_FreeImageBuffer(out_frame_info)
        else:
            print("error: no data[0x%x]" % ret)
        if g_bExit is True:
            break


if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    device_list = MV_CC_DEVICE_INFO_LIST()
    t_layer_type = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                    | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)

    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(t_layer_type, device_list)
    if ret != 0:
        print("error: enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if device_list.nDeviceNum == 0:
        print("find no device!")
        sys.exit()

    print("Find %d devices!" % device_list.nDeviceNum)

    for i in range(0, device_list.nDeviceNum):
        mvcc_dev_info = cast(device_list.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print("gige device: [%d]" % i)
            device_model_name = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                device_model_name = device_model_name + chr(per)
            print("device model name: %s" % device_model_name)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print("current ip: %d.%d.%d.%d" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print("u3v device: [%d]" % i)
            device_model_name = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                device_model_name = device_model_name + chr(per)
            print("device model name: %s" % device_model_name)

            serial_number = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                serial_number = serial_number + chr(per)
            print("user serial number: %s" % serial_number)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print ("\nCML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print ("\nCXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print ("\nXoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    connection_number = input("please input the number of the device to connect:")

    if int(connection_number) >= device_list.nDeviceNum:
        print("error: input error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    current_device_info = cast(device_list.pDeviceInfo[int(connection_number)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(current_device_info)
    if ret != 0:
        print("error: create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print("error: open device fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if current_device_info.nTLayerType == MV_GIGE_DEVICE or current_device_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize", nPacketSize)
            if ret != 0:
                print("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    b_enable = c_bool(False)
    ret = cam.MV_CC_GetBoolValue("AcquisitionLineRateEnable", b_enable)
    if ret != 0:
        print("error: get AcquisitionLineRateEnable fail! ret[0x%x]" % ret)

    # ch:设置行触发 | en:Set trigger selector is line start
    ret = cam.MV_CC_SetEnumValueByString("TriggerSelector", "LineStart")
    if ret != 0:
        print("error: set trigger selector fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:设置触发模式为On | en:Set trigger mode as on
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_ON)
    if ret != 0:
        print("error: set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:设置触发源 | en:Set trigger source
    ret = cam.MV_CC_SetEnumValue("TriggerSource", MV_TRIGGER_SOURCE_LINE1)
    if ret != 0:
        print("error: set trigger source fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print("error: start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    try:
        thread_handle = threading.Thread(target=work_thread, args=(cam, None, None))
        thread_handle.start()
    except:
        print("error: unable to start thread")

    print("press a key to stop grabbing.")
    msvcrt.getch()

    g_bExit = True
    thread_handle.join()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print("error: stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print("error: close device fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print("error: destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()


===== .//HighBandwidthDecode/HighBandwidthDecode.py =====
# -- coding: utf-8 --

import sys
import threading
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

g_bExit = False

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                  | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("Find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print ("\nCML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print ("\nCXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print ("\nXoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()
    
    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()
    
    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    stBool = c_bool(False)
    ret =cam.MV_CC_GetBoolValue("AcquisitionFrameRateEnable", stBool)
    if ret != 0:
        print ("get AcquisitionFrameRateEnable fail! ret[0x%x]" % ret)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print ("set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    # 获取数据包大小
    stParam = MVCC_INTVALUE()
    memset(byref(stParam), 0, sizeof(stParam))
    ret = cam.MV_CC_GetIntValue("PayloadSize",stParam)
    if 0 != ret:
        print("Get PayloadSize fail! ret[0x%x]" % ret)
        sys.exit()

    nPayloadSize = stParam.nCurValue

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    nImageNum=10
    stOutFrame = MV_FRAME_OUT()
    stDecodeParam = MV_CC_HB_DECODE_PARAM()
    memset(byref(stOutFrame), 0, sizeof(stOutFrame))
    for i in range(0,nImageNum):
        ret = cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
        if None != stOutFrame.pBufAddr and 0 == ret:
            print("get one frame: Width[%d], Height[%d], nFrameNum[%d]" % (
            stOutFrame.stFrameInfo.nWidth, stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum))

            stDecodeParam.pSrcBuf = stOutFrame.pBufAddr
            stDecodeParam.nSrcLen = stOutFrame.stFrameInfo.nFrameLen
            stDecodeParam.pDstBuf = (c_ubyte * nPayloadSize)()
            stDecodeParam.nDstBufSize = nPayloadSize
            ret = cam.MV_CC_HBDecode(stDecodeParam)
            if ret != 0:
                print("HB Decode fail! ret[0x%x]" % ret)
                cam.MV_CC_FreeImageBuffer(stOutFrame)
                break
            else:
                print("Decode succeed!")

            nRet = cam.MV_CC_FreeImageBuffer(stOutFrame)

            file_path = "Image_w%d_h%d_fn%d.raw" %(stOutFrame.stFrameInfo.nWidth,stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum)
            file_open = open(file_path.encode('ascii'),'wb+')
            try:
                error_save = (c_ubyte * stDecodeParam.nDstBufLen)()
                memmove(byref(error_save),stDecodeParam.pDstBuf,stDecodeParam.nDstBufLen)
                file_open.write(error_save)
            except:
                raise Exception("save error raw file executed failed!")
            finally:
                file_open.close()
        else:
            print("no data[0x%x]" % ret)
        if g_bExit == True:
            break
        
    print ("press a key to exit.")
    msvcrt.getch()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()


===== .//InterfaceDemo/InterfaceDemo.py =====
# -- coding: utf-8 --

import sys
import threading
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *


if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    interfaceList = MV_INTERFACE_INFO_LIST()
    transportLayerType = MV_GIGE_INTERFACE | MV_CAMERALINK_INTERFACE | MV_CXP_INTERFACE | MV_XOF_INTERFACE
    
    # ch:枚举采集卡 | en:Enum interfaces
    ret = MvCamera.MV_CC_EnumInterfaces(transportLayerType, interfaceList)
    if ret != 0:
        print("enum interfaces fail! ret[0x%x]" % ret)
        sys.exit()

    if interfaceList.nInterfaceNum == 0:
        print("find no interface!")
        sys.exit()

    print("Find %d interfaces!" % interfaceList.nInterfaceNum)

    for i in range(0, interfaceList.nInterfaceNum):
        interfaceInfo = cast(interfaceList.pInterfaceInfos[i], POINTER(MV_INTERFACE_INFO)).contents
        print("interface: [%d]" % i)
        displayName = ""
        for per in interfaceInfo.chDisplayName:
            if per == 0:
                break
            displayName = displayName + chr(per)
        print("display name: %s" % displayName)

        serialNumber = ""
        for per in interfaceInfo.chSerialNumber:
            if per == 0:
                break
            serialNumber = serialNumber + chr(per)
        print("serial number: %s" % serialNumber)

        modelName = ""
        for per in interfaceInfo.chModelName:
            if per == 0:
                break
            modelName = modelName + chr(per)
        print("model name: %s" % modelName)

        interfaceId = ""
        for per in interfaceInfo.chInterfaceID:
            if per == 0:
                break
            interfaceId = interfaceId + chr(per)
        print("interface id: %s" % interfaceId)

    nConnectionNum = input("please input the number of the interface to connect:")

    if int(nConnectionNum) >= interfaceList.nInterfaceNum:
        print("input error!")
        sys.exit()

    # ch:创建相机实例 | en:Create Camera Object
    cam = MvCamera()
    
    # ch:选择采集卡并创建句柄 | en:Select interface and create handle
    curInterface = cast(interfaceList.pInterfaceInfos[int(nConnectionNum)], POINTER(MV_INTERFACE_INFO)).contents

    ret = cam.MV_CC_CreateInterface(curInterface)
    if ret != 0:
        print("create interface handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenInterface()
    if ret != 0:
        print("open interface fail! ret[0x%x]" % ret)
        sys.exit()
    else:
        print("open interface success")

    # ch:获取属性 | en:Get Feature
    stEnumValue = MVCC_ENUMVALUE()
    ret =cam.MV_CC_GetEnumValue("StreamSelector", stEnumValue)
    if ret != 0:
        print("get StreamSelector fail! ret[0x%x]" % ret)

    # ch:设置属性 | en:Set Feature
    ret = cam.MV_CC_SetEnumValue("StreamSelector", stEnumValue.nCurValue)
    if ret != 0:
        print("set StreamSelector fail! ret[0x%x]" % ret)
        sys.exit()
    else:
        print("set StreamSelector [%d] success" % stEnumValue.nCurValue)

    # ch:关闭采集卡 | en:Close interface
    ret = cam.MV_CC_CloseInterface()
    if ret != 0:
        print("close interface fail! ret[0x%x]" % ret)
        sys.exit()
    else:
        print("close interface success")

    # ch:销毁采集卡句柄 | en:Destroy interface
    ret = cam.MV_CC_DestroyInterface()
    if ret != 0:
        print("destroy interface fail! ret[0x%x]" % ret)
        sys.exit()

    print("press a key to exit.")
    msvcrt.getch()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()

===== .//MultiCast/MultiCast.py =====
# -- coding: utf-8 --

import sys
import threading
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

g_bExit = False

# 为线程定义一个函数
def work_thread(cam=0, pData=0, nDataSize=0):
    stOutFrame = MV_FRAME_OUT()  
    memset(byref(stOutFrame), 0, sizeof(stOutFrame))
    while True:
        ret = cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
        if None != stOutFrame.pBufAddr and 0 == ret:
            print ("get one frame: Width[%d], Height[%d], nFrameNum[%d]"  % (stOutFrame.stFrameInfo.nWidth, stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum))
            nRet = cam.MV_CC_FreeImageBuffer(stOutFrame)
        else:
            print ("no data[0x%x]" % ret)
        if g_bExit == True:
            break

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = MV_GIGE_DEVICE
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents

        print ("\ngige device: [%d]" % i)
        strModeName = ""
        for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
            if per == 0:
                break
            strModeName = strModeName + chr(per)
        print ("device model name: %s" % strModeName)

        nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
        nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
        nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
        nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
        print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    #ch:询问用户启动多播控制应用程序或多播监控应用程序
    #en:Ask the user to launch: the multicast controlling application or the multicast monitoring application.
    print ("start multicast sample in (c)ontrol or in (m)onitor mode? (c/m)")

    key = msvcrt.getch()
    key = bytes.decode(key)

    #ch:查询用户使用的模式 | en:Query the user for the mode to use.
    monitor = False
    if key == 'm' or key == 'M':
        monitor = True
    elif key == 'c' or key == 'C':
        monitor = False
    else:
        print ("intput error!")
        sys.exit()

    if monitor:
        ret = cam.MV_CC_OpenDevice(MV_ACCESS_Monitor, 0)
        if ret != 0:
            print ("open device fail! ret[0x%x]" % ret)
            sys.exit()
    else:
        ret = cam.MV_CC_OpenDevice(MV_ACCESS_Control, 0)
        if ret != 0:
            print ("open device fail! ret[0x%x]" % ret)
            sys.exit()

    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    #ch:指定组播ip | en:multicast IP
    strIp = "239.0.1.23"
    device_ip_list = strIp.split('.')
    dest_ip = (int(device_ip_list[0]) << 24) | (int(device_ip_list[1]) << 16) | (int(device_ip_list[2]) << 8) | int(device_ip_list[3])
    print ("dest ip: %s" % strIp)

    #ch:可指定端口号作为组播组端口 | en:multicast port
    stTransmissionType = MV_TRANSMISSION_TYPE() 
    memset(byref(stTransmissionType), 0, sizeof(MV_TRANSMISSION_TYPE))

    stTransmissionType.enTransmissionType = MV_GIGE_TRANSTYPE_MULTICAST
    stTransmissionType.nDestIp = dest_ip
    stTransmissionType.nDestPort = 8787

    ret = cam.MV_GIGE_SetTransmissionType(stTransmissionType)
    if MV_OK != ret:
        print ("set transmission type fail! ret [0x%x]" % ret)

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    try:
        hThreadHandle = threading.Thread(target=work_thread, args=(cam, None, None))
        hThreadHandle.start()
    except:
        print ("error: unable to start thread")
        
    print ("press a key to stop grabbing.")
    msvcrt.getch()

    g_bExit = True
    hThreadHandle.join()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()



===== .//MultipleCameras/CamOperation_class.py =====
# -- coding: utf-8 --
import threading
import time
import sys
import ctypes
from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

class CameraOperation():

    def __init__(self,obj_cam,st_device_list,n_connect_num=0,b_open_device=False,b_start_grabbing = False,h_thread_handle=None,\
                b_thread_opened=False,st_frame_info=None,b_save_bmp=False,b_save_jpg=False,buf_save_image=None):

        self.obj_cam = obj_cam
        self.st_device_list = st_device_list
        self.n_connect_num = n_connect_num
        self.b_open_device = b_open_device
        self.b_start_grabbing = b_start_grabbing 
        self.b_thread_opened = b_thread_opened
        self.st_frame_info = MV_FRAME_OUT_INFO_EX()
        self.b_save_bmp = b_save_bmp
        self.b_save_jpg = b_save_jpg
        self.buf_save_image = buf_save_image
        self.buf_save_image_len = 0
        self.h_thread_handle = h_thread_handle
        self.buf_lock = threading.Lock()  # 取图和存图的buffer锁
        self.exit_flag = 0
        self.frame_count = 0
        self.lost_frame_count = 0

    # 转为16进制字符串
    def to_hex_str(self, num):
        chaDic = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}
        hexStr = ""
        if num < 0:
            num = num + 2**32
        while num >= 16:
            digit = num % 16
            hexStr = chaDic.get(digit, str(digit)) + hexStr
            num //= 16
        hexStr = chaDic.get(num, str(num)) + hexStr
        return hexStr

    # 打开相机
    def open_device(self):
        if self.b_open_device is False:
            # ch:选择设备并创建句柄 | en:Select device and create handle
            nConnectionNum = int(self.n_connect_num)
            stDeviceList = cast(self.st_device_list.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents
            self.obj_cam = MvCamera()
            ret = self.obj_cam.MV_CC_CreateHandle(stDeviceList)
            if ret != 0:
                self.obj_cam.MV_CC_DestroyHandle()
                return ret

            ret = self.obj_cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
            if ret != 0:
                self.b_open_device = False
                self.b_thread_opened = False
                return ret
            self.b_open_device = True
            self.b_thread_opened = False

            # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
            if stDeviceList.nTLayerType == MV_GIGE_DEVICE:
                nPacketSize = self.obj_cam.MV_CC_GetOptimalPacketSize()
                if int(nPacketSize) > 0:
                    ret = self.obj_cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
                    if ret != 0:
                        print("warning: set packet size fail! ret[0x%x]" % ret)
                else:
                    print("warning: packet size is invalid[%d]" % nPacketSize)

            stBool = c_bool(False)
            ret =self.obj_cam.MV_CC_GetBoolValue("AcquisitionFrameRateEnable", stBool)
            if ret != 0:
                print("warning: get acquisition frame rate enable fail! ret[0x%x]" % ret)

            # ch:设置触发模式为off | en:Set trigger mode as off
            ret = self.obj_cam.MV_CC_SetEnumValueByString("TriggerMode", "Off")
            if ret != 0:
                print("warning: set trigger mode off fail! ret[0x%x]" % ret)
            return 0
        return 0
            
    # 开始取图
    def start_grabbing(self, n_index,  win_handle):
        if not self.b_start_grabbing and self.b_open_device:
            ret = self.obj_cam.MV_CC_StartGrabbing()
            if ret != 0:
                self.b_start_grabbing = False
                return ret
            self.b_start_grabbing = True
            print("start grabbing " + str(n_index) + "successfully!")
            try:
                self.exit_flag = threading.Event()
                self.h_thread_handle = threading.Thread(target=CameraOperation.work_thread, args=(self, n_index, win_handle, self.exit_flag))
                self.h_thread_handle.start()
                self.b_thread_opened = True
            except TypeError:
                print('error: unable to start thread')
                self.b_start_grabbing = False
            return 0
        return MV_E_CALLORDER

    # 停止取图
    def stop_grabbing(self):
        if (self.b_start_grabbing is True) and (self.b_open_device is True):
            # 退出线程
            if self.b_thread_opened:
                self.exit_flag.set()
                self.h_thread_handle.join()
                self.b_thread_opened = False
            ret = self.obj_cam.MV_CC_StopGrabbing()
            if ret != 0:
                return ret
            self.b_start_grabbing = False
            return 0
        return MV_E_CALLORDER

    # 关闭相机
    def close_device(self):
        if self.b_open_device:
            #退出线程
            if self.b_thread_opened:
                self.exit_flag.set()
                self.h_thread_handle.join()
                self.b_thread_opened = False
            if self.b_start_grabbing:
                ret = self.obj_cam.MV_CC_StopGrabbing()
                if ret != 0:
                    return ret
                self.b_start_grabbing = False
            ret = self.obj_cam.MV_CC_CloseDevice()
            if ret != 0:
                return ret
                
        # ch:销毁句柄 | Destroy handle
        self.obj_cam.MV_CC_DestroyHandle()
        self.b_open_device = False
        return 0

    # 设置触发模式
    def set_trigger_mode(self, trigger_mode):
        if True == self.b_open_device:
            if "continuous" == trigger_mode:
                ret = self.obj_cam.MV_CC_SetEnumValueByString("TriggerMode","Off")
                if ret != 0:
                    return ret
                return 0
            if "triggermode" == trigger_mode:
                ret = self.obj_cam.MV_CC_SetEnumValueByString("TriggerMode","On")
                if ret != 0:
                    return ret
                return 0

    # 设置触发源
    def set_trigger_source(self, trigger_source):
        if self.b_open_device is True:
            if "software" == trigger_source:
                ret = self.obj_cam.MV_CC_SetEnumValueByString("TriggerSource", "Software")
                if ret != 0:
                    return ret
                return 0
            else:
                ret = self.obj_cam.MV_CC_SetEnumValueByString("TriggerSource", "Line0")
                if ret != 0:
                    return ret
                return 0

    # 软触发一次
    def trigger_once(self):
        if self.b_open_device is True:
            ret = self.obj_cam.MV_CC_SetCommandValue("TriggerSoftware")
            return ret

    def set_exposure_time(self, str_value):
        if self.b_open_device is True:
            self.obj_cam.MV_CC_SetEnumValue("ExposureAuto", 0)
            time.sleep(0.2)
            ret = self.obj_cam.MV_CC_SetFloatValue("ExposureTime", float(str_value))
            if ret != 0:
                print('show error', 'set exposure time fail! ret = ' + self.to_hex_str(ret))
                return ret
        return 0

    def set_gain(self, str_value):
        if self.b_open_device is True:
            self.obj_cam.MV_CC_SetEnumValue("GainAuto", 0)
            time.sleep(0.2)
            ret = self.obj_cam.MV_CC_SetFloatValue("Gain", float(str_value))
            if ret != 0:
                print('show error', 'set gain fail! ret = ' + self.to_hex_str(ret))
                return ret
        return 0

    def set_frame_rate(self, str_value):
        if self.b_open_device is True:
            ret = self.obj_cam.MV_CC_SetFloatValue("AcquisitionFrameRate", float(str_value))
            return ret
        return 0

    # 取图线程函数
    def work_thread(self, n_index, win_handle, exit_flag):
        stOutFrame = MV_FRAME_OUT()
        memset(byref(stOutFrame), 0, sizeof(stOutFrame))

        while not exit_flag.is_set():
            ret = self.obj_cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
            if 0 == ret:
                # 拷贝图像和图像信息
                # 获取缓存锁
                self.buf_lock.acquire()
                if self.buf_save_image_len < stOutFrame.stFrameInfo.nFrameLen:
                    if self.buf_save_image is not None:
                        del self.buf_save_image
                        self.buf_save_image = None
                    self.buf_save_image = (c_ubyte * stOutFrame.stFrameInfo.nFrameLen)()
                    self.buf_save_image_len = stOutFrame.stFrameInfo.nFrameLen

                cdll.msvcrt.memcpy(byref(self.st_frame_info), byref(stOutFrame.stFrameInfo), sizeof(MV_FRAME_OUT_INFO_EX))
                cdll.msvcrt.memcpy(byref(self.buf_save_image), stOutFrame.pBufAddr, self.st_frame_info.nFrameLen)
                self.buf_lock.release()

                # 使用Display接口显示图像
                stDisplayParam = MV_DISPLAY_FRAME_INFO()
                memset(byref(stDisplayParam), 0, sizeof(stDisplayParam))
                stDisplayParam.hWnd = int(win_handle)
                stDisplayParam.nWidth = stOutFrame.stFrameInfo.nWidth
                stDisplayParam.nHeight = stOutFrame.stFrameInfo.nHeight
                stDisplayParam.enPixelType = stOutFrame.stFrameInfo.enPixelType
                stDisplayParam.pData = stOutFrame.pBufAddr
                stDisplayParam.nDataLen = stOutFrame.stFrameInfo.nFrameLen
                self.obj_cam.MV_CC_DisplayOneFrame(stDisplayParam)

                # 释放缓存
                self.obj_cam.MV_CC_FreeImageBuffer(stOutFrame)
            else:
                print("Camera[" + str(n_index) + "]:no data, ret = "+self.to_hex_str(ret))
                continue

    # 存BMP图像
    def save_bmp(self):
        if 0 == self.buf_save_image:
            return

        # 获取缓存锁
        self.buf_lock.acquire()

        file_path = "cam" + str(self.n_connect_num) + "_" + str(self.st_frame_info.nFrameNum) + ".bmp"
        c_file_path = file_path.encode('ascii')

        stSaveParam = MV_SAVE_IMAGE_TO_FILE_PARAM_EX()
        stSaveParam.enPixelType = self.st_frame_info.enPixelType  # ch:相机对应的像素格式 | en:Camera pixel type
        stSaveParam.nWidth = self.st_frame_info.nWidth  # ch:相机对应的宽 | en:Width
        stSaveParam.nHeight = self.st_frame_info.nHeight  # ch:相机对应的高 | en:Height
        stSaveParam.nDataLen = self.st_frame_info.nFrameLen
        stSaveParam.pData = cast(self.buf_save_image, POINTER(c_ubyte))
        stSaveParam.enImageType = MV_Image_Bmp  # ch:需要保存的图像类型 | en:Image format to save
        stSaveParam.pcImagePath = ctypes.create_string_buffer(c_file_path)
        stSaveParam.iMethodValue = 1
        ret = self.obj_cam.MV_CC_SaveImageToFileEx(stSaveParam)

        self.buf_lock.release()

        return ret


===== .//MultipleCameras/MultipleCameras.py =====
# -*- coding: utf-8 -*-
import sys
import time

from PyQt5.QtWidgets import *
from PyQt5.QtGui import QTextCursor
from CamOperation_class import CameraOperation
from MvCameraControl_class import *
from MvErrorDefine_const import *
from CameraParams_header import *
from PyUIMultipleCameras import Ui_MainWindow
import ctypes

# 将返回的错误码转换为十六进制显示
def ToHexStr(num):
    chaDic = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}
    hexStr = ""
    if num < 0:
        num = num + 2 ** 32
    while num >= 16:
        digit = num % 16
        hexStr = chaDic.get(digit, str(digit)) + hexStr
        num //= 16
    hexStr = chaDic.get(num, str(num)) + hexStr
    return hexStr

# Decoding Characters
def decoding_char(c_ubyte_value):
    c_char_p_value = ctypes.cast(c_ubyte_value, ctypes.c_char_p)
    try:
        decode_str = c_char_p_value.value.decode('gbk')  # Chinese characters
    except UnicodeDecodeError:
        decode_str = str(c_char_p_value.value)
    return decode_str


if __name__ == "__main__":

    global deviceList
    deviceList = MV_CC_DEVICE_INFO_LIST()

    global cam_checked_list
    cam_checked_list = []

    global obj_cam_operation
    obj_cam_operation = []

    global win_display_handles
    win_display_handles = []

    global valid_number
    valid_number = 0

    global b_is_open
    b_is_open = False

    global b_is_grab
    b_is_grab = False

    global b_is_trigger
    b_is_trigger = False

    global b_is_software_trigger
    b_is_software_trigger = False


    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    # print info in ui
    def print_text(str_info):
        ui.textEdit.moveCursor(QTextCursor.Start)
        ui.textEdit.insertPlainText(str_info + "\n")

    # ch:枚举相机 | en:enum devices
    def enum_devices():
        global deviceList
        global valid_number
        deviceList = MV_CC_DEVICE_INFO_LIST()
        n_layer_type = (MV_GIGE_DEVICE | MV_USB_DEVICE
                        | MV_GENTL_GIGE_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                        | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
        ret = MvCamera.MV_CC_EnumDevicesEx2(n_layer_type, deviceList, '', SortMethod_SerialNumber)
        if ret != 0:
            str_error = "Enum devices fail! ret = :" + ToHexStr(ret)
            QMessageBox.warning(mainWindow, "Error", str_error, QMessageBox.Ok)
            return ret

        if deviceList.nDeviceNum == 0:
            QMessageBox.warning(mainWindow, "Info", "Find no device", QMessageBox.Ok)
            return ret
        print_text("Find %d devices!" % deviceList.nDeviceNum)

        valid_number = 0
        for i in range(0, 4):
            if (i < deviceList.nDeviceNum) is True:
                serial_number = ""
                model_name = ""
                mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
                if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
                    print("\ngige device: [%d]" % i)
                    user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stGigEInfo.chUserDefinedName)
                    model_name = decoding_char(mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName)
                    print("device user define name: " + user_defined_name)
                    print("device model name: " + model_name)

                    nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
                    nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
                    nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
                    nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
                    print("current ip: %d.%d.%d.%d " % (nip1, nip2, nip3, nip4))

                    for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chSerialNumber:
                        if per == 0:
                            break
                        serial_number = serial_number + chr(per)

                elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
                    print("\nu3v device: [%d]" % i)
                    user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stUsb3VInfo.chUserDefinedName)
                    model_name = decoding_char(mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName)
                    print("device user define name: " + user_defined_name)
                    print("device model name: " + model_name)

                    for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                        if per == 0:
                            break
                        serial_number = serial_number + chr(per)
                    print("user serial number: " + serial_number)
                elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
                    print("\nCML device: [%d]" % i)
                    user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stCMLInfo.chUserDefinedName)
                    model_name = decoding_char(mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName)
                    print("device user define name: " + user_defined_name)
                    print("device model name: " + model_name)

                    for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                        if per == 0:
                            break
                        serial_number = serial_number + chr(per)
                    print("user serial number: " + serial_number)
                elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
                    print("\nCXP device: [%d]" % i)
                    user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stCXPInfo.chUserDefinedName)
                    model_name = decoding_char(mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName)
                    print("device user define name: " + user_defined_name)
                    print("device model name: " + model_name)

                    for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                        if per == 0:
                            break
                        serial_number = serial_number + chr(per)
                    print("user serial number: " + serial_number)
                elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
                    print("\nXoF device: [%d]" % i)
                    user_defined_name = decoding_char(mvcc_dev_info.SpecialInfo.stXoFInfo.chUserDefinedName)
                    model_name = decoding_char(mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName)
                    print("device user define name: " + user_defined_name)
                    print("device model name: " + model_name)

                    for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                        if per == 0:
                            break
                        serial_number = serial_number + chr(per)
                    print("user serial number: " + serial_number)

                button_by_id = cam_button_group.button(i)
                button_by_id.setText("(" + serial_number + ")" + model_name)
                button_by_id.setEnabled(True)
                valid_number = valid_number + 1
            else:
                button_by_id = cam_button_group.button(i)
                button_by_id.setEnabled(False)

    def cam_check_box_clicked():
        global cam_checked_list
        cam_checked_list = []
        for i in range(0, 4):
            button = cam_button_group.button(i)
            if button.isChecked() is True:
                cam_checked_list.append(True)
            else:
                cam_checked_list.append(False)

    def enable_ui_controls():
        global b_is_open
        global b_is_grab
        global b_is_trigger
        global b_is_software_trigger
        ui.pushButton_enum.setEnabled(not b_is_open)
        ui.pushButton_open.setEnabled(not b_is_open)
        ui.pushButton_close.setEnabled(b_is_open)
        result1 = False if b_is_grab else b_is_open
        result2 = b_is_open if b_is_grab else False
        ui.pushButton_startGrab.setEnabled(result1)
        ui.pushButton_stopGrab.setEnabled(result2)
        ui.pushButton_saveImg.setEnabled(result2)
        ui.radioButton_continuous.setEnabled(b_is_open)
        ui.radioButton_trigger.setEnabled(b_is_open)
        ui.pushButton_setParams.setEnabled(b_is_open)
        ui.lineEdit_gain.setEnabled(b_is_open)
        ui.lineEdit_frameRate.setEnabled(b_is_open)
        ui.lineEdit_exposureTime.setEnabled(b_is_open)
        result3 = b_is_open if b_is_trigger else False
        ui.pushButton_triggerOnce.setEnabled(b_is_software_trigger and result3)
        ui.checkBox_software_trigger.setEnabled(b_is_trigger)

    def open_devices():
        global deviceList
        global obj_cam_operation
        global b_is_open
        global valid_number
        global cam_checked_list
        b_checked = 0
        if b_is_open is True:
            return

        if len(cam_checked_list) <= 0:
            print_text("please select a camera !")
            return
        obj_cam_operation = []
        for i in range(0, 4):
            if cam_checked_list[i] is True:
                b_checked = True
                camObj = MvCamera()
                obj_cam_operation.append(CameraOperation(camObj, deviceList, i))
                ret = obj_cam_operation[i].open_device()
                if 0 != ret:
                    obj_cam_operation.pop()
                    print_text("open cam %d fail ret[0x%x]" % (i, ret))
                    continue
                else:
                    b_is_open = True
            else:
                obj_cam_operation.append(0)
        if b_checked is False:
            print_text("please select a camera !")
            return
        if b_is_open is False:
            print_text("no camera opened successfully !")
            return
        else:
            ui.radioButton_continuous.setChecked(True)
            enable_ui_controls()

        for i in range(0, 4):
            if(i < valid_number) is True:
                button_by_id = cam_button_group.button(i)
                button_by_id.setEnabled(not b_is_open)

    def software_trigger_check_box_clicked():
        global obj_cam_operation
        global b_is_software_trigger
        if (ui.checkBox_software_trigger.isChecked()) is True:
            b_is_software_trigger = True
            for i in range(0, 4):
                if obj_cam_operation[i] != 0:
                    ret = obj_cam_operation[i].set_trigger_source("software")
                    if 0 != ret:
                        print_text('camera' + str(i) + ' set trigger source: software  fail! ret = ' + ToHexStr(ret))
        else:
            b_is_software_trigger = False
            for i in range(0, 4):
                if obj_cam_operation[i] != 0:
                    ret = obj_cam_operation[i].set_trigger_source("hardware")
                    if 0 != ret:
                        print_text('camera' + str(i) + ' set trigger source: hardware  fail! ret = ' + ToHexStr(ret))
        enable_ui_controls()

    def radio_button_clicked(button):
        global obj_cam_operation
        global b_is_trigger
        button_id = raio_button_group.id(button)
        if (button_id == 0) is True:
            b_is_trigger = False
            for i in range(0, 4):
                if obj_cam_operation[i] != 0:
                    ret = obj_cam_operation[i].set_trigger_mode("continuous")
                    if 0 != ret:
                        print_text('camera' + str(i) + ' set trigger mode: continuous fail! ret = ' + ToHexStr(ret))
            enable_ui_controls()

        else:
            b_is_trigger = True
            for i in range(0, 4):
                if obj_cam_operation[i] != 0:
                    ret = obj_cam_operation[i].set_trigger_mode("triggermode")
                    if 0 != ret:
                        print_text('camera' + str(i) + ' set trigger on fail! ret = ' + ToHexStr(ret))
            enable_ui_controls()

    def close_devices():
        global b_is_open
        global obj_cam_operation
        global valid_number

        if b_is_open is False:
            return
        if b_is_grab is True:
            stop_grabbing()
        for i in range(0, 4):
            if obj_cam_operation[i] != 0:
                ret = obj_cam_operation[i].close_device()
                if 0 != ret:
                    print_text('camera' + str(i) + ' close device fail! ret = ' + ToHexStr(ret))

            if i < valid_number:
                button_by_id = cam_button_group.button(i)
                button_by_id.setEnabled(True)
        b_is_open = False
        enable_ui_controls()

    def start_grabbing():
        global obj_cam_operation
        global win_display_handles
        global b_is_open
        global b_is_grab

        if (not b_is_open) or (b_is_grab is True):
            return

        for i in range(0, 4):
            if obj_cam_operation[i] != 0:
                ret = obj_cam_operation[i].start_grabbing(i, win_display_handles[i])
                if 0 != ret:
                    print_text('camera' + str(i) + ' start grabbing fail! ret = ' + ToHexStr(ret))
                b_is_grab = True
        enable_ui_controls()

    def stop_grabbing():
        global b_is_grab
        global obj_cam_operation
        global b_is_open

        if (not b_is_open) or (b_is_grab is False):
            return
        for i in range(0, 4):
            if obj_cam_operation[i] != 0:
                ret = obj_cam_operation[i].stop_grabbing()
                if 0 != ret:
                    print_text('camera' + str(i) + ' stop grabbing fail!ret = ' + ToHexStr(ret))
                b_is_grab = False
        enable_ui_controls()

    # ch:存图 | en:save image
    def save_bmp():
        global b_is_grab
        global obj_cam_operation

        if b_is_grab is False:
            return
        for i in range(0, 4):
            if obj_cam_operation[i] != 0:
                ret = obj_cam_operation[i].save_bmp()
                if 0 != ret:
                    print_text('camera' + str(i) + ' save bmp fail!ret = ' + ToHexStr(ret))

    def is_float(str_value):
        try:
            float(str_value)
            return True
        except ValueError:
            return False

    def set_parameters():
        global obj_cam_operation
        global b_is_open
        if b_is_open is False:
            return

        frame_rate = ui.lineEdit_frameRate.text()
        exposure_time = ui.lineEdit_exposureTime.text()
        gain = ui.lineEdit_gain.text()

        if is_float(frame_rate) is False or is_float(exposure_time) is False or is_float(gain) is False:
            print_text("parameters is valid, please check")
            return

        for i in range(0, 4):
            if obj_cam_operation[i] != 0:
                ret = obj_cam_operation[i].set_exposure_time(exposure_time)
                if ret != 0:
                    print_text('camera' + str(i) + ' Set exposure time failed ret:' + ToHexStr(ret))
                ret = obj_cam_operation[i].set_gain(gain)
                if ret != 0:
                    print_text('camera' + str(i) + ' Set gain failed ret:' + ToHexStr(ret))
                ret = obj_cam_operation[i].set_frame_rate(frame_rate)
                if ret != 0:
                    print_text('camera' + str(i) + ' set acquisition frame rate failed ret:' + ToHexStr(ret))

    def software_trigger_once():
        for i in range(0, 4):
            if obj_cam_operation[i] != 0:
                ret = obj_cam_operation[i].trigger_once()
                if ret != 0:
                    print_text('camera' + str(i) + 'TriggerSoftware failed ret:' + ToHexStr(ret))

    # ch: 初始化app, 绑定控件与函数 | en: Init app, bind ui and api
    app = QApplication(sys.argv)
    mainWindow = QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(mainWindow)
    ui.pushButton_enum.clicked.connect(enum_devices)
    ui.pushButton_open.clicked.connect(open_devices)
    ui.pushButton_close.clicked.connect(close_devices)
    ui.pushButton_startGrab.clicked.connect(start_grabbing)
    ui.pushButton_stopGrab.clicked.connect(stop_grabbing)
    ui.pushButton_saveImg.clicked.connect(save_bmp)
    ui.pushButton_setParams.clicked.connect(set_parameters)
    ui.checkBox_software_trigger.clicked.connect(software_trigger_check_box_clicked)
    ui.pushButton_triggerOnce.clicked.connect(software_trigger_once)
    cam_button_group = QButtonGroup(mainWindow)
    cam_button_group.addButton(ui.checkBox_1, 0)
    cam_button_group.addButton(ui.checkBox_2, 1)
    cam_button_group.addButton(ui.checkBox_3, 2)
    cam_button_group.addButton(ui.checkBox_4, 3)

    cam_button_group.setExclusive(False)
    cam_button_group.buttonClicked.connect(cam_check_box_clicked)

    raio_button_group = QButtonGroup(mainWindow)
    raio_button_group.addButton(ui.radioButton_continuous, 0)
    raio_button_group.addButton(ui.radioButton_trigger, 1)
    raio_button_group.buttonClicked.connect(radio_button_clicked)

    win_display_handles.append(ui.widget_display1.winId())
    win_display_handles.append(ui.widget_display2.winId())
    win_display_handles.append(ui.widget_display3.winId())
    win_display_handles.append(ui.widget_display4.winId())

    mainWindow.show()
    enum_devices()
    enable_ui_controls()

    app.exec_()

    close_devices()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()

    sys.exit()


===== .//MultipleCameras/PyUIMultipleCameras.py =====
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'PyUIMultipleCameras.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1185, 818)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.widget_display1 = QtWidgets.QWidget(self.centralwidget)
        self.widget_display1.setMinimumSize(QtCore.QSize(200, 0))
        self.widget_display1.setObjectName("widget_display1")
        self.gridLayout.addWidget(self.widget_display1, 1, 0, 1, 1)
        self.checkBox_1 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_1.setObjectName("checkBox_1")
        self.gridLayout.addWidget(self.checkBox_1, 0, 0, 1, 1)
        self.checkBox_3 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_3.setObjectName("checkBox_3")
        self.gridLayout.addWidget(self.checkBox_3, 2, 0, 1, 1)
        self.checkBox_2 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_2.setObjectName("checkBox_2")
        self.gridLayout.addWidget(self.checkBox_2, 0, 1, 1, 1)
        self.checkBox_4 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_4.setObjectName("checkBox_4")
        self.gridLayout.addWidget(self.checkBox_4, 2, 1, 1, 1)
        self.widget_display2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_display2.setObjectName("widget_display2")
        self.gridLayout.addWidget(self.widget_display2, 1, 1, 1, 1)
        self.widget_display4 = QtWidgets.QWidget(self.centralwidget)
        self.widget_display4.setObjectName("widget_display4")
        self.gridLayout.addWidget(self.widget_display4, 3, 1, 1, 1)
        self.widget_display3 = QtWidgets.QWidget(self.centralwidget)
        self.widget_display3.setObjectName("widget_display3")
        self.gridLayout.addWidget(self.widget_display3, 3, 0, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setMaximumSize(QtCore.QSize(16777215, 120))
        self.textEdit.setObjectName("textEdit")
        self.verticalLayout.addWidget(self.textEdit)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.gridLayout_2 = QtWidgets.QGridLayout()
        self.gridLayout_2.setContentsMargins(10, -1, 10, -1)
        self.gridLayout_2.setHorizontalSpacing(30)
        self.gridLayout_2.setVerticalSpacing(2)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.pushButton_triggerOnce = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_triggerOnce.setObjectName("pushButton_triggerOnce")
        self.gridLayout_2.addWidget(self.pushButton_triggerOnce, 4, 1, 1, 1)
        self.label_exposure = QtWidgets.QLabel(self.centralwidget)
        self.label_exposure.setObjectName("label_exposure")
        self.gridLayout_2.addWidget(self.label_exposure, 6, 0, 1, 1)
        self.lineEdit_exposureTime = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_exposureTime.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.lineEdit_exposureTime.setObjectName("lineEdit_exposureTime")
        self.gridLayout_2.addWidget(self.lineEdit_exposureTime, 6, 1, 1, 1)
        self.radioButton_continuous = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_continuous.setObjectName("radioButton_continuous")
        self.gridLayout_2.addWidget(self.radioButton_continuous, 2, 0, 1, 1)
        self.pushButton_startGrab = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_startGrab.setMinimumSize(QtCore.QSize(0, 35))
        self.pushButton_startGrab.setObjectName("pushButton_startGrab")
        self.gridLayout_2.addWidget(self.pushButton_startGrab, 3, 0, 1, 1)
        self.pushButton_enum = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_enum.setMinimumSize(QtCore.QSize(0, 35))
        self.pushButton_enum.setObjectName("pushButton_enum")
        self.gridLayout_2.addWidget(self.pushButton_enum, 1, 1, 1, 1)
        self.label_gain = QtWidgets.QLabel(self.centralwidget)
        self.label_gain.setObjectName("label_gain")
        self.gridLayout_2.addWidget(self.label_gain, 7, 0, 1, 1)
        self.pushButton_setParams = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_setParams.setMinimumSize(QtCore.QSize(0, 35))
        self.pushButton_setParams.setObjectName("pushButton_setParams")
        self.gridLayout_2.addWidget(self.pushButton_setParams, 9, 1, 1, 1)
        self.lineEdit_gain = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_gain.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.lineEdit_gain.setObjectName("lineEdit_gain")
        self.gridLayout_2.addWidget(self.lineEdit_gain, 7, 1, 1, 1)
        self.lineEdit_frameRate = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_frameRate.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.lineEdit_frameRate.setObjectName("lineEdit_frameRate")
        self.gridLayout_2.addWidget(self.lineEdit_frameRate, 8, 1, 1, 1)
        self.radioButton_trigger = QtWidgets.QRadioButton(self.centralwidget)
        self.radioButton_trigger.setObjectName("radioButton_trigger")
        self.gridLayout_2.addWidget(self.radioButton_trigger, 2, 1, 1, 1)
        self.pushButton_saveImg = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_saveImg.setMinimumSize(QtCore.QSize(0, 35))
        self.pushButton_saveImg.setObjectName("pushButton_saveImg")
        self.gridLayout_2.addWidget(self.pushButton_saveImg, 5, 1, 1, 1)
        self.pushButton_stopGrab = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_stopGrab.setMinimumSize(QtCore.QSize(0, 35))
        self.pushButton_stopGrab.setObjectName("pushButton_stopGrab")
        self.gridLayout_2.addWidget(self.pushButton_stopGrab, 3, 1, 1, 1)
        self.pushButton_close = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_close.setMinimumSize(QtCore.QSize(0, 35))
        self.pushButton_close.setObjectName("pushButton_close")
        self.gridLayout_2.addWidget(self.pushButton_close, 0, 1, 1, 1)
        self.pushButton_open = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_open.setMinimumSize(QtCore.QSize(0, 35))
        self.pushButton_open.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.pushButton_open.setObjectName("pushButton_open")
        self.gridLayout_2.addWidget(self.pushButton_open, 0, 0, 1, 1)
        self.checkBox_software_trigger = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_software_trigger.setObjectName("checkBox_software_trigger")
        self.gridLayout_2.addWidget(self.checkBox_software_trigger, 4, 0, 1, 1)
        self.label_frameRate = QtWidgets.QLabel(self.centralwidget)
        self.label_frameRate.setObjectName("label_frameRate")
        self.gridLayout_2.addWidget(self.label_frameRate, 8, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 250, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 10, 0, 1, 1)
        self.gridLayout_2.setColumnStretch(0, 1)
        self.horizontalLayout.addLayout(self.gridLayout_2)
        self.horizontalLayout.setStretch(0, 2)
        self.horizontalLayout.setStretch(1, 1)
        self.horizontalLayout_2.addLayout(self.horizontalLayout)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1185, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.checkBox_1.setText(_translate("MainWindow", "Cam1"))
        self.checkBox_3.setText(_translate("MainWindow", "Cam3"))
        self.checkBox_2.setText(_translate("MainWindow", "Cam2"))
        self.checkBox_4.setText(_translate("MainWindow", "Cam4"))
        self.pushButton_triggerOnce.setText(_translate("MainWindow", "Trigger by \n"
"software once"))
        self.label_exposure.setText(_translate("MainWindow", "Exposure time"))
        self.radioButton_continuous.setText(_translate("MainWindow", "Continuous"))
        self.pushButton_startGrab.setText(_translate("MainWindow", "Start"))
        self.pushButton_enum.setText(_translate("MainWindow", "Enum"))
        self.label_gain.setText(_translate("MainWindow", "Gain"))
        self.pushButton_setParams.setText(_translate("MainWindow", "Set parameter"))
        self.radioButton_trigger.setText(_translate("MainWindow", "Trigger Mode"))
        self.pushButton_saveImg.setText(_translate("MainWindow", "Save image"))
        self.pushButton_stopGrab.setText(_translate("MainWindow", "Stop"))
        self.pushButton_close.setText(_translate("MainWindow", "Close"))
        self.pushButton_open.setText(_translate("MainWindow", "Open"))
        self.checkBox_software_trigger.setText(_translate("MainWindow", "Software \n"
"Trigger"))
        self.label_frameRate.setText(_translate("MainWindow", "Frame rate"))


===== .//MvImport/CameraParams_const.py =====
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# \~chinese 设备类型定义    \~english Device Type Definition
MV_UNKNOW_DEVICE                             = 0x00000000  # < \~chinese 未知设备类型，保留意义       \~english Unknown Device Type, Reserved
MV_GIGE_DEVICE                               = 0x00000001  # < \~chinese GigE设备                     \~english GigE Device
MV_1394_DEVICE                               = 0x00000002  # < \~chinese 1394-a/b 设备                \~english 1394-a/b Device
MV_USB_DEVICE                                = 0x00000004  # < \~chinese USB 设备                     \~english USB Device
MV_CAMERALINK_DEVICE                         = 0x00000008  # < \~chinese CameraLink设备               \~english CameraLink Device
MV_VIR_GIGE_DEVICE                           = 0x00000010  # < \~chinese 虚拟GigE设备               \~english Virtual GigE Device
MV_VIR_USB_DEVICE                            = 0x00000020  # < \~chinese 虚拟USB设备                \~english Virtual USB Device
MV_GENTL_GIGE_DEVICE                         = 0x00000040  # < \~chinese 自研网卡下GigE设备          \~english GenTL GigE Device
MV_GENTL_CAMERALINK_DEVICE                   = 0x00000080  # < \~chinese CameraLink设备            \~english GenTL CameraLink Device
MV_GENTL_CXP_DEVICE                          = 0x00000100  # < \~chinese CoaXPress设备             \~english GenTL CoaXPress Device
MV_GENTL_XOF_DEVICE                          = 0x00000200  # < \~chinese XoF设备                   \~english GenTL XoF Device

# \~chinese 采集卡类型         \~english Interface type
MV_GIGE_INTERFACE                    = 0x00000001          # < \~chinese GigE Vision采集卡        \~english GigE Vision interface
MV_CAMERALINK_INTERFACE              = 0x00000004          # < \~chinese Camera Link采集卡        \~english Camera Link interface
MV_CXP_INTERFACE                     = 0x00000008          # < \~chinese CoaXPress采集卡          \~english CoaXPress interface
MV_XOF_INTERFACE                     = 0x00000010          # < \~chinese XoFLink采集卡            \~english XoFLink interface

INFO_MAX_BUFFER_SIZE                         = 64          # < \~chinese 最大的数据信息大小           \~english Maximum data information size

MV_MAX_TLS_NUM                               = 8           # < \~chinese 最多支持的传输层实例个数     \~english The maximum number of supported transport layer instances
MV_MAX_DEVICE_NUM                            = 256         # < \~chinese 最大支持的设备个数           \~english The maximum number of supported devices

MV_MAX_INTERFACE_NUM                         = 64          #< \~chinese 最大支持的采集卡数量  \~english The maximum number of Frame Grabber interface supported

MV_MAX_SERIAL_PORT_NUM                       = 64          # \~chinese 最大支持的串口数量  \~english The maximum number of serial port supported

MV_MAX_GENTL_IF_NUM                          = 256         # < \~chinese 最大支持的GenTL数量          \~english The maximum number of GenTL supported
MV_MAX_GENTL_DEV_NUM                         = 256         # < \~chinese 最大支持的GenTL设备数量      \~english The maximum number of GenTL devices supported

# \~chinese 设备的访问模式    \~english Device Access Mode
# \~chinese 独占权限，其他APP只允许读CCP寄存器                        \~english Exclusive authority, other APP is only allowed to read the CCP register
MV_ACCESS_Exclusive                          = 1
# \~chinese 可以从5模式下抢占权限，然后以独占权限打开                 \~english You can seize the authority from the 5 mode, and then open with exclusive authority
MV_ACCESS_ExclusiveWithSwitch                = 2
# \~chinese 控制权限，其他APP允许读所有寄存器                         \~english Control authority, allows other APP reading all registers
MV_ACCESS_Control                            = 3
# \~chinese 可以从5的模式下抢占权限，然后以控制权限打开               \~english You can seize the authority from the 5 mode, and then open with control authority
MV_ACCESS_ControlWithSwitch                  = 4
# \~chinese 以可被抢占的控制权限打开                                  \~english Open with seized control authority
MV_ACCESS_ControlSwitchEnable                = 5
# \~chinese 可以从5的模式下抢占权限，然后以可被抢占的控制权限打开     \~english You can seize the authority from the 5 mode, and then open with seized control authority
MV_ACCESS_ControlSwitchEnableWithKey         = 6
# \~chinese 读模式打开设备，适用于控制权限下                          \~english Open with read mode and is available under control authority
MV_ACCESS_Monitor                            = 7

MV_MATCH_TYPE_NET_DETECT                     = 0x00000001  # < \~chinese 网络流量和丢包信息              \~english Network traffic and packet loss information
MV_MATCH_TYPE_USB_DETECT                     = 0x00000002  # < \~chinese host接收到来自U3V设备的字节总数 \~english The total number of bytes host received from U3V device

# \~chinese GigEVision IP配置    \~english GigEVision IP Configuration
MV_IP_CFG_STATIC                             = 0x05000000  # < \~chinese 静态         \~english Static
MV_IP_CFG_DHCP                               = 0x06000000  # < \~chinese DHCP         \~english DHCP
MV_IP_CFG_LLA                                = 0x04000000  # < \~chinese LLA          \~english LLA

# \~chinese GigEVision网络传输模式    \~english GigEVision Net Transfer Mode
MV_NET_TRANS_DRIVER                          = 0x00000001  # < \~chinese 驱动         \~english Driver
MV_NET_TRANS_SOCKET                          = 0x00000002  # < \~chinese Socket       \~english Socket

# \~chinese CameraLink波特率    \~english CameraLink Baud Rates (CLUINT32)
MV_CAML_BAUDRATE_9600                        = 0x00000001  # < \~chinese 9600         \~english 9600
MV_CAML_BAUDRATE_19200                       = 0x00000002  # < \~chinese 19200        \~english 19200
MV_CAML_BAUDRATE_38400                       = 0x00000004  # < \~chinese 38400        \~english 38400
MV_CAML_BAUDRATE_57600                       = 0x00000008  # < \~chinese 57600        \~english 57600
MV_CAML_BAUDRATE_115200                      = 0x00000010  # < \~chinese 115200       \~english 115200
MV_CAML_BAUDRATE_230400                      = 0x00000020  # < \~chinese 230400       \~english 230400
MV_CAML_BAUDRATE_460800                      = 0x00000040  # < \~chinese 460800       \~english 460800
MV_CAML_BAUDRATE_921600                      = 0x00000080  # < \~chinese 921600       \~english 921600
MV_CAML_BAUDRATE_AUTOMAX                     = 0x40000000  # < \~chinese 最大值       \~english Auto Max

# \~chinese 异常消息类型    \~english Exception message type
MV_EXCEPTION_DEV_DISCONNECT                  = 0x00008001  # < \~chinese 设备断开连接              \~english The device is disconnected
MV_EXCEPTION_VERSION_CHECK                   = 0x00008002  # < \~chinese SDK与驱动版本不匹配       \~english SDK does not match the driver version

MAX_EVENT_NAME_SIZE                          = 128         # < \~chinese 设备Event事件名称最大长度 \~english Max length of event name
MV_MAX_XML_SYMBOLIC_NUM                      = 64          # \~chinese 最大XML符号数               \~english Max XML Symbolic Number
MV_MAX_SYMBOLIC_LEN                          = 64          # \~chinese 最大枚举条目对应的符号长度     \~english Max Enum Entry Symbolic Number

MV_MAX_SPLIT_NUM                             = 8           # \~chinese 分时曝光时最多将源图像拆分的个数 \~english The maximum number of source image to be split in time-division exposure


===== .//MvImport/CameraParams_header.py =====
# -*- coding: utf-8 -*-
# generated by 'xml2py'
# flags '-c -d -v C:\test_h\CameraParams.xml -o CameraParams_header.py'
from ctypes import *
from CameraParams_const import *
from PixelType_header import *

STRING = c_char_p

MV_PointCloudFile_Undefined = 0                  # < \~chinese 未定义的点云格式                  \~english Undefined point cloud format
MV_ACQ_MODE_CONTINUOUS = 2                       # < \~chinese 持续采集模式                      \~english Continuous Mode
MV_ACQ_MODE_MUTLI = 1                            # < \~chinese 多帧模式                          \~english Multi Mode
MV_TRIGGER_MODE_ON = 1                           # < \~chinese 打开                              \~english On
AM_CycleDetect = 6                               # < \~chinese 内部用于AccessMode循环检测         \~english used internally for AccessMode cycle detection
AM_Undefined = 5                                 # < \~chinese 对象未被初始化                     \~english Object is not yet initialized
AM_RW = 4                                        # < \~chinese 读和写                            \~english Read and Write
AM_RO = 3                                        # < \~chinese 只读                              \~english Read Only
AM_WO = 2                                        # < \~chinese 只写                              \~english Write Only
AM_NA = 1                                        # < \~chinese 不可用                            \~english Not available
AM_NI = 0                                        # < \~chinese 没有实现                          \~english Not implemented
MV_Image_Tif = 4                                 # < \~chinese Tif格式                           \~english Tif image file
MV_Image_Png = 3                                 # < \~chinese Png格式                           \~english Png image file
MV_Image_Jpeg = 2                                # < \~chinese Jpeg格式                          \~english Jpeg image file
MV_Image_Bmp = 1                                 # < \~chinese Bmp格式                           \~english Bmp image file
MV_GAIN_MODE_CONTINUOUS = 2                      # < \~chinese 连续                              \~english Gain Mode Continuous 
MV_GAIN_MODE_ONCE = 1                            # < \~chinese 单次                              \~english Gain Mode Once
MV_GrabStrategy_UpcomingImage = 3                # < \~chinese 等待下一帧图像                     \~english Wait for the next image
MV_GrabStrategy_LatestImages = 2                 # < \~chinese 获取列表中最新的图像               \~english Gets the latest image in the list
MV_GrabStrategy_LatestImagesOnly = 1             # < \~chinese 获取列表中最新的一帧图像（同时清除列表中的其余图像）         \~english Gets the most recent image in the list (while clearing the rest of the images in the list)
MV_PointCloudFile_OBJ = 3                        # < \~chinese OBJ点云格式                       \~english The point cloud format named OBJ
MV_PointCloudFile_CSV = 2                        # < \~chinese CSV点云格式                       \~english The point cloud format named CSV
MV_PointCloudFile_PLY = 1                        # < \~chinese PLY点云格式                       \~english The point cloud format named PLY
MV_ACQ_MODE_SINGLE = 0                           # < \~chinese 单帧模式                          \~english Single Mode
MV_TRIGGER_MODE_OFF = 0                          # < \~chinese 关闭                             \~english Off
MV_TRIGGER_SOURCE_SOFTWARE = 7                   # < \~chinese 软触发                           \~english Trigger source software
MV_EXPOSURE_MODE_TIMED = 0                       # < \~chinese 曝光超时模式                      \~english exposure mode timed
MV_FormatType_Undefined = 0                      # < \~chinese 未定义的格式类型                  \~english Undefined format type
MV_GAIN_MODE_OFF = 0                             # < \~chinese 关闭增益模式                     \~english Gain mode off
MV_EXPOSURE_AUTO_MODE_CONTINUOUS = 2             # < \~chinese 自动连续曝光模式                 \~english Exposure auto mode continuous
MV_EXPOSURE_AUTO_MODE_ONCE = 1                   # < \~chinese 单次自动曝光模式                 \~english Exposure auto mode once
MV_EXPOSURE_AUTO_MODE_OFF = 0                    # < \~chinese 关闭自动曝光模式                 \~english Exposure auto mode off
IFT_IValue = 0                                   # < \~chinese IValue接口类型                  \~english IValue interface
MV_GrabStrategy_OneByOne = 0                     # < \~chinese 从旧到新一帧一帧的获取图像        \~english Frame by frame from old to new
MV_FormatType_AVI = 1                            # < \~chinese AVI视频格式                     \~english AVI format type
MV_GAMMA_SELECTOR_USER = 1                       # < \~chinese gamma选择项User                 \~english This enumeration selects the type of gamma to apply
IFT_IString = 6                                  # < \~chinese IString接口类型                 \~english IString interface
MV_BALANCEWHITE_AUTO_OFF = 0                     # < \~chinese 白平衡自动关闭                   \~english Balance white auto off
MV_GAMMA_SELECTOR_SRGB = 2                       # < \~chinese gamma选择项SRGB                 \~english This enumeration selects the type of gamma to apply
IFT_IPort = 11                                   # < \~chinese IPort接口类型                   \~english IPort interface
MV_BALANCEWHITE_AUTO_CONTINUOUS = 1              # < \~chinese 白平衡自动连续                   \~english Balance white auto continuous
IFT_IEnumEntry = 10                              # < \~chinese IEnumEntry接口类型              \~english IEnumEntry interface
IFT_ICategory = 8                                # < \~chinese ICategory接口类型               \~english ICategory interface
IFT_IRegister = 7                                # < \~chinese IRegister接口类型               \~english IRegister interface
MV_Image_Undefined = 0                           # < \~chinese 未定义的图像类型                 \~english Image undefined
IFT_IFloat = 5                                   # < \~chinese IFloat接口类型                  \~english IFloat interface
IFT_IEnumeration = 9                             # < \~chinese IEnumeration接口类型            \~english IEnumeration interface
IFT_ICommand = 4                                 # < \~chinese ICommand接口类型                \~english ICommand interface
IFT_IBoolean = 3                                 # < \~chinese IBoolean接口类型                \~english IBoolean interface
IFT_IInteger = 2                                 # < \~chinese IInteger接口类型                \~english IInteger interface
MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV = 65537 # < \~chinese 表示组播模式，但本实例不接收图像数据         \~english Multicast without receive data
IFT_IBase = 1                                    # < \~chinese IBase接口类型                             \~english IBase interface
MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV = 65536   # < \~chinese 表示设置了单播，但本实例不接收图像数据       \~english Unicast without receive data
MV_BALANCEWHITE_AUTO_ONCE = 2                    # < \~chinese 单次自动白平衡                             \~english Balance white auto once
MV_GIGE_TRANSTYPE_LIMITEDBROADCAST = 2           # < \~chinese 表示局域网内广播，暂不支持                  \~english Limited broadcast mode,not support
MV_GIGE_TRANSTYPE_MULTICAST = 1                  # < \~chinese 表示组播                                  \~english Multicast mode
MV_GIGE_TRANSTYPE_UNICAST = 0                    # < \~chinese 表示单播(默认)                            \~english Unicast mode(default)
MV_GIGE_TRANSTYPE_CAMERADEFINED = 4              # < \~chinese 表示从相机获取，暂不支持                   \~english Transtype from camera,not support
MV_GIGE_TRANSTYPE_SUBNETBROADCAST = 3            # < \~chinese 表示子网内广播，暂不支持                   \~english Subnet broadcast mode,not support
MV_EXPOSURE_MODE_TRIGGER_WIDTH = 1               # < \~chinese 曝光模式触发宽                            \~english Trigger width
MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT = 5       # < \~chinese 表示用户自定义应用端接收图像数据Port号      \~english User Defined Receive Data Port
MV_TRIGGER_SOURCE_FrequencyConverter = 8         # < \~chinese 触发源变频器                              \~english Trigger source frequency converter
MV_TRIGGER_SOURCE_COUNTER0 = 4                   # < \~chinese 触发源计数器                              \~english Trigger source conuter
MV_TRIGGER_SOURCE_LINE3 = 3                      # < \~chinese LINE3 触发源                             \~english Trigger source line3
MV_TRIGGER_SOURCE_LINE2 = 2                      # < \~chinese LINE2 触发源                             \~english Trigger source line2
MV_TRIGGER_SOURCE_LINE1 = 1                      # < \~chinese LINE1 触发源                             \~english Trigger source line1
MV_TRIGGER_SOURCE_LINE0 = 0                      # < \~chinese LINE0 触发源                             \~english Trigger source line0
SortMethod_SerialNumber = 0                      # < \~chinese 按序列号排序                     \~english Sorting by SerialNumber
SortMethod_UserID = 1                            # < \~chinese 按用户自定义名字排序             \~english Sorting by UserID
SortMethod_CurrentIP_ASC = 2                     # < \~chinese 按当前IP地址排序（升序）         \~english Sorting by current IP（Ascending）
SortMethod_CurrentIP_DESC = 3                    # < \~chinese 按当前IP地址排序（降序）         \~english Sorting by current IP（Descending）
MV_IMAGE_ROTATE_90 = 1                           # < \~chinese 旋转90度         \~english Rotate 90 degrees
MV_IMAGE_ROTATE_180 = 2                          # < \~chinese 旋转180度         \~english Rotate 180 degrees
MV_IMAGE_ROTATE_270 = 3                          # < \~chinese 旋转270度         \~english Rotate 270 degrees
MV_FLIP_VERTICAL = 1                             # < \~chinese 垂直翻转          \~english flip vertical
MV_FLIP_HORIZONTAL = 2                           # < \~chinese 水平翻转         \~english flip horizontal
MV_CC_GAMMA_TYPE_NONE = 0                        # < \~chinese 不启用                       \~english Disable
MV_CC_GAMMA_TYPE_VALUE = 1                       # < \~chinese Gamma值                      \~english Gamma value
MV_CC_GAMMA_TYPE_USER_CURVE = 2                  # < \~chinese Gamma曲线                    \~english Gamma curve
MV_CC_GAMMA_TYPE_LRGB2SRGB = 3                   # < \~chinese linear RGB to sRGB           \~english linear RGB to sRGB
MV_CC_GAMMA_TYPE_SRGB2LRGB = 4                   # < \~chinese sRGB to linear RGB(仅色彩插值时支持，色彩校正时无效) \~english sRGB to linear RGB
MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE = 0x4001   # < \~chinese 异常的图像，该帧被丢弃            \~english abnormal image,the frame is discarded
MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW = 0x4002    # < \~chinese 缓存列表溢出，清除最旧的一帧       \~english Cache list overflow, clear the oldest frame
MV_CC_STREAM_EXCEPTION_LIST_EMPTY = 0x4003       # < \~chinese 缓存列表为空，该帧被丢弃           \~english Cache list is empty,the frame is discarded
MV_CC_STREAM_EXCEPTION_RECONNECTION = 0x4004    # < \~chinese 断流恢复                         \~english reconnect
MV_CC_STREAM_EXCEPTION_DISCONNECTED = 0x4005    # < \~chinese 断流,恢复失败,取流被中止    \~english reconnect fail, stream is  terminated
MV_CC_STREAM_EXCEPTION_DEVICE = 0x4006          # < \~chinese 设备异常,取流被中止         \~english device exception
MV_SPLIT_BY_LINE = 1                            #< \~chinese 源图像按行拆分成多张图像         \~english Source image split into multiple images by line
int8_t = c_int8
int16_t = c_int16
int32_t = c_int32
int64_t = c_int64
uint8_t = c_uint8
uint16_t = c_uint16
uint32_t = c_uint32
uint64_t = c_uint64
int_least8_t = c_byte
int_least16_t = c_short
int_least32_t = c_int
int_least64_t = c_long
uint_least8_t = c_ubyte
uint_least16_t = c_ushort
uint_least32_t = c_uint
uint_least64_t = c_ulong
int_fast8_t = c_byte
int_fast16_t = c_long
int_fast32_t = c_long
int_fast64_t = c_long
uint_fast8_t = c_ubyte
uint_fast16_t = c_ulong
uint_fast32_t = c_ulong
uint_fast64_t = c_ulong
intptr_t = c_long
uintptr_t = c_ulong
intmax_t = c_long
uintmax_t = c_ulong

# GigE设备信息    \~english GigE device info
class _MV_GIGE_DEVICE_INFO_(Structure):
    pass
_MV_GIGE_DEVICE_INFO_._fields_ = [
    ('nIpCfgOption', c_uint),                     # < \~chinese IP配置选项         \~english Ip config option
    ('nIpCfgCurrent', c_uint),                    # < \~chinese 当前IP地址配置     \~english IP configuration:bit31-static bit30-dhcp bit29-lla
    ('nCurrentIp', c_uint),                       # < \~chinese 当前主机IP地址     \~english Current host Ip 
    ('nCurrentSubNetMask', c_uint),               # < \~chinese 当前子网掩码       \~english curtent subnet mask
    ('nDefultGateWay', c_uint),                   # < \~chinese 默认网关           \~english Default gate way
    ('chManufacturerName', c_ubyte * 32),         # < \~chinese 厂商名称           \~english Manufacturer Name
    ('chModelName', c_ubyte * 32),                # < \~chinese 型号名称           \~english Mode name
    ('chDeviceVersion', c_ubyte * 32),            # < \~chinese 设备固件版本       \~english Device Version
    ('chManufacturerSpecificInfo', c_ubyte * 48), # < \~chinese 厂商特殊信息       \~english Manufacturer Specific Infomation
    ('chSerialNumber', c_ubyte * 16),             # < \~chinese 序列号            \~english serial number
    ('chUserDefinedName', c_ubyte * 16),          # < \~chinese 用户定义名称       \~english User Defined Name
    ('nNetExport', c_uint),                       # < \~chinese 网口Ip地址         \~english NetWork Ip address
    ('nReserved', c_uint * 4),                    # < \~chinese 保留字节           \~english Reserved bytes
]
MV_GIGE_DEVICE_INFO = _MV_GIGE_DEVICE_INFO_

# USB设备信息    \~english USB device info
class _MV_USB3_DEVICE_INFO_(Structure):
    pass
_MV_USB3_DEVICE_INFO_._fields_ = [
    ('CrtlInEndPoint', c_ubyte),                            # < \~chinese 控制输入端点          \~english Control input endpoint
    ('CrtlOutEndPoint', c_ubyte),                           # < \~chinese 控制输出端点          \~english Control output endpoint
    ('StreamEndPoint', c_ubyte),                            # < \~chinese 流端点                \~english Flow endpoint
    ('EventEndPoint', c_ubyte),                             # < \~chinese 事件端点              \~english Event endpoint
    ('idVendor', c_ushort),                                 # < \~chinese 供应商ID号            \~english Vendor ID Number
    ('idProduct', c_ushort),                                # < \~chinese 产品ID号              \~english Device ID Number
    ('nDeviceNumber', c_uint),                              # < \~chinese 设备序列号            \~english Device Serial Number
    ('chDeviceGUID', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 设备GUID号            \~english Device GUID Number
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 供应商名字            \~english Vendor Name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),        # < \~chinese 型号名字              \~english Model Name
    ('chFamilyName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 家族名字              \~english Family Name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 设备版本号            \~english Device Version
    ('chManufacturerName', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese 制造商名字            \~english Manufacturer Name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号                \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字         \~english User Defined Name
    ('nbcdUSB', c_uint),                                    # < \~chinese 支持的USB协议         \~english Support USB Protocol
    ('nDeviceAddress', c_uint),                             # < \~chinese 设备地址              \~english Device Address
    ('nReserved', c_uint * 2),                              # < \~chinese 保留字节              \~english Reserved bytes
]
MV_USB3_DEVICE_INFO = _MV_USB3_DEVICE_INFO_

# CameraLink设备信息    \~english CameraLink device info
class _MV_CamL_DEV_INFO_(Structure):
    pass
_MV_CamL_DEV_INFO_._fields_ = [
    ('chPortID', c_ubyte * INFO_MAX_BUFFER_SIZE),           # < \~chinese 端口号            \~english Port ID         
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),        # < \~chinese 设备型号          \~english Model name
    ('chFamilyName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 家族名字          \~english Family Name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 设备版本号        \~english Device Version
    ('chManufacturerName', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese 制造商名字        \~english Manufacturer Name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('nReserved', c_uint * 38),                             # < \~chinese 保留字节          \~english Reserved bytes
]
MV_CamL_DEV_INFO = _MV_CamL_DEV_INFO_

# 采集卡Camera Link相机信息          \~english Camera Link device information on frame grabber
class _MV_CML_DEVICE_INFO_(Structure):
    pass
_MV_CML_DEVICE_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 采集卡ID   \~english Interface ID of Frame Grabber
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 供应商名字       \~english Vendor name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号名字         \~english Model name
    ('chManufacturerInfo', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 厂商信息   \~english Manufacturer information
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 相机版本          \~english Device version
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字      \~english User defined name
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 相机ID            \~english Device ID
    ('nReserved', c_uint * 7),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_CML_DEVICE_INFO = _MV_CML_DEVICE_INFO_

# CoaXPress相机信息      \~english CoaXPress device information
class _MV_CXP_DEVICE_INFO_(Structure):
    pass
_MV_CXP_DEVICE_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 采集卡ID   \~english Interface ID of Frame Grabber
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 供应商名字       \~english Vendor name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号名字         \~english Model name
    ('chManufacturerInfo', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 厂商信息   \~english Manufacturer information
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 相机版本          \~english Device version
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字      \~english User defined name
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 相机ID            \~english Device ID
    ('nReserved', c_uint * 7),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_CXP_DEVICE_INFO = _MV_CXP_DEVICE_INFO_

# XoFLink相机信息      \~english XoFLink device information
class _MV_XOF_DEVICE_INFO_(Structure):
    pass
_MV_XOF_DEVICE_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 采集卡ID   \~english Interface ID of Frame Grabber
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 供应商名字       \~english Vendor name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号名字         \~english Model name
    ('chManufacturerInfo', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 厂商信息   \~english Manufacturer information
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 相机版本          \~english Device version
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字      \~english User defined name
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 相机ID            \~english Device ID
    ('nReserved', c_uint * 7),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_XOF_DEVICE_INFO = _MV_XOF_DEVICE_INFO_

# CameraParams.h 80
class _MV_CC_DEVICE_INFO_(Structure):
    pass
# 设备信息    \~english Device info
class N19_MV_CC_DEVICE_INFO_3DOT_0E(Union):
    pass
N19_MV_CC_DEVICE_INFO_3DOT_0E._fields_ = [
    ('stGigEInfo', MV_GIGE_DEVICE_INFO),                   # < \~chinese Gige设备信息        \~english Gige device infomation
    ('stUsb3VInfo', MV_USB3_DEVICE_INFO),                  # < \~chinese U3V设备信息         \~english u3V device information
    ('stCamLInfo', MV_CamL_DEV_INFO),                      # < \~chinese CamLink设备信息     \~english CamLink device information
    ('stCMLInfo', MV_CML_DEVICE_INFO),  # < \~chinese 采集卡CameraLink设备信息     \~english CameraLink Device Info On Frame Grabber
    ('stCXPInfo', MV_CXP_DEVICE_INFO),  # < \~chinese 采集卡CoaXPress设备信息     \~english CoaXPress Device Info On Frame Grabber
    ('stXoFInfo', MV_XOF_DEVICE_INFO),  # < \~chinese 采集卡XoF设备信息          \~english XoF Device Info On Frame Grabber
]

_MV_CC_DEVICE_INFO_._fields_ = [
    ('nMajorVer', c_ushort),                              # < \~chinese 规范的主要版本         \~english Major version of the specification.
    ('nMinorVer', c_ushort),                              # < \~chinese 规范的次要版本         \~english Minor version of the specification
    ('nMacAddrHigh', c_uint),                             # < \~chinese MAC地址高位           \~english Mac address high
    ('nMacAddrLow', c_uint),                              # < \~chinese MAC地址低位           \~english Mac address low
    ('nTLayerType', c_uint),                              # < \~chinese 设备传输层协议类型     \~english Device Transport Layer Protocol Type, e.g. MV_GIGE_DEVICE
    ('nDevTypeInfo', c_uint),                             # < \~chinese 设备类型信息         \~english Device Type Info
    ('nReserved', c_uint * 3),                            # < \~chinese 保留字节              \~english Reserved bytes
    ('SpecialInfo', N19_MV_CC_DEVICE_INFO_3DOT_0E),       # < \~chinese 不同设备特有信息       \~english Special information
]
MV_CC_DEVICE_INFO = _MV_CC_DEVICE_INFO_

# 设备信息列表    \~english Device Information List
class _MV_CC_DEVICE_INFO_LIST_(Structure):
    pass
_MV_CC_DEVICE_INFO_LIST_._fields_ = [
    ('nDeviceNum', c_uint),                                          # < \~chinese 在线设备数量         \~english Online Device Number
    ('pDeviceInfo', POINTER(MV_CC_DEVICE_INFO) * MV_MAX_DEVICE_NUM), # < \~chinese 支持最多256个设备    \~english Support up to 256 devices
]
MV_CC_DEVICE_INFO_LIST = _MV_CC_DEVICE_INFO_LIST_

# 通过GenTL枚举到的Interface信息    \~english Interface Information with GenTL
class _MV_GENTL_IF_INFO_(Structure):
    pass
_MV_GENTL_IF_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese GenTL接口ID        \~english Interface ID of GenTL
    ('chTLType', c_ubyte * INFO_MAX_BUFFER_SIZE),      # < \~chinese 传输层类型          \~english Transport Layer type
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese 设备显示名称         \~english Display name
    ('nCtiIndex', c_uint),                             # < \~chinese GenTL的cti文件索引   \~english Cti file index of GenTL 
    ('nReserved', c_uint * 8),                         # < \~chinese 保留字节             \~english Reserved bytes
]
MV_GENTL_IF_INFO = _MV_GENTL_IF_INFO_

# 通过GenTL枚举到的设备信息列表    \~english Device Information List with GenTL
class _MV_GENTL_IF_INFO_LIST_(Structure):
    pass
_MV_GENTL_IF_INFO_LIST_._fields_ = [
    ('nInterfaceNum', c_uint),                                    # < \~chinese 在线设备数量         \~english Online Device Number
    ('pIFInfo', POINTER(MV_GENTL_IF_INFO) * MV_MAX_GENTL_IF_NUM), # < \~chinese 支持最多256个设备     \~english Support up to 256 devices
]
MV_GENTL_IF_INFO_LIST = _MV_GENTL_IF_INFO_LIST_

# 通过GenTL枚举到的设备信息    \~english Device Information with GenTL
class _MV_GENTL_DEV_INFO_(Structure):
    pass
_MV_GENTL_DEV_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),          # < \~chinese GenTL接口ID         \~english Interface ID of GenTL
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),             # < \~chinese 设备ID              \~english Device ID
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),           # < \~chinese 供应商名字          \~english Vendor Name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),            # < \~chinese 型号名字            \~english Model name
    ('chTLType', c_ubyte * INFO_MAX_BUFFER_SIZE),               # < \~chinese 传输层类型          \~english Transport Layer type
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE),          # < \~chinese 显示名称           \~english Display name
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),      # < \~chinese 用户自定义名字      \~english User defined name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 序列号             \~english Serial number
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),        # < \~chinese 设备版本号         \~english Device version
    ('nCtiIndex', c_uint),                                      # < \~chinese cti索引            \~english Cti Index
    ('nReserved', c_uint * 8),                                  # < \~chinese 保留字节           \~english Reserved bytes
]
MV_GENTL_DEV_INFO = _MV_GENTL_DEV_INFO_

# 通过GenTL枚举到的设备信息列表    \~english Device Information List with GenTL
class _MV_GENTL_DEV_INFO_LIST_(Structure):
    pass
_MV_GENTL_DEV_INFO_LIST_._fields_ = [
    ('nDeviceNum', c_uint),                                             # < \~chinese 在线设备数量         \~english Online Device Number
    ('pDeviceInfo', POINTER(MV_GENTL_DEV_INFO) * MV_MAX_GENTL_DEV_NUM), # < \~chinese GenTL设备信息       \~english device infomation of GenTL device
]
MV_GENTL_DEV_INFO_LIST = _MV_GENTL_DEV_INFO_LIST_

# Chunk内容    \~english The content of ChunkData
class _MV_CHUNK_DATA_CONTENT_(Structure):
    pass
_MV_CHUNK_DATA_CONTENT_._fields_ = [
    ('pChunkData', POINTER(c_ubyte)),  # < \~chinese 块数据             \~english Chunk data
    ('nChunkID', c_uint),              # < \~chinese 块数据ID           \~english Chunk id
    ('nChunkLen', c_uint),             # < \~chinese 块数据长度         \~english Chunk len
    ('nReserved', c_uint * 8),         # < \~chinese 保留字节           \~english Reserved bytes
]
MV_CHUNK_DATA_CONTENT = _MV_CHUNK_DATA_CONTENT_

# 输出帧的信息    \~english Output Frame Information
class _MV_FRAME_OUT_INFO_EX_(Structure):
    pass
# values for enumeration 'MvGvspPixelType'
MvGvspPixelType = c_int # enum

class N22_MV_FRAME_OUT_INFO_EX_3DOT_1E(Union):
    pass
N22_MV_FRAME_OUT_INFO_EX_3DOT_1E._fields_ = [
    ('pUnparsedChunkContent', POINTER(MV_CHUNK_DATA_CONTENT)), # < \~chinese Chunk内容         \~english Chunk Content
    ('nAligning', int64_t),                                    # < \~chinese 校准字段          \~english Aligning
]
_MV_FRAME_OUT_INFO_EX_._fields_ = [
    ('nWidth', c_ushort),
    # < \~chinese 图像宽(最大65535，超出请用nExtendWidth)    \~english Image Width (over 65535, use nExtendWidth)
    ('nHeight', c_ushort),
    # < \~chinese 图像高(最大65535，超出请用nExtendHeight)   \~english Image Height(over 65535, use nExtendHeight)
    ('enPixelType', MvGvspPixelType),                        # < \~chinese 像素格式           \~english Pixel Type
    ('nFrameNum', c_uint),                                   # < \~chinese 帧号               \~english Frame Number
    ('nDevTimeStampHigh', c_uint),                           # < \~chinese 时间戳高32位       \~english Timestamp high 32 bits
    ('nDevTimeStampLow', c_uint),                            # < \~chinese 时间戳低32位       \~english Timestamp low 32 bits
    ('nReserved0', c_uint),                                  # < \~chinese 保留，8字节对齐     \~english Reserved, 8-byte aligned
    ('nHostTimeStamp', int64_t),                             # < \~chinese 主机生成的时间戳    \~english Host-generated timestamp
    ('nFrameLen', c_uint),                                   # < \~chinese 帧的长度           \~english Frame length
    # < \~chinese 以下为chunk新增水印信息 \~english The followings are chunk add frame-specific information
    # < \~chinese 设备水印时标 \~english Device frame-specific time scale
    ('nSecondCount', c_uint),                                # < \~chinese 秒数               \~english The Seconds                         
    ('nCycleCount', c_uint),                                 # < \~chinese 周期数             \~english The Count of Cycle                
    ('nCycleOffset', c_uint),                                # < \~chinese 周期偏移量         \~english The Offset of Cycle                  
    ('fGain', c_float),                                      # < \~chinese 增益               \~english Gain
    ('fExposureTime', c_float),                              # < \~chinese 曝光时间           \~english Exposure Time
    ('nAverageBrightness', c_uint),                          # < \~chinese 平均亮度           \~english Average brightness
    # < \~chinese:白平衡相关 \~english White balance
    ('nRed', c_uint),                                        # < \~chinese 红色               \~english Red     
    ('nGreen', c_uint),                                      # < \~chinese 绿色               \~english Green
    ('nBlue', c_uint),                                       # < \~chinese 蓝色               \~english Blue
    ('nFrameCounter', c_uint),                               # < \~chinese 帧计数             \~english Frame counter
    ('nTriggerIndex', c_uint),                               # < \~chinese 触发计数           \~english Trigger index
    # < \~chinese  输入/输出 \~english Line Input/Output
    ('nInput', c_uint),                                      # < \~chinese 输入               \~english input
    ('nOutput', c_uint),                                     # < \~chinese 输出               \~english output
    # < \~chinese ROI区域 \~english ROI Region                       
    ('nOffsetX', c_ushort),                                  # < \~chinese 水平偏移量             \~english OffsetX   
    ('nOffsetY', c_ushort),                                  # < \~chinese 垂直偏移量             \~english OffsetY
    ('nChunkWidth', c_ushort),                               # < \~chinese chunk 宽              \~english The Width of Chunk
    ('nChunkHeight', c_ushort),                              # < \~chinese chunk 高               \~english The Height of Chunk
    ('nLostPacket', c_uint),                                 # < \~chinese 本帧丢包数            \~english Lost Pacekt Number In This Frame
    ('nUnparsedChunkNum', c_uint),                           # < \~chinese 未解析的Chunkdata个数 \~english Unparsed chunk number
    ('UnparsedChunkList', N22_MV_FRAME_OUT_INFO_EX_3DOT_1E), # < \~chinese 数据库链表            \~english Unparsed chunk list
    ('nExtendWidth', c_uint),                                # < \~chinese 图像宽(扩展变量)       \~english Image Width
    ('nExtendHeight', c_uint),                               # < \~chinese 图像高(扩展变量)       \~english Image Height
    ('nReserved', c_uint * 34),                              # < \~chinese 保留字节            \~english Reserved bytes
]
MV_FRAME_OUT_INFO_EX = _MV_FRAME_OUT_INFO_EX_

# \~chinese 显示帧信息   \~english Display frame information
class _MV_DISPLAY_FRAME_INFO_EX_(Structure):
    pass
_MV_DISPLAY_FRAME_INFO_EX_._fields_ = [
    ('nWidth', c_uint),                # < \~chinese 图像宽    \~english Image Width
    ('nHeight', c_uint),               # < \~chinese 图像高    \~english Image Height
    ('enPixelType', MvGvspPixelType),  # < \~chinese 像素格式            \~english Pixel Type
    ('pImageBuf', POINTER(c_ubyte)),   # < \~chinese 输入图像缓存         \~english Input image buffer
    ('nImageBufLen', c_uint),          # < \~chinese 输入图像长度         \~english Input image length
    ('enRenderMode', c_uint),          # < \~chinese 图像渲染方式 0-默认模式(Windows GDI/Linux OPENGL), 1-D3D模式(Windows有效)   \~english Render mode 0-Default Mode 1-D3D Mode
    ('nRes', c_uint * 3),              # < \~chinese 保留字节            \~english Reserved bytes
]
MV_DISPLAY_FRAME_INFO_EX = _MV_DISPLAY_FRAME_INFO_EX_

# 图像结构体，输出图像指针地址及图像信息    \~english Image Struct, output the pointer of Image and the information of the specific image
class _MV_FRAME_OUT_(Structure):
    pass
_MV_FRAME_OUT_._fields_ = [
    ('pBufAddr', POINTER(c_ubyte)),         # < \~chinese 图像指针地址         \~english pointer of image
    ('stFrameInfo', MV_FRAME_OUT_INFO_EX),  # < \~chinese 图像信息            \~english information of the specific image
    ('nRes', c_uint * 16),                  # < \~chinese 保留字节            \~english Reserved bytes
]
MV_FRAME_OUT = _MV_FRAME_OUT_

# values for enumeration '_MV_GRAB_STRATEGY_'
_MV_GRAB_STRATEGY_ = c_int # enum       
MV_GRAB_STRATEGY = _MV_GRAB_STRATEGY_   

# 网络传输的相关信息    \~english Network transmission information
class _MV_NETTRANS_INFO_(Structure):
    pass
_MV_NETTRANS_INFO_._fields_ = [
    ('nReceiveDataSize', int64_t),          # < \~chinese 已接收数据大小  [统计StartGrabbing和StopGrabbing之间的数据量]         \~english Received Data Size  [Calculate the Data Size between StartGrabbing and StopGrabbing]  
    ('nThrowFrameCount', c_int),            # < \~chinese 丢帧数量             \~english Throw frame number
    ('nNetRecvFrameCount', c_uint),         # < \~chinese 收到帧计数           \~english Receive Frame count
    ('nRequestResendPacketCount', int64_t), # < \~chinese 请求重发包数         \~english Request Resend Packet Count
    ('nResendPacketCount', int64_t),        # < \~chinese 重发包数            \~english Resend Packet Count
]
MV_NETTRANS_INFO = _MV_NETTRANS_INFO_

# 全匹配的一种信息结构体    \~english A fully matched information structure
class _MV_ALL_MATCH_INFO_(Structure):
    pass
_MV_ALL_MATCH_INFO_._fields_ = [
    ('nType', c_uint),              # < \~chinese 需要输出的信息类型                  \~english Information type need to output
    ('pInfo', c_void_p),            # < \~chinese 输出的信息缓存，由调用者分配         \~englishOutput information cache, which is allocated by the caller
    ('nInfoSize', c_uint),          # < \~chinese 信息缓存的大小                      \~english Information cache size
]
MV_ALL_MATCH_INFO = _MV_ALL_MATCH_INFO_

# 网络流量和丢包信息反馈结构体，对应类型为 MV_MATCH_TYPE_NET_DETECT    \~english Network traffic and packet loss feedback structure, the corresponding type is MV_MATCH_TYPE_NET_DETECT
class _MV_MATCH_INFO_NET_DETECT_(Structure):
    pass
_MV_MATCH_INFO_NET_DETECT_._fields_ = [
    ('nReceiveDataSize', int64_t),          # < \~chinese 已接收数据大小      \~english Received data size
    ('nLostPacketCount', int64_t),          # < \~chinese 丢失的包数量        \~english Number of packets lost
    ('nLostFrameCount', c_uint),            # < \~chinese 丢帧数量           \~english Number of frames lost
    ('nNetRecvFrameCount', c_uint),         # < \~chinese 收到帧计数           \~english Receive Frame count
    ('nRequestResendPacketCount', int64_t), # < \~chinese 请求重发包数         \~english Request Resend Packet Count
    ('nResendPacketCount', int64_t),        # < \~chinese 重发包数            \~english Resend Packet Count
]
MV_MATCH_INFO_NET_DETECT = _MV_MATCH_INFO_NET_DETECT_

# \~chinese host收到从u3v设备端的总字节数，对应类型为 MV_MATCH_TYPE_USB_DETECT    \~english The total number of bytes host received from the u3v device side, the corresponding type is MV_MATCH_TYPE_USB_DETECT
class _MV_MATCH_INFO_USB_DETECT_(Structure):
    pass
_MV_MATCH_INFO_USB_DETECT_._fields_ = [
    ('nReceiveDataSize', int64_t),   # < \~chinese 已接收数据大小      \~english Received data size
    ('nReceivedFrameCount', c_uint), # < \~chinese 已收到的帧数        \~english Number of frames received
    ('nErrorFrameCount', c_uint),    # < \~chinese 错误帧数            \~english Number of error frames
    ('nReserved', c_uint * 2),       # < \~chinese 保留字节            \~english Reserved bytes
]
MV_MATCH_INFO_USB_DETECT = _MV_MATCH_INFO_USB_DETECT_

# \~chinese 显示帧信息   \~english Display frame information
class _MV_DISPLAY_FRAME_INFO_(Structure):
    pass
_MV_DISPLAY_FRAME_INFO_._fields_ = [
    ('hWnd', c_void_p),               # < \~chinese 窗口句柄           \~english Windows handle
    ('pData', POINTER(c_ubyte)),      # < \~chinese 显示的数据         \~english Data Buffer
    ('nDataLen', c_uint),             # < \~chinese 数据长度           \~english Data Size
    ('nWidth', c_ushort),             # < \~chinese 图像宽             \~english Width
    ('nHeight', c_ushort),            # < \~chinese 图像高             \~english Height
    ('enPixelType', MvGvspPixelType), # < \~chinese 像素格式           \~english Pixel format
    ('enRenderMode', c_uint),         # < \~chinese 图像渲染方式 0-默认模式(Windows GDI/Linux OPENGL), 1-D3D模式(Windows有效)   \~english Render mode 0-Default Mode 1-D3D Mode
    ('nRes', c_uint * 3),             # < \~chinese 保留字节           \~english Reserved bytes
]
MV_DISPLAY_FRAME_INFO = _MV_DISPLAY_FRAME_INFO_

# values for enumeration 'MV_SAVE_POINT_CLOUD_FILE_TYPE'
MV_SAVE_POINT_CLOUD_FILE_TYPE = c_int # enum

# \~chinese 保存3D数据到缓存    \~english Save 3D data to buffer
class _MV_SAVE_POINT_CLOUD_PARAM_(Structure):
    pass
_MV_SAVE_POINT_CLOUD_PARAM_._fields_ = [
    ('nLinePntNum', c_uint),                                 # < \~chinese 每一行点的数量，即图像宽                                             \~english The number of points in each row,which is the width of the image
    ('nLineNum', c_uint),                                    # < \~chinese 行数，即图像高                                                       \~english The number of rows,which is the height of the image
    ('enSrcPixelType', MvGvspPixelType),                     # < \~chinese 输入数据的像素格式                                                    \~english The pixel format of the input data
    ('pSrcData', POINTER(c_ubyte)),                          # < \~chinese 输入数据缓存                                                          \~english Input data buffer
    ('nSrcDataLen', c_uint),                                 # < \~chinese 输入数据大小                                                           \~english Input data size
    ('pDstBuf', POINTER(c_ubyte)),                           # < \~chinese 输出像素数据缓存                                                        \~english Output pixel data buffer
    ('nDstBufSize', c_uint),                                 # < \~chinese 提供的输出缓冲区大小(nLinePntNum * nLineNum * (16*3 + 4) + 2048)         \~english Output buffer size provided (nLinePntNum * nLineNum * (16*3 + 4) + 2048) 
    ('nDstBufLen', c_uint),                                  # < \~chinese 输出像素数据缓存长度                                                     \~english Output pixel data buffer size
    ('enPointCloudFileType', MV_SAVE_POINT_CLOUD_FILE_TYPE), # < \~chinese 提供输出的点云文件类型                                                    \~english Output point data file type provided
    ('nReserved', c_uint * 8),                               # < \~chinese 保留字节                                                                 \~english Reserved bytes
]
MV_SAVE_POINT_CLOUD_PARAM = _MV_SAVE_POINT_CLOUD_PARAM_

# values for enumeration 'MV_SAVE_IAMGE_TYPE'
MV_SAVE_IAMGE_TYPE = c_int # enum

# \~chinese 图片保存参数    \~english Save Image Parameters
class _MV_SAVE_IMAGE_PARAM_T_EX_(Structure):
    pass
_MV_SAVE_IMAGE_PARAM_T_EX_._fields_ = [
    ('pData', POINTER(c_ubyte)),                            # < \~chinese 输入数据缓存         \~english Input Data Buffer
    ('nDataLen', c_uint),                                   # < \~chinese 输入数据大小         \~english Input Data Size
    ('enPixelType', MvGvspPixelType),                       # < \~chinese 输入数据的像素格式         \~english Input Data Pixel Format
    ('nWidth', c_ushort),                                   # < \~chinese 图像宽         \~english Image Width
    ('nHeight', c_ushort),                                  # < \~chinese 图像高         \~english Image Height
    ('pImageBuffer', POINTER(c_ubyte)),                     # < \~chinese 输出图片缓存         \~english Output Image Buffer
    ('nImageLen', c_uint),                                  # < \~chinese 输出图片大小         \~english Output Image Size
    ('nBufferSize', c_uint),                                # < \~chinese 提供的输出缓冲区大小         \~english Output buffer size provided
    ('enImageType', MV_SAVE_IAMGE_TYPE),                    # < \~chinese 输出图片格式         \~english Output Image Format
    ('nJpgQuality', c_uint),                                # < \~chinese 编码质量, (50-99]         \~english Encoding quality, (50-99]
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_uint),
    ('nReserved', c_uint * 3),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMAGE_PARAM_EX = _MV_SAVE_IMAGE_PARAM_T_EX_

class _MV_SAVE_IMAGE_PARAM_EX3_(Structure):
    pass
_MV_SAVE_IMAGE_PARAM_EX3_._fields_ = [
    ('pData', POINTER(c_ubyte)),                            # < \~chinese 输入数据缓存         \~english Input Data Buffer
    ('nDataLen', c_uint),                                   # < \~chinese 输入数据大小         \~english Input Data Size
    ('enPixelType', MvGvspPixelType),                       # < \~chinese 输入数据的像素格式         \~english Input Data Pixel Format
    ('nWidth', c_uint),                                   # < \~chinese 图像宽         \~english Image Width
    ('nHeight', c_uint),                                  # < \~chinese 图像高         \~english Image Height
    ('pImageBuffer', POINTER(c_ubyte)),                     # < \~chinese 输出图片缓存         \~english Output Image Buffer
    ('nImageLen', c_uint),                                  # < \~chinese 输出图片大小         \~english Output Image Size
    ('nBufferSize', c_uint),                                # < \~chinese 提供的输出缓冲区大小         \~english Output buffer size provided
    ('enImageType', MV_SAVE_IAMGE_TYPE),                    # < \~chinese 输出图片格式         \~english Output Image Format
    ('nJpgQuality', c_uint),                                # < \~chinese 编码质量, (50-99]         \~english Encoding quality, (50-99]
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_uint),
    ('nReserved', c_uint * 3),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMAGE_PARAM_EX3 = _MV_SAVE_IMAGE_PARAM_EX3_

# \~chinese 保存BMP、JPEG、PNG、TIFF图片文件的参数    \~english Save BMP、JPEG、PNG、TIFF image file parameters
class _MV_SAVE_IMG_TO_FILE_PARAM_(Structure):
    pass
_MV_SAVE_IMG_TO_FILE_PARAM_._fields_ = [
    ('enPixelType', MvGvspPixelType),    # < \~chinese 输入数据的像素格式                    \~english The pixel format of the input data
    ('pData', POINTER(c_ubyte)),         # < \~chinese 输入数据缓存                          \~english Input Data Buffer
    ('nDataLen', c_uint),                # < \~chinese 输入数据大小                           \~english Input Data Size
    ('nWidth', c_ushort),                # < \~chinese 图像宽                                  \~english Image Width
    ('nHeight', c_ushort),               # < \~chinese 图像高                                   \~english Image Height
    ('enImageType', MV_SAVE_IAMGE_TYPE), # < \~chinese 输入图片格式                               \~english Input Image Format
    ('nQuality', c_uint),                # < \~chinese JPG编码质量(50-99]         \~english JPG Encoding quality(50-99]
    ('pImagePath', c_char * 256),        # < \~chinese 输入文件路径         \~english Input file path
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_int),             
    ('nReserved', c_uint * 8),           # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMG_TO_FILE_PARAM = _MV_SAVE_IMG_TO_FILE_PARAM_

class _MV_SAVE_IMAGE_TO_FILE_PARAM_EX_(Structure):
    pass
_MV_SAVE_IMAGE_TO_FILE_PARAM_EX_._fields_ = [
    ('nWidth', c_uint),  # < \~chinese 图像宽                                  \~english Image Width
    ('nHeight', c_uint),  # < \~chinese 图像高                                 \~english Image Height
    # < \~chinese 输入数据的像素格式                    \~english The pixel format of the input data
    ('enPixelType', MvGvspPixelType),
    ('pData', POINTER(c_ubyte)),  # < \~chinese 输入数据缓存                          \~english Input Data Buffer
    ('nDataLen', c_uint),  # < \~chinese 输入数据大小                           \~english Input Data Size
    # < \~chinese 输入图片格式                               \~english Input Image Format
    ('enImageType', MV_SAVE_IAMGE_TYPE),
    ('pcImagePath', POINTER(c_char)),  # < \~chinese 输入文件路径         \~english Input file path
    ('nQuality', c_uint),      # < \~chinese JPG编码质量(50-99]，其他格式无效    \~english JPG Encoding quality(50-99]
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_int),
    ('nReserved', c_uint * 8),  # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMAGE_TO_FILE_PARAM_EX = _MV_SAVE_IMAGE_TO_FILE_PARAM_EX_

# \~chinese 图像转换结构体    \~english Pixel convert structure
class _MV_CC_PIXEL_CONVERT_PARAM_T_(Structure):
    pass
_MV_CC_PIXEL_CONVERT_PARAM_T_._fields_ = [
    ('nWidth', c_ushort),                # < \~chinese 图像宽             \~english Image Width
    ('nHeight', c_ushort),               # < \~chinese 图像高              \~english Image Height
    ('enSrcPixelType', MvGvspPixelType), # < \~chinese 源像素格式            \~english Source pixel format
    ('pSrcData', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),             # < \~chinese 输入数据大小            \~english Input data size
    ('enDstPixelType', MvGvspPixelType), # < \~chinese 目标像素格式             \~english Destination pixel format
    ('pDstBuffer', POINTER(c_ubyte)),    # < \~chinese 输出数据缓存              \~english Output data buffer
    ('nDstLen', c_uint),                 # < \~chinese 输出数据大小               \~english Output data size
    ('nDstBufferSize', c_uint),          # < \~chinese 提供的输出缓冲区大小         \~english Provided outbut buffer size
    ('nRes', c_uint * 4),                # < \~chinese 保留字节                     \~english Reserved bytes
]
MV_CC_PIXEL_CONVERT_PARAM = _MV_CC_PIXEL_CONVERT_PARAM_T_

class _MV_PIXEL_CONVERT_PARAM_EX_T_(Structure):
    pass
_MV_PIXEL_CONVERT_PARAM_EX_T_._fields_ = [
    ('nWidth', c_uint),                # < \~chinese 图像宽             \~english Image Width
    ('nHeight', c_uint),               # < \~chinese 图像高              \~english Image Height
    ('enSrcPixelType', MvGvspPixelType), # < \~chinese 源像素格式            \~english Source pixel format
    ('pSrcData', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),             # < \~chinese 输入数据大小            \~english Input data size
    ('enDstPixelType', MvGvspPixelType), # < \~chinese 目标像素格式             \~english Destination pixel format
    ('pDstBuffer', POINTER(c_ubyte)),    # < \~chinese 输出数据缓存              \~english Output data buffer
    ('nDstLen', c_uint),                 # < \~chinese 输出数据大小               \~english Output data size
    ('nDstBufferSize', c_uint),          # < \~chinese 提供的输出缓冲区大小         \~english Provided outbut buffer size
    ('nRes', c_uint * 4),                # < \~chinese 保留字节                     \~english Reserved bytes
]
MV_CC_PIXEL_CONVERT_PARAM_EX = _MV_PIXEL_CONVERT_PARAM_EX_T_

# values for enumeration '_MV_RECORD_FORMAT_TYPE_'
_MV_RECORD_FORMAT_TYPE_ = c_int # enum
MV_RECORD_FORMAT_TYPE = _MV_RECORD_FORMAT_TYPE_

# \~chinese 录像参数    \~english Record Parameters
class _MV_CC_RECORD_PARAM_T_(Structure):
    pass
_MV_CC_RECORD_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),           # < \~chinese 输入数据的像素格式                                \~english Ip config option
    ('nWidth', c_ushort),                       # < \~chinese 图像宽(指定目标参数时需为2的倍数)                   \~english Ip config option
    ('nHeight', c_ushort),                      # < \~chinese 图像高(指定目标参数时需为2的倍数)                    \~english Ip config option
    ('fFrameRate', c_float),                    # < \~chinese 帧率fps(1/16-120)                                  \~english Ip config option
    ('nBitRate', c_uint),                       # < \~chinese 码率kbps(128kbps-16Mbps)                            \~english Ip config option
    ('enRecordFmtType', MV_RECORD_FORMAT_TYPE), # < \~chinese 录像格式                                              \~english Ip config option
    ('strFilePath', STRING),                    # < \~chinese 录像文件存放路径(如果路径中存在中文，需转成utf-8)         \~english Video file storage path (if there is Chinese in the path, it needs to be converted to utf-8)
    ('nRes', c_uint * 8),                       # < \~chinese 保留字节                                                \~english Reserved bytes
]
MV_CC_RECORD_PARAM = _MV_CC_RECORD_PARAM_T_

# \~chinese 录像数据    \~english Record Data
class _MV_CC_INPUT_FRAME_INFO_T_(Structure):
    pass
_MV_CC_INPUT_FRAME_INFO_T_._fields_ = [
    ('pData', POINTER(c_ubyte)),  # < \~chinese 图像数据指针         \~english Input Data Buffer
    ('nDataLen', c_uint),         # < \~chinese  输入数据大小         \~english Input Data Size
    ('nRes', c_uint * 8),         # < \~chinese 保留字节               \~english Reserved bytes
]
MV_CC_INPUT_FRAME_INFO = _MV_CC_INPUT_FRAME_INFO_T_

# values for enumeration '_MV_CAM_ACQUISITION_MODE_'
_MV_CAM_ACQUISITION_MODE_ = c_int # enum
MV_CAM_ACQUISITION_MODE = _MV_CAM_ACQUISITION_MODE_

# values for enumeration '_MV_CAM_GAIN_MODE_'
_MV_CAM_GAIN_MODE_ = c_int # enum
MV_CAM_GAIN_MODE = _MV_CAM_GAIN_MODE_

# values for enumeration '_MV_CAM_EXPOSURE_MODE_'
_MV_CAM_EXPOSURE_MODE_ = c_int # enum
MV_CAM_EXPOSURE_MODE = _MV_CAM_EXPOSURE_MODE_

# values for enumeration '_MV_CAM_EXPOSURE_AUTO_MODE_'
_MV_CAM_EXPOSURE_AUTO_MODE_ = c_int # enum
MV_CAM_EXPOSURE_AUTO_MODE = _MV_CAM_EXPOSURE_AUTO_MODE_

# values for enumeration '_MV_CAM_TRIGGER_MODE_'
_MV_CAM_TRIGGER_MODE_ = c_int # enum
MV_CAM_TRIGGER_MODE = _MV_CAM_TRIGGER_MODE_

# values for enumeration '_MV_CAM_GAMMA_SELECTOR_'
_MV_CAM_GAMMA_SELECTOR_ = c_int # enum
MV_CAM_GAMMA_SELECTOR = _MV_CAM_GAMMA_SELECTOR_

# values for enumeration '_MV_CAM_BALANCEWHITE_AUTO_'
_MV_CAM_BALANCEWHITE_AUTO_ = c_int # enum
MV_CAM_BALANCEWHITE_AUTO = _MV_CAM_BALANCEWHITE_AUTO_

# values for enumeration '_MV_CAM_TRIGGER_SOURCE_'
_MV_CAM_TRIGGER_SOURCE_ = c_int # enum
MV_CAM_TRIGGER_SOURCE = _MV_CAM_TRIGGER_SOURCE_

# \~chinese Event事件回调信息\    \~english Event callback infomation
class _MV_EVENT_OUT_INFO_(Structure):
    pass
_MV_EVENT_OUT_INFO_._fields_ = [
    ('EventName', c_char * MAX_EVENT_NAME_SIZE), # < \~chinese Event名称       \~english Event name
    ('nEventID', c_ushort),                      # < \~chinese Event号          \~english Event ID
    ('nStreamChannel', c_ushort),                # < \~chinese 流通道序号         \~english Circulation number
    ('nBlockIdHigh', c_uint),                    # < \~chinese 帧号高位  (暂无固件支持)          \~english BlockId high, not support
    ('nBlockIdLow', c_uint),                     # < \~chinese 帧号低位  (暂无固件支持)           \~english BlockId low, not support
    ('nTimestampHigh', c_uint),                  # < \~chinese 时间戳高位            \~english Timestramp high
    ('nTimestampLow', c_uint),                   # < \~chinese 时间戳低位             \~english Timestramp low
    ('pEventData', c_void_p),                    # < \~chinese Event数据     (暂无固件支持)         \~english Event data, not support
    ('nEventDataSize', c_uint),                  # < \~chinese Event数据长度 (暂无固件支持)         \~english Event data len, not support
    ('nReserved', c_uint * 16),                  # < \~chinese 保留字节                 \~english Reserved bytes
]
MV_EVENT_OUT_INFO = _MV_EVENT_OUT_INFO_

# \~chinese 文件存取    \~english File Access
class _MV_CC_FILE_ACCESS_T(Structure):
    pass
_MV_CC_FILE_ACCESS_T._fields_ = [
    ('pUserFileName', STRING),  # < \~chinese 用户文件名         \~english User file name
    ('pDevFileName', STRING),   # < \~chinese 设备文件名          \~english Device file name
    ('nReserved', c_uint * 32), # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_FILE_ACCESS = _MV_CC_FILE_ACCESS_T

# \~chinese 文件存取进度    \~english File Access Progress
class _MV_CC_FILE_ACCESS_PROGRESS_T(Structure):
    pass
_MV_CC_FILE_ACCESS_PROGRESS_T._fields_ = [
    ('nCompleted', int64_t),     # < \~chinese 已完成的长度         \~english Completed Length
    ('nTotal', int64_t),         # < \~chinese 总长度               \~english Total Length
    ('nReserved', c_uint * 8),   # < \~chinese 保留字节              \~english Reserved bytes
]
MV_CC_FILE_ACCESS_PROGRESS = _MV_CC_FILE_ACCESS_PROGRESS_T

# values for enumeration '_MV_GIGE_TRANSMISSION_TYPE_'
_MV_GIGE_TRANSMISSION_TYPE_ = c_int # enum
MV_GIGE_TRANSMISSION_TYPE = _MV_GIGE_TRANSMISSION_TYPE_

# 传输模式，可以为单播模式、组播模式等    \~english Transmission type
class _MV_TRANSMISSION_TYPE_T(Structure):
    pass
_MV_TRANSMISSION_TYPE_T._fields_ = [
    ('enTransmissionType', MV_GIGE_TRANSMISSION_TYPE),  # < \~chinese 传输模式                      \~english Transmission type
    ('nDestIp', c_uint),                                # < \~chinese 目标IP，组播模式下有意义        \~english Destination IP
    ('nDestPort', c_ushort),                            # < \~chinese 目标Port，组播模式下有意义        \~english Destination port
    ('nReserved', c_uint * 32),                         # < \~chinese 保留字节                          \~english Reserved bytes
]
MV_TRANSMISSION_TYPE = _MV_TRANSMISSION_TYPE_T

# \~chinese 动作命令信息    \~english Action Command
class _MV_ACTION_CMD_INFO_T(Structure):
    pass
_MV_ACTION_CMD_INFO_T._fields_ = [
    ('nDeviceKey', c_uint),        # < \~chinese 设备密钥                                     \~english Device key
    ('nGroupKey', c_uint),         # < \~chinese 组键                                          \~english Group key
    ('nGroupMask', c_uint),        # < \~chinese 组掩码                                         \~english Group mask
    ('bActionTimeEnable', c_uint), # < \~chinese 只有设置成1时Action Time才有效，非1时无效         \~english Action time enable
    ('nActionTime', int64_t),      # < \~chinese 预定的时间，和主频有关                             \~english Action time
    ('pBroadcastAddress', STRING), # < \~chinese 广播包地址                                         \~english Broadcast address
    ('nTimeOut', c_uint),          # < \~chinese 等待ACK的超时时间，如果为0表示不需要ACK               \~english Timeout
    ('nReserved', c_uint * 16),    # < \~chinese 预留                                                 \~english Reserved bytes
]
MV_ACTION_CMD_INFO = _MV_ACTION_CMD_INFO_T

# \~chinese 动作命令返回信息    \~english Action Command Result
class _MV_ACTION_CMD_RESULT_T(Structure):
    pass
_MV_ACTION_CMD_RESULT_T._fields_ = [
    ('strDeviceAddress', c_ubyte * 16), # < \~chinese IP配置选项         \~english IP address of the device
    #1.0x0000:success.
    #2.0x8001:Command is not supported by the device.
    #3.0x8013:The device is not synchronized to a master clock to be used as time reference.
    #4.0x8015:A device queue or packet data has overflowed.
    #5.0x8016:The requested scheduled action command was requested at a time that is already past.
    ('nStatus', c_int),                 # < \~chinese 状态码            \~english status
    ('nReserved', c_uint * 4),          # < \~chinese 预留              \~english Reserved bytes
]
MV_ACTION_CMD_RESULT = _MV_ACTION_CMD_RESULT_T

# \~chinese 动作命令返回信息列表    \~english Action Command Result List
class _MV_ACTION_CMD_RESULT_LIST_T(Structure):
    pass
_MV_ACTION_CMD_RESULT_LIST_T._fields_ = [
    ('nNumResults', c_uint),                     # < \~chinese 返回值个数         \~english Num Results
    ('pResults', POINTER(MV_ACTION_CMD_RESULT)), # < \~chinese 动作命令返回信息        \~english action command result list
]
MV_ACTION_CMD_RESULT_LIST = _MV_ACTION_CMD_RESULT_LIST_T

# values for enumeration 'MV_XML_InterfaceType'
MV_XML_InterfaceType = c_int # enum

# values for enumeration 'MV_XML_AccessMode'
MV_XML_AccessMode = c_int # enum

# \~chinese 枚举类型值    \~english Enumeration Value
class _MVCC_ENUMVALUE_T(Structure):
    pass
_MVCC_ENUMVALUE_T._fields_ = [
    ('nCurValue', c_uint),                               # < \~chinese 当前值                \~english Current Value
    ('nSupportedNum', c_uint),                           # < \~chinese 数据的有效数据个数      \~english Number of valid data
    ('nSupportValue', c_uint * MV_MAX_XML_SYMBOLIC_NUM), # < \~chinese 支持值列表              \~english Support value list
    ('nReserved', c_uint * 4),                           # < \~chinese 预留                    \~english Reserved bytes
]
MVCC_ENUMVALUE = _MVCC_ENUMVALUE_T

# \~chinese Int类型值    \~english Int Value
class _MVCC_INTVALUE_T(Structure):
    pass
_MVCC_INTVALUE_T._fields_ = [
    ('nCurValue', c_uint),     # < \~chinese 当前值        \~english Current Value
    ('nMax', c_uint),          # < \~chinese 最大值         \~english Max Value
    ('nMin', c_uint),          # < \~chinese 最小值          \~english Min Value
    ('nInc', c_uint),          # < \~chinese 步径             \~english Step size
    ('nReserved', c_uint * 4), # < \~chinese 预留              \~english Reserved bytes
]
MVCC_INTVALUE = _MVCC_INTVALUE_T

# \~chinese Int类型值Ex    \~english Int Value Ex
class _MVCC_INTVALUE_EX_T(Structure):
    pass
_MVCC_INTVALUE_EX_T._fields_ = [
    ('nCurValue', int64_t),     # < \~chinese 当前值         \~english Current Value
    ('nMax', int64_t),          # < \~chinese 最大值          \~english Max Value
    ('nMin', int64_t),          # < \~chinese 最小值           \~english Min Value
    ('nInc', int64_t),          # < \~chinese 步径              \~english Step size
    ('nReserved', c_uint * 16), # < \~chinese 预留               \~english Reserved bytes
]
MVCC_INTVALUE_EX = _MVCC_INTVALUE_EX_T

# \~chinese Float类型值    \~english Float Value
class _MVCC_FLOATVALUE_T(Structure):
    pass
_MVCC_FLOATVALUE_T._fields_ = [
    ('fCurValue', c_float),    # < \~chinese 当前值         \~english Current Value
    ('fMax', c_float),         # < \~chinese 最大值          \~english Max Value
    ('fMin', c_float),         # < \~chinese 最小值           \~english Min Value
    ('nReserved', c_uint * 4), # < \~chinese 预留              \~english Reserved bytes
]
MVCC_FLOATVALUE = _MVCC_FLOATVALUE_T

# \~chinese String类型值    \~english String Value
class _MVCC_STRINGVALUE_T(Structure):
    pass
_MVCC_STRINGVALUE_T._fields_ = [
    ('chCurValue', c_char * 256), # < \~chinese 当前值         \~english Current Value
    ('nMaxLength', int64_t),      # < \~chinese 最大长度        \~english Max length
    ('nReserved', c_uint * 2),    # < \~chinese 预留            \~english Reserved bytes
]
MVCC_STRINGVALUE = _MVCC_STRINGVALUE_T

# \~chinese 水印信息     \~english  Frame-specific information
class _MV_CC_FRAME_SPEC_INFO_(Structure):
    pass
_MV_CC_FRAME_SPEC_INFO_._fields_ = [
    # < \~chinese 设备水印时标      \~english Device frame-specific time scale
    ('nSecondCount', c_uint),        # < \~chinese 秒数                  \~english The Seconds
    ('nCycleCount', c_uint),         # < \~chinese 周期数                 \~english The Count of Cycle
    ('nCycleOffset', c_uint),        # < \~chinese 周期偏移量              \~english The Offset of Cycle
    ('fGain', c_float),              # < \~chinese 增益                   \~english Gain
    ('fExposureTime', c_float),      # < \~chinese 曝光时间                \~english Exposure Time
    ('nAverageBrightness', c_uint),  # < \~chinese 平均亮度                \~english Average brightness
    # < \~chinese 白平衡相关        \~english White balance
    ('nRed', c_uint),    # < \~chinese 红色                   \~english Red
    ('nGreen', c_uint),  # < \~chinese 绿色                    \~english Green
    ('nBlue', c_uint),   # < \~chinese 蓝色                    \~english Blue
    ('nFrameCounter', c_uint),  # < \~chinese 总帧数           \~english Frame Counter
    ('nTriggerIndex', c_uint),  # < \~chinese 触发计数          \~english Trigger Counting
    ('nInput', c_uint),  # < \~chinese 输入                   \~english Input
    ('nOutput', c_uint), # < \~chinese 输出                   \~english Output
    # < \~chinese ROI区域           \~english ROI Region
    ('nOffsetX', c_ushort),      # < \~chinese 水平偏移量        \~english OffsetX
    ('nOffsetY', c_ushort),      # < \~chinese 垂直偏移量         \~english OffsetY
    ('nFrameWidth', c_ushort),   # < \~chinese 水印宽            \~english The Width of Chunk
    ('nFrameHeight', c_ushort),  # < \~chinese 水印高            \~english The Height of Chunk
    ('nReserved', c_uint * 16),   # < \~chinese 预留              \~english Reserved bytes
]
MV_CC_FRAME_SPEC_INFO = _MV_CC_FRAME_SPEC_INFO_

# \~chinese 无损解码参数              \~english High Bandwidth decode structure
class _MV_CC_HB_DECODE_PARAM_T_(Structure):
    pass
_MV_CC_HB_DECODE_PARAM_T_._fields_ = [
    ('pSrcBuf', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcLen', c_uint),                # < \~chinese 输入数据大小           \~english Input data size
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存           \~english Output data buffer
    ('nDstBufSize', c_uint),            # < \~chinese 提供的输出缓冲区大小     \~english Provided output buffer size
    ('nDstBufLen', c_uint),             # < \~chinese 输出数据大小            \~english Output data size
    ('enDstPixelType', MvGvspPixelType),  # < \~chinese 输出的像素格式        \~english Output pixel format
    ('stFrameInfo', MV_CC_FRAME_SPEC_INFO),  # < \~chinese 水印信息          \~english Frame Spec Info
    ('nRes', c_uint * 8),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_HB_DECODE_PARAM = _MV_CC_HB_DECODE_PARAM_T_

# values for enumeration '_MV_SORT_METHOD_'
_MV_SORT_METHOD_ = c_int  # enum
MV_SORT_METHOD = _MV_SORT_METHOD_

# values for enumeration '_MV_IMG_ROTATION_ANGLE_'
_MV_IMG_ROTATION_ANGLE_ = c_int  # enum
MV_IMG_ROTATION_ANGLE = _MV_IMG_ROTATION_ANGLE_

# values for enumeration '_MV_IMG_FLIP_TYPE_'
_MV_IMG_FLIP_TYPE_ = c_int  # enum
MV_IMG_FLIP_TYPE = _MV_IMG_FLIP_TYPE_

# values for enumeration '_MV_CC_GAMMA_TYPE_'
_MV_CC_GAMMA_TYPE_ = c_int  # enum
MV_CC_GAMMA_TYPE = _MV_CC_GAMMA_TYPE_

# values for enumeration '_MV_CC_STREAM_EXCEPTION_TYPE_'
_MV_CC_STREAM_EXCEPTION_TYPE_ = c_int  # enum
MV_CC_STREAM_EXCEPTION_TYPE = _MV_CC_STREAM_EXCEPTION_TYPE_

# values for enumeration '_MV_IMAGE_RECONSTRUCTION_METHOD_'
_MV_IMAGE_RECONSTRUCTION_METHOD_ = c_int  # enum
MV_IMAGE_RECONSTRUCTION_METHOD = _MV_IMAGE_RECONSTRUCTION_METHOD_

# \~chinese 图像旋转结构体            \~english Rotate image structure
class _MV_CC_ROTATE_IMAGE_PARAM_T_(Structure):
    pass
_MV_CC_ROTATE_IMAGE_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式              \~english pixel format
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('pSrcData', POINTER(c_ubyte)),     # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),            # < \~chinese 输入数据大小           \~english Input data length
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存           \~english Output data buffer
    ('nDstBufLen', c_uint),             # < \~chinese输出数据长度            \~english Output data length
    ('nDstBufSize', c_uint),            # < \~chinese  提供的输出缓冲区大小    \~english Provided output buffer size
    ('enRotationAngle', MV_IMG_ROTATION_ANGLE),   # < \~chinese  旋转角度               \~english Rotation angle
    ('nRes', c_uint * 8),               # < \~chinese 保留字节               \~english Reserved bytes
]
MV_CC_ROTATE_IMAGE_PARAM = _MV_CC_ROTATE_IMAGE_PARAM_T_

# \~chinese 图像翻转结构体            \~english Flip image structure
class _MV_CC_FLIP_IMAGE_PARAM_T_(Structure):
    pass
_MV_CC_FLIP_IMAGE_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式              \~english pixel format
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('pSrcData', POINTER(c_ubyte)),     # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),            # < \~chinese 输入数据大小           \~english Input data length
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存           \~english Output data buffer
    ('nDstBufLen', c_uint),             # < \~chinese输出数据长度            \~english Output data length
    ('nDstBufSize', c_uint),            # < \~chinese  提供的输出缓冲区大小    \~english Provided output buffer size
    ('enFlipType', MV_IMG_FLIP_TYPE),   # < \~chinese  翻转类型              \~english Flip type
    ('nRes', c_uint * 8),               # < \~chinese 保留字节               \~english Reserved bytes
]
MV_CC_FLIP_IMAGE_PARAM = _MV_CC_FLIP_IMAGE_PARAM_T_

# \~chinese Gamma信息结构体           \~english Gamma info structure
class _MV_CC_GAMMA_PARAM_T_(Structure):
    pass
_MV_CC_GAMMA_PARAM_T_._fields_ = [
    ('enGammaType', MV_CC_GAMMA_TYPE),       # < \~chinese Gamma类型              \~english Gamma type
    ('fGammaValue', c_float),                # < \~chinese Gamma值[0.1,4.0]       \~english Gamma value[0.1,4.0]
    ('pGammaCurveBuf', POINTER(c_ubyte)),    # < \~chinese Gamma曲线缓存          \~english Gamma curve buffer
    ('nGammaCurveBufLen', c_uint),           # < \~chinese Gamma曲线长度          \~english Gamma curve buffer size
    ('nRes', c_uint * 8),                    # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_GAMMA_PARAM = _MV_CC_GAMMA_PARAM_T_

# \~chinese CCM参数                   \~english CCM param
class _MV_CC_CCM_PARAM_T_(Structure):
    pass
_MV_CC_CCM_PARAM_T_._fields_ = [
    ('bCCMEnable', c_bool),         # < \~chinese 是否启用CCM            \~english CCM enable
    ('nCCMat', c_int * 9),          # < \~chinese CCM矩阵[-8192~8192]   \~english Color correction matrix[-8192~8192]
    ('nRes', c_uint * 8),           # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_CCM_PARAM = _MV_CC_CCM_PARAM_T_

# \~chinese CCM参数                   \~english CCM param
class _MV_CC_CCM_PARAM_EX_T_(Structure):
    pass
_MV_CC_CCM_PARAM_EX_T_._fields_ = [
    ('bCCMEnable', c_bool),         # < \~chinese 是否启用CCM            \~english CCM enable
    ('nCCMat', c_int * 9),          # < \~chinese CCM矩阵[-65536~65536]  \~english Color correction matrix[-65536~65536]
    ('nCCMScale', c_uint),          # < \~chinese 量化系数（2的整数幂,最大65536）    \~english Quantitative scale(Integer power of 2, <= 65536)
    ('nRes', c_uint * 8),           # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_CCM_PARAM_EX = _MV_CC_CCM_PARAM_EX_T_

# \~chinese 对比度调节结构体          \~english Contrast structure
class _MV_CC_CONTRAST_PARAM_T_(Structure):
    pass
_MV_CC_CONTRAST_PARAM_T_._fields_ = [
    ('nWidth', c_uint),                 # < \~chinese 图像宽(最小8)         \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高(最小8)         \~english Image Height
    ('pSrcBuf', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcBufLen', c_uint),             # < \~chinese 输入数据大小           \~english Input data length
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式               \~english pixel format
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存          \~english Output data buffer
    ('nDstBufSize', c_uint),            # < \~chinese提供的输出缓冲区大小     \~english Provided output buffer size
    ('nDstBufLen', c_uint),            # < \~chinese  输出数据长度           \~english Output data length
    ('nContrastFactor', c_uint),       # < \~chinese  对比度值，[1,10000]    \~english Contrast factor,[1,10000]
    ('nRes', c_uint * 8),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_CONTRAST_PARAM_T = _MV_CC_CONTRAST_PARAM_T_

# \~chinese 枚举类型条目          \~english Enumeration Entry
class _MVCC_ENUMENTRY_T(Structure):
    pass
_MVCC_ENUMENTRY_T._fields_ = [
    ('nValue', c_uint),                             # < \~chinese 指定值               \~english Value
    ('chSymbolic', c_char * MV_MAX_SYMBOLIC_LEN),  # < \~chinese 指定值对应的符号       \~english Symbolic

    ('nReserved', c_uint * 4),                      # < \~chinese 预留                 \~english Reserved bytes
]
MVCC_ENUMENTRY = _MVCC_ENUMENTRY_T

# \~chinese 辅助线颜色                \~english Color of Auxiliary Line
class _MVCC_COLORF(Structure):
    pass
_MVCC_COLORF._fields_ = [
    ('fR', c_float),
    # < \~chinese 红色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度   \~english Red，Range[0.0, 1.0]
    ('fG', c_float),
    # < \~chinese 绿色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度   \~english Green，Range[0.0, 1.0]
    ('fB', c_float),
    # < \~chinese 蓝色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度   \~english Blue，Range[0.0, 1.0]
    ('fAlpha', c_float),
    # < \~chinese 透明度，根据像素颜色的相对透明度，范围为[0.0 , 1.0] (此参数功能暂不支持)    \~english Alpha，Range[0.0, 1.0](Not Support)
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                            \~english Reserved bytes
]
MVCC_COLORF = _MVCC_COLORF

# \~chinese 自定义点                    \~english Point defined
class _MVCC_POINTF(Structure):
    pass
_MVCC_POINTF._fields_ = [
    ('fX', c_float),
    # < \~chinese 该点距离图像左边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Left，Range[0.0, 1.0]
    ('fY', c_float),
    # < \~chinese 该点距离图像上边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Top，Range[0.0, 1.0]
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                 \~english Reserved bytes
]
MVCC_POINTF = _MVCC_POINTF

# \~chinese 矩形框区域信息            \~english Rect Area Info
class _MVCC_RECT_INFO(Structure):
    pass
_MVCC_RECT_INFO._fields_ = [
    ('fTop', c_float),
    # < \~chinese 矩形上边缘距离图像上边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Top，Range[0, 1.0]
    ('fBottom', c_float),
    # < \~chinese 矩形下边缘距离图像下边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Bottom，Range[0, 1.0]
    ('fLeft', c_float),
    # < \~chinese 矩形左边缘距离图像左边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Left，Range[0, 1.0]
    ('fRight', c_float),
    # < \~chinese 矩形右边缘距离图像右边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Right，Range[0, 1.0]
    ('stColor', MVCC_COLORF),      # < \~chinese 辅助线颜色信息                \~english Color of Auxiliary Line
    ('nLineWidth', c_uint),        # < \~chinese 辅助线宽度，宽度只能是1或2      \~english Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                     \~english Reserved bytes
]
MVCC_RECT_INFO = _MVCC_RECT_INFO

# \~chinese 圆形框区域信息            \~english Circle Area Info
class _MVCC_CIRCLE_INFO(Structure):
    pass
_MVCC_CIRCLE_INFO._fields_ = [
    ('stCenterPoint', MVCC_POINTF),  # < \~chinese 圆心信息                   \~english Circle Point Info
    ('fR1', c_float),
    # < \~chinese 宽向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错  \~english Width Radius, Range[0, 1.0]
    ('fR2', c_float),
    # < \~chinese高向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错  \~english Height Radius, Range[0, 1.0]
    ('stColor', MVCC_COLORF),      # < \~chinese 辅助线颜色信息                \~english Color of Auxiliary Line
    ('nLineWidth', c_uint),        # < \~chinese 辅助线宽度，宽度只能是1或2      \~english Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                     \~english Reserved bytes
]
MVCC_CIRCLE_INFO = _MVCC_CIRCLE_INFO

# \~chinese 线条辅助线信息    \~english Linear Auxiliary Line Info
class _MVCC_LINES_INFO(Structure):
    pass
_MVCC_LINES_INFO._fields_ = [
    ('stStartPoint', MVCC_POINTF), # < \~chinese 线条辅助线的起始点坐标         \~english The Start Point of Auxiliary Line
    ('stEndPoint', MVCC_POINTF),   # < \~chinese线条辅助线的终点坐标            \~english The End Point of Auxiliary Line
    ('stColor', MVCC_COLORF),      # < \~chinese 辅助线颜色信息                \~english Color of Auxiliary Line
    ('nLineWidth', c_uint),        # < \~chinese 辅助线宽度，宽度只能是1或2      \~english Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节             \~english Reserved bytes
]
MVCC_LINES_INFO = _MVCC_LINES_INFO

# \~chinese 图像重构后的图像列表      \~english List of images after image reconstruction
class _MV_OUTPUT_IMAGE_INFO_(Structure):
    pass
_MV_OUTPUT_IMAGE_INFO_._fields_ = [
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式               \~english pixel format
    ('pBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存          \~english Output data buffer
    ('nBufLen', c_uint),             # < \~chinese 输出数据长度          \~english Output data length
    ('nBufSize', c_uint),            # < \~chinese  提供的输出缓冲区大小  \~english Provided output buffer size
    ('nRes', c_uint * 8),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_OUTPUT_IMAGE_INFO = _MV_OUTPUT_IMAGE_INFO_

# \~chinese 重构图像参数信息      \~english Restructure image parameters
class _MV_RECONSTRUCT_IMAGE_PARAM_(Structure):
    pass
_MV_RECONSTRUCT_IMAGE_PARAM_._fields_ = [
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式               \~english pixel format
    ('pSrcData', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english input data buffer
    ('nSrcDataLen', c_uint),             # < \~chinese 输入数据大小            \~english input data size
    ('nExposureNum', c_uint),            # < \~chinese  曝光个数(1-8]     \~english Exposure number
    ('enReconstructMethod', MV_IMAGE_RECONSTRUCTION_METHOD),   # < \~chinese 图像重构方式      \~english Image restructuring method
    ('stDstBufList', MV_OUTPUT_IMAGE_INFO * MV_MAX_SPLIT_NUM),  # < \~chinese 输出数据缓存信息  \~english Output data info
    ('nRes', c_uint * 4),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_RECONSTRUCT_IMAGE_PARAM = _MV_RECONSTRUCT_IMAGE_PARAM_

# \~chinese 文件存取                  \~english File Access
class _MV_CC_FILE_ACCESS_E(Structure):
    pass
_MV_CC_FILE_ACCESS_E._fields_ = [
    ('pUserFileBuf', POINTER(c_char)),  # < \~chinese 用户文件数据        \~english User file data
    ('pFileBufSize', c_uint),  # < \~chinese 用户数据缓存大小       \~english data buffer size
    ('pFileBufLen', c_uint),   # < \~chinese 用户数据缓存长度       \~english data buffer len
    ('pDevFileName', STRING),           # < \~chinese 设备文件名          \~english Device file name
    ('nReserved', c_uint * 32),         # < \~chinese 保留字节            \~english Reserved bytes
]
MV_CC_FILE_ACCESS_EX = _MV_CC_FILE_ACCESS_E

# 采集卡信息            \~english Interface information
class _MV_INTERFACE_INFO_(Structure):
    pass
_MV_INTERFACE_INFO_._fields_ = [
    ('nTLayerType', c_uint),               # < \~chinese 采集卡类型    \~english Interface type
    ('nPCIEInfo', c_uint),                 # < \~chinese 采集卡的PCIE插槽信息  \~english PCIe slot information of interface
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 采集卡ID    \~english Interface ID
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 显示名称    \~english Display name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 序列号      \~english Serial number
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号        \~english model name
    ('chManufacturer', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 厂商        \~english manufacturer name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 版本号      \~english device version
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 自定义名称 \~english user defined name
    ('nReserved', c_uint * 64),                             # < \~chinese 保留字节   \~english Reserved bytes
]
MV_INTERFACE_INFO = _MV_INTERFACE_INFO_

# 采集卡信息列表           \~english Interface Information List
class _MV_INTERFACE_INFO_LIST_(Structure):
    pass
_MV_INTERFACE_INFO_LIST_._fields_ = [
    ('nInterfaceNum', c_uint),                                          # < \~chinese 在线设备数量         \~english Online Device Number
    ('pInterfaceInfos', POINTER(MV_INTERFACE_INFO) * MV_MAX_INTERFACE_NUM), # < \~chinese 支持最多256个设备    \~english Support up to 256 devices
]
MV_INTERFACE_INFO_LIST = _MV_INTERFACE_INFO_LIST_

# 串口信息      \~english Serial Port Info
class _MV_CAML_SERIAL_PORT_(Structure):
    pass
_MV_CAML_SERIAL_PORT_._fields_ = [
    ('chSerialPort', c_char * INFO_MAX_BUFFER_SIZE),   # < \~chinese 串口号          \~english Serial Port
    ('nRes', c_uint * 4),                              # < \~chinese 保留字节        \~english Reserved bytes
]
MV_CAML_SERIAL_PORT = _MV_CAML_SERIAL_PORT_

# 本机串口列表            \~english serial port list
class _MV_CAML_SERIAL_PORT_LIST_(Structure):
    pass
_MV_CAML_SERIAL_PORT_LIST_._fields_ = [
    ('nSerialPortNum', c_uint),                                      # < \~chinese 串口数量   \~english Serial Port Num
    ('stSerialPort', MV_CAML_SERIAL_PORT * MV_MAX_SERIAL_PORT_NUM),  # < \~chinese 串口信息   \~english Serial Port Information
    ('nRes', c_uint * 4),  # < \~chinese 保留字节   \~english Reserved bytes
]
MV_CAML_SERIAL_PORT_LIST = _MV_CAML_SERIAL_PORT_LIST_

__all__ = ['_MV_ALL_MATCH_INFO_', 'MV_CC_FILE_ACCESS_PROGRESS',
           'N19_MV_CC_DEVICE_INFO_3DOT_0E', 'MV_FRAME_OUT',
           'MV_CAM_GAIN_MODE',
           'MV_ALL_MATCH_INFO',
           'MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV',
           'MV_TRIGGER_SOURCE_LINE0', 'MV_PointCloudFile_Undefined',
           'MV_TRIGGER_SOURCE_LINE2', 'MV_TRIGGER_SOURCE_LINE3',
           'AM_CycleDetect',
           'MV_GrabStrategy_UpcomingImage', 'IFT_IFloat',
           'MV_EVENT_OUT_INFO', 'MV_TRANSMISSION_TYPE',
           'uint_fast16_t', 'MV_CHUNK_DATA_CONTENT','MV_ACTION_CMD_RESULT',
           'MV_CC_INPUT_FRAME_INFO',
           '_MV_ACTION_CMD_RESULT_T',
           'AM_RO', 'IFT_IPort', 'uint_least16_t',
           '_MV_FRAME_OUT_INFO_EX_', '_MV_TRANSMISSION_TYPE_T',
           'MV_SAVE_IMAGE_PARAM_EX', 'MV_SAVE_IMAGE_PARAM_EX3', 'AM_RW', 'MV_XML_InterfaceType',
           'int32_t', '_MV_ACTION_CMD_INFO_T', 'intptr_t',
           'uint_least64_t', '_MV_NETTRANS_INFO_',
           '_MV_CAM_TRIGGER_MODE_', 'int_least32_t',
           'MV_GIGE_TRANSTYPE_SUBNETBROADCAST',
           'MV_SAVE_POINT_CLOUD_FILE_TYPE',
           'MV_ACTION_CMD_RESULT_LIST',
           'MV_BALANCEWHITE_AUTO_CONTINUOUS',
           '_MV_CHUNK_DATA_CONTENT_', 'MV_FormatType_AVI',
           '_MV_CC_PIXEL_CONVERT_PARAM_T_','_MV_PIXEL_CONVERT_PARAM_EX_T_',
           'MV_GENTL_IF_INFO',
           'MV_ACQ_MODE_SINGLE',
           'MV_TRIGGER_MODE_ON',
           'int_least16_t', 'N22_MV_FRAME_OUT_INFO_EX_3DOT_1E',
           'MV_GIGE_TRANSTYPE_LIMITEDBROADCAST', 'int_fast32_t',
           '_MV_CAM_GAIN_MODE_',
           'MV_RECORD_FORMAT_TYPE', 'MV_CC_DEVICE_INFO',
           'IFT_ICommand', '_MV_RECORD_FORMAT_TYPE_',
           '_MV_CAM_ACQUISITION_MODE_',
           '_MVCC_STRINGVALUE_T',
           'MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV',
           '_MV_MATCH_INFO_NET_DETECT_', 'MVCC_INTVALUE',
           'MV_PointCloudFile_OBJ', '_MV_GIGE_TRANSMISSION_TYPE_',
           '_MV_CC_RECORD_PARAM_T_',
           '_MV_GENTL_IF_INFO_', 'MV_EXPOSURE_MODE_TIMED', 'intmax_t',
           'int16_t',
           'MV_DISPLAY_FRAME_INFO', '_MV_CC_FILE_ACCESS_PROGRESS_T',
           '_MV_GRAB_STRATEGY_', '_MV_SAVE_IMG_TO_FILE_PARAM_', '_MV_SAVE_IMAGE_TO_FILE_PARAM_EX_',
           'int_fast64_t',
           'MV_XML_AccessMode',
           'MV_GAIN_MODE_ONCE', 'IFT_IInteger',
           'MV_CAM_BALANCEWHITE_AUTO', 'int_least8_t',
           'MV_PointCloudFile_CSV', 'IFT_IBase',
           'MV_TRIGGER_MODE_OFF', 'MV_Image_Bmp',
           '_MV_GENTL_DEV_INFO_', 'MV_CC_FILE_ACCESS',
           '_MV_CAM_EXPOSURE_AUTO_MODE_',
           'uint_least8_t',
           'MV_ACTION_CMD_INFO',
           '_MV_CC_INPUT_FRAME_INFO_T_',
           'MV_GENTL_DEV_INFO_LIST', '_MV_CAM_TRIGGER_SOURCE_',
           'MV_GRAB_STRATEGY',
           'IFT_IEnumeration', 'uint64_t', 'uint8_t',
           '_MV_GENTL_DEV_INFO_LIST_',
           'MV_CAM_GAMMA_SELECTOR',
           'MV_CamL_DEV_INFO', 'MV_GENTL_IF_INFO_LIST',
           'MV_CAM_TRIGGER_MODE', 'MV_GIGE_TRANSTYPE_MULTICAST',
           'uint16_t', 'uint_fast8_t',
           '_MV_ACTION_CMD_RESULT_LIST_T',
           '_MV_MATCH_INFO_USB_DETECT_',
           '_MVCC_ENUMVALUE_T',
           'MV_SAVE_POINT_CLOUD_PARAM', '_MV_CC_DEVICE_INFO_',
           'IFT_IBoolean',
           'MV_MATCH_INFO_USB_DETECT', 'MV_PointCloudFile_PLY',
           'MVCC_ENUMVALUE',
           'IFT_IString',
           'MV_ACQ_MODE_CONTINUOUS',
           'MV_TRIGGER_SOURCE_FrequencyConverter',
           'MV_TRIGGER_SOURCE_COUNTER0',
           'MV_GAIN_MODE_OFF', '_MV_CC_DEVICE_INFO_LIST_',
           'MV_GIGE_DEVICE_INFO', '_MV_SAVE_IMAGE_PARAM_T_EX_', '_MV_SAVE_IMAGE_PARAM_EX3_',
           'AM_NA', 'uint_least32_t',
           'MV_CC_PIXEL_CONVERT_PARAM', 'MV_CC_PIXEL_CONVERT_PARAM_EX','AM_NI',
           '_MVCC_INTVALUE_EX_T', 'uintptr_t', 'MV_Image_Tif',
           'MVCC_FLOATVALUE', 'MV_GIGE_TRANSTYPE_CAMERADEFINED',
           '_MV_GENTL_IF_INFO_LIST_', 'MV_NETTRANS_INFO',
           'IFT_IRegister', 'MV_GIGE_TRANSMISSION_TYPE',
           'MV_EXPOSURE_AUTO_MODE_ONCE', 'MV_GIGE_TRANSTYPE_UNICAST',
           'int8_t', '_MV_GIGE_DEVICE_INFO_', 'IFT_IValue', 'AM_WO',
           'int_fast8_t',
           'MV_GAMMA_SELECTOR_SRGB','int_least64_t',
           'MV_GrabStrategy_LatestImagesOnly',
           'MV_EXPOSURE_AUTO_MODE_OFF', 'MV_CAM_EXPOSURE_AUTO_MODE',
           'MV_EXPOSURE_AUTO_MODE_CONTINUOUS',
           'MV_CAM_ACQUISITION_MODE', 'AM_Undefined',
           'MV_MATCH_INFO_NET_DETECT',
           '_MV_CC_FILE_ACCESS_T',
           '_MV_DISPLAY_FRAME_INFO_','MV_GrabStrategy_OneByOne',
           'MV_TRIGGER_SOURCE_SOFTWARE', 'MV_FormatType_Undefined',
           'MV_BALANCEWHITE_AUTO_ONCE',
           'uintmax_t', 'int_fast16_t',
           '_MV_CAM_EXPOSURE_MODE_','MV_BALANCEWHITE_AUTO_OFF',
           'int64_t', 'MV_Image_Undefined', 'MV_GAIN_MODE_CONTINUOUS',
           'uint_fast32_t',
           'MV_CAM_TRIGGER_SOURCE', 'MV_GrabStrategy_LatestImages',
           'MV_Image_Png',
           'MV_Image_Jpeg', '_MV_CamL_DEV_INFO_',
           '_MVCC_FLOATVALUE_T',
           'MV_FRAME_OUT_INFO_EX', '_MV_SAVE_POINT_CLOUD_PARAM_',
           '_MV_CAM_BALANCEWHITE_AUTO_', 'MV_CC_RECORD_PARAM',
           '_MV_USB3_DEVICE_INFO_',
           'MVCC_INTVALUE_EX', 'MV_EXPOSURE_MODE_TRIGGER_WIDTH',
           'MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT',
           'MV_SAVE_IAMGE_TYPE','MV_GENTL_DEV_INFO',
           'MV_CAM_EXPOSURE_MODE',
           'MVCC_STRINGVALUE',
           'MvGvspPixelType',
           'MV_CC_DEVICE_INFO_LIST',
           'MV_TRIGGER_SOURCE_LINE1',
           'uint_fast64_t','_MVCC_INTVALUE_T',
           'IFT_ICategory',
           'MV_SAVE_IMG_TO_FILE_PARAM', 'MV_SAVE_IMAGE_TO_FILE_PARAM_EX', '_MV_FRAME_OUT_',
           'MV_GAMMA_SELECTOR_USER',
           'uint32_t', '_MV_CAM_GAMMA_SELECTOR_', 'MV_ACQ_MODE_MUTLI',
           'MV_USB3_DEVICE_INFO', '_MV_EVENT_OUT_INFO_', 'MV_CC_FRAME_SPEC_INFO', 'MV_CC_HB_DECODE_PARAM',
           'MV_SORT_METHOD', '_MV_SORT_METHOD_',
           'SortMethod_SerialNumber', 'SortMethod_UserID', 'SortMethod_CurrentIP_ASC', 'SortMethod_CurrentIP_DESC',
           '_MV_IMG_ROTATION_ANGLE_', 'MV_IMG_ROTATION_ANGLE',
           'MV_IMAGE_ROTATE_90', 'MV_IMAGE_ROTATE_180', 'MV_IMAGE_ROTATE_270',
           '_MV_IMG_FLIP_TYPE_', 'MV_IMG_FLIP_TYPE', 'MV_FLIP_VERTICAL', 'MV_FLIP_HORIZONTAL',
           '_MV_CC_GAMMA_TYPE_', 'MV_CC_GAMMA_TYPE', 'MV_CC_GAMMA_TYPE_NONE', 'MV_CC_GAMMA_TYPE_VALUE',
           'MV_CC_GAMMA_TYPE_USER_CURVE', 'MV_CC_GAMMA_TYPE_LRGB2SRGB', 'MV_CC_GAMMA_TYPE_SRGB2LRGB',
           'MV_CC_STREAM_EXCEPTION_TYPE', '_MV_CC_STREAM_EXCEPTION_TYPE_',
           'MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE', 'MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW',
           'MV_CC_STREAM_EXCEPTION_LIST_EMPTY', 'MV_CC_STREAM_EXCEPTION_RECONNECTION',
           'MV_CC_STREAM_EXCEPTION_DISCONNECTED', 'MV_CC_STREAM_EXCEPTION_DEVICE',
           '_MV_IMAGE_RECONSTRUCTION_METHOD_', 'MV_IMAGE_RECONSTRUCTION_METHOD', 'MV_SPLIT_BY_LINE',
           'MVCC_COLORF', '_MVCC_COLORF', '_MVCC_POINTF', 'MVCC_POINTF', '_MVCC_RECT_INFO', 'MVCC_RECT_INFO',
           '_MVCC_CIRCLE_INFO', 'MVCC_CIRCLE_INFO', '_MVCC_LINES_INFO', 'MVCC_LINES_INFO', '_MV_OUTPUT_IMAGE_INFO_',
           'MV_OUTPUT_IMAGE_INFO', 'MV_RECONSTRUCT_IMAGE_PARAM', '_MV_RECONSTRUCT_IMAGE_PARAM_',
           '_MVCC_ENUMENTRY_T', 'MVCC_ENUMENTRY','_MV_CC_CONTRAST_PARAM_T_', 'MV_CC_CONTRAST_PARAM_T',
           '_MV_CC_CCM_PARAM_EX_T_', 'MV_CC_CCM_PARAM_EX', 'MV_CC_CCM_PARAM', '_MV_CC_CCM_PARAM_T_',
           'MV_CC_GAMMA_PARAM', '_MV_CC_GAMMA_PARAM_T_', 'MV_CC_FLIP_IMAGE_PARAM', '_MV_CC_FLIP_IMAGE_PARAM_T_',
           '_MV_CC_ROTATE_IMAGE_PARAM_T_', 'MV_CC_ROTATE_IMAGE_PARAM', 'MV_CC_FILE_ACCESS_EX', '_MV_CC_FILE_ACCESS_E',
           '_MV_DISPLAY_FRAME_INFO_EX_', 'MV_DISPLAY_FRAME_INFO_EX', 'MV_CML_DEVICE_INFO', '_MV_CML_DEVICE_INFO_',
           'MV_CXP_DEVICE_INFO', '_MV_CXP_DEVICE_INFO_', '_MV_XOF_DEVICE_INFO_', 'MV_XOF_DEVICE_INFO',
           '_MV_INTERFACE_INFO_LIST_', 'MV_INTERFACE_INFO_LIST', '_MV_INTERFACE_INFO_', 'MV_INTERFACE_INFO',
           '_MV_CAML_SERIAL_PORT_LIST_', 'MV_CAML_SERIAL_PORT_LIST', '_MV_CAML_SERIAL_PORT_', 'MV_CAML_SERIAL_PORT']


===== .//MvImport/MvCameraControl_class.py =====
# -- coding: utf-8 --

import sys
import copy
import ctypes

from ctypes import *

from PixelType_header import *
from CameraParams_const import *
from CameraParams_header import *
from MvErrorDefine_const import *

# Python3.8版本修改Dll加载策略, 默认不再搜索Path环境变量, 同时增加winmode参数以兼容旧版本
dllname = "MvCameraControl.dll"
if "winmode" in ctypes.WinDLL.__init__.__code__.co_varnames:
    MvCamCtrldll = WinDLL(dllname, winmode=0)
else:
    MvCamCtrldll = WinDLL(dllname)


# 用于回调函数传入相机实例
class _MV_PY_OBJECT_(Structure):
    pass


_MV_PY_OBJECT_._fields_ = [
    ('PyObject', py_object),
]
MV_PY_OBJECT = _MV_PY_OBJECT_


class MvCamera():

    def __init__(self):
        self._handle = c_void_p()  # 记录当前连接设备的句柄
        self.handle = pointer(self._handle)  # 创建句柄指针

    '''
    Part1 ch: 相机的控制和取流接口 | en: Camera control and streaming
    '''

    # ch:初始化SDK | en: Initialize SDK
    @staticmethod
    def MV_CC_Initialize():
        MvCamCtrldll.MV_CC_Initialize.restype = c_int
        # C原型：int __stdcall MV_CC_Initialize();
        return MvCamCtrldll.MV_CC_Initialize()

    # ch:反初始化SDK | en: Finalize SDK
    @staticmethod
    def MV_CC_Finalize():
        MvCamCtrldll.MV_CC_Finalize.restype = c_int
        # C原型：int __stdcall MV_CC_Finalize();
        return MvCamCtrldll.MV_CC_Finalize()

    # ch:获取SDK版本号 | en:Get SDK Version
    @staticmethod
    def MV_CC_GetSDKVersion():
        MvCamCtrldll.MV_CC_GetSDKVersion.restype = c_uint
        # C原型：unsigned int __stdcall MV_CC_GetSDKVersion();
        return MvCamCtrldll.MV_CC_GetSDKVersion()

    # ch:获取支持的传输层 | en:Get supported Transport Layer
    @staticmethod
    def MV_CC_EnumerateTls():
        MvCamCtrldll.MV_CC_EnumerateTls.restype = c_uint
        # C原型：int __stdcall MV_CC_EnumerateTls();
        return MvCamCtrldll.MV_CC_EnumerateTls()

    # ch:枚举设备 | en:Enumerate Device
    @staticmethod
    def MV_CC_EnumDevices(nTLayerType, stDevList):
        MvCamCtrldll.MV_CC_EnumDevices.argtype = (c_uint, c_void_p)
        MvCamCtrldll.MV_CC_EnumDevices.restype = c_uint
        # C原型:int __stdcall MV_CC_EnumDevices(unsigned int nTLayerType, MV_CC_DEVICE_INFO_LIST* pstDevList)
        return MvCamCtrldll.MV_CC_EnumDevices(c_uint(nTLayerType), byref(stDevList))

    # ch:根据厂商名字枚举设备 | en:Enumerate device according to manufacture name
    @staticmethod
    def MV_CC_EnumDevicesEx(nTLayerType, stDevList, strManufacturerName):
        MvCamCtrldll.MV_CC_EnumDevicesEx.argtype = (c_uint, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EnumDevicesEx.restype = c_uint
        # C原型:int __stdcall MV_CC_EnumDevicesEx(IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST* pstDevList,
        #                                         IN const char* strManufacturerName);
        return MvCamCtrldll.MV_CC_EnumDevicesEx(c_uint(nTLayerType), byref(stDevList),
                                                strManufacturerName.encode('ascii'))

    # ch:枚举设备扩展（可指定排序方式枚举、根据厂商名字过滤） | en: Enumerate device according to the specified ordering
    @staticmethod
    def MV_CC_EnumDevicesEx2(nTLayerType, stDevList, strManufacturerName, enSortMethod):
        MvCamCtrldll.MV_CC_EnumDevicesEx2.argtype = (c_uint, c_void_p, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_EnumDevicesEx2.restype = c_uint
        # C原型:int __stdcall MV_CC_EnumDevicesEx2(IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST* pstDevList,
        #                                          IN const char* strManufacturerName, IN MV_SORT_METHOD enSortMethod);
        return MvCamCtrldll.MV_CC_EnumDevicesEx2(c_uint(nTLayerType), byref(stDevList),
                                                 strManufacturerName.encode('ascii'), c_uint(enSortMethod))

    # ch:设备是否可达 | en:Is the device accessible
    @staticmethod
    def MV_CC_IsDeviceAccessible(stDevInfo, nAccessMode):
        MvCamCtrldll.MV_CC_IsDeviceAccessible.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_IsDeviceAccessible.restype = c_uint
        # C原型：bool __stdcall MV_CC_IsDeviceAccessible(IN MV_CC_DEVICE_INFO* pstDevInfo, IN unsigned int nAccessMode);
        return MvCamCtrldll.MV_CC_IsDeviceAccessible(byref(stDevInfo), nAccessMode)

    # ch:枚举采集卡 | en:Enumerate frame grabbers
    @staticmethod
    def MV_CC_EnumInterfaces(nTLayerType, stInterfaceInfoList):
        MvCamCtrldll.MV_CC_EnumInterfaces.argtype = (c_uint, c_void_p)
        MvCamCtrldll.MV_CC_EnumInterfaces.restype = c_uint
        # C原型：bool __stdcall MV_CC_EnumInterfaces(IN unsigned int nTLayerType,
        #                                           IN OUT MV_INTERFACE_INFO_LIST* pInterfaceInfoList);
        return MvCamCtrldll.MV_CC_EnumInterfaces(c_uint(nTLayerType), byref(stInterfaceInfoList))

    # ch:创建采集卡句柄 | en:Create frame grabber handle
    def MV_CC_CreateInterface(self, stInterfaceInfo):
        MvCamCtrldll.MV_CC_CreateInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_CreateInterface.restype = c_uint
        # C原型：MV_CC_CreateInterface(IN OUT void ** handle, IN MV_INTERFACE_INFO* pInterfaceInfo);
        return MvCamCtrldll.MV_CC_CreateInterface(byref(self.handle), byref(stInterfaceInfo))

    # ch:通过采集卡ID创建采集卡句柄 | en:Create frame grabber handle by frame grabber ID
    def MV_CC_CreateInterfaceByID(self, InterfaceID):
        MvCamCtrldll.MV_CC_CreateInterfaceByID.argtype = c_void_p
        MvCamCtrldll.MV_CC_CreateInterfaceByID.restype = c_uint
        # C原型：MV_CC_CreateInterfaceByID(IN OUT void ** handle, IN char* pInterfaceID);
        return MvCamCtrldll.MV_CC_CreateInterfaceByID(byref(self.handle), InterfaceID.encode('ascii'))

    # ch:打开采集卡 | en:Open frame grabber
    def MV_CC_OpenInterface(self):
        MvCamCtrldll.MV_CC_OpenInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_OpenInterface.restype = c_uint
        # C原型：int __stdcall MV_CC_OpenInterface(IN void* handle, IN char* pReserved);
        return MvCamCtrldll.MV_CC_OpenInterface(self.handle, 0)

    # ch:关闭采集卡 | en:Close frame grabber
    def MV_CC_CloseInterface(self):
        MvCamCtrldll.MV_CC_CloseInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_CloseInterface.restype = c_uint
        # C原型：int __stdcall MV_CC_CloseInterface(IN void* handle);
        return MvCamCtrldll.MV_CC_CloseInterface(self.handle)

    # ch:销毁采集卡句柄 | en:Destroy frame grabber handle
    def MV_CC_DestroyInterface(self):
        MvCamCtrldll.MV_CC_DestroyInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_DestroyInterface.restype = c_uint
        # C原型：int __stdcall MV_CC_DestroyInterface(IN void* handle);
        return MvCamCtrldll.MV_CC_DestroyInterface(self.handle)

    # ch: 设置SDK日志路径 | en: Set SDK log path
    def MV_CC_SetSDKLogPath(self, SDKLogPath):
        MvCamCtrldll.MV_CC_SetSDKLogPath.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_SetSDKLogPath.restype = c_uint
        # C原型:int MV_CC_SetSDKLogPath(IN const char * strSDKLogPath);
        return MvCamCtrldll.MV_CC_SetSDKLogPath(SDKLogPath.encode('ascii'))

    # ch:创建设备句柄 | en:Create Device Handle
    def MV_CC_CreateHandle(self, stDevInfo):
        MvCamCtrldll.MV_CC_CreateHandle.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_CreateHandle.restype = c_uint
        # C原型:int MV_CC_CreateHandle(void ** handle, MV_CC_DEVICE_INFO* pstDevInfo)
        return MvCamCtrldll.MV_CC_CreateHandle(byref(self.handle), byref(stDevInfo))

    # ch:创建句柄（不生成日志） | en:Create Device Handle without log
    def MV_CC_CreateHandleWithoutLog(self, stDevInfo):
        MvCamCtrldll.MV_CC_CreateHandleWithoutLog.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_CreateHandleWithoutLog.restype = c_uint
        # C原型:int MV_CC_CreateHandleWithoutLog(void ** handle, MV_CC_DEVICE_INFO* pstDevInfo)
        return MvCamCtrldll.MV_CC_CreateHandleWithoutLog(byref(self.handle), byref(stDevInfo))

    # ch:销毁设备句柄 | en:Destroy Device Handle
    def MV_CC_DestroyHandle(self):
        MvCamCtrldll.MV_CC_DestroyHandle.argtype = c_void_p
        MvCamCtrldll.MV_CC_DestroyHandle.restype = c_uint
        return MvCamCtrldll.MV_CC_DestroyHandle(self.handle)

    # ch:打开设备 | en:Open Device
    def MV_CC_OpenDevice(self, nAccessMode=MV_ACCESS_Exclusive, nSwitchoverKey=0):
        MvCamCtrldll.MV_CC_OpenDevice.argtype = (c_void_p, c_uint32, c_uint16)
        MvCamCtrldll.MV_CC_OpenDevice.restype = c_uint
        # C原型:int MV_CC_OpenDevice(void* handle, unsigned int nAccessMode, unsigned short nSwitchoverKey)
        return MvCamCtrldll.MV_CC_OpenDevice(self.handle, nAccessMode, nSwitchoverKey)

    # ch:关闭设备 | en:Close Device
    def MV_CC_CloseDevice(self):
        MvCamCtrldll.MV_CC_CloseDevice.argtype = c_void_p
        MvCamCtrldll.MV_CC_CloseDevice.restype = c_uint
        return MvCamCtrldll.MV_CC_CloseDevice(self.handle)

    # ch:判断设备是否处于连接状态 | en: Is The Device Connected
    def MV_CC_IsDeviceConnected(self):
        MvCamCtrldll.MV_CC_IsDeviceConnected.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_IsDeviceConnected.restype = c_bool
        # C原型：bool __stdcall MV_CC_IsDeviceConnected(IN void* handle);
        return MvCamCtrldll.MV_CC_IsDeviceConnected(self.handle)

    # ch:注册图像数据回调 | en:Register the image callback function
    def MV_CC_RegisterImageCallBackEx(self, CallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterImageCallBackEx.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterImageCallBackEx.restype = c_uint
        # C原型:int MV_CC_RegisterImageCallBackEx(void* handle,
        #                        void(* cbOutput)(unsigned char * pData, MV_FRAME_OUT_INFO_EX* pFrameInfo, void* pUser),
        #                        void* pUser);
        return MvCamCtrldll.MV_CC_RegisterImageCallBackEx(self.handle, CallBackFun, pUser)

    # ch:注册取流回调 | en:Register the image callback function
    def MV_CC_RegisterImageCallBackForRGB(self, CallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterImageCallBackForRGB.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterImageCallBackForRGB.restype = c_uint
        # C原型:int MV_CC_RegisterImageCallBackForRGB(void* handle,
        #                        void(* cbOutput)(unsigned char * pData, MV_FRAME_OUT_INFO_EX* pFrameInfo, void* pUser),
        #                        void* pUser);
        return MvCamCtrldll.MV_CC_RegisterImageCallBackForRGB(self.handle, CallBackFun, pUser)

    # ch:注册取流回调 | en:Register the image callback function
    def MV_CC_RegisterImageCallBackForBGR(self, CallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterImageCallBackForBGR.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterImageCallBackForBGR.restype = c_uint
        # C原型:int MV_CC_RegisterImageCallBackForBGR(void* handle,
        #                         void(* cbOutput)(unsigned char * pData,MV_FRAME_OUT_INFO_EX* pFrameInfo, void* pUser),
        #                         void* pUser);
        return MvCamCtrldll.MV_CC_RegisterImageCallBackForBGR(self.handle, CallBackFun, pUser)

    # ch:开始取流 | en:Start Grabbing
    def MV_CC_StartGrabbing(self):
        MvCamCtrldll.MV_CC_StartGrabbing.argtype = c_void_p
        MvCamCtrldll.MV_CC_StartGrabbing.restype = c_uint
        return MvCamCtrldll.MV_CC_StartGrabbing(self.handle)

    # ch:停止取流 | en:Stop Grabbing
    def MV_CC_StopGrabbing(self):
        MvCamCtrldll.MV_CC_StopGrabbing.argtype = c_void_p
        MvCamCtrldll.MV_CC_StopGrabbing.restype = c_uint
        return MvCamCtrldll.MV_CC_StopGrabbing(self.handle)

    # ch:获取一帧RGB数据，此函数为查询式获取，每次调用查询内部缓存有无数据，有数据则获取数据，无数据返回错误码
    # en:Get one frame of RGB data, this function is using query to get data query whether the internal cache has data,
    # get data if there has, return error code if no data
    def MV_CC_GetImageForRGB(self, pData, nDataSize, stFrameInfo, nMsec):
        MvCamCtrldll.MV_CC_GetImageForRGB.argtype = (c_void_p, c_void_p, c_uint, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetImageForRGB.restype = c_uint
        # C原型:int MV_CC_GetImageForRGB(IN void* handle, IN OUT unsigned char * pData , IN unsigned int nDataSize,
        #                               IN OUT MV_FRAME_OUT_INFO_EX* pstFrameInfo, int nMsec);
        return MvCamCtrldll.MV_CC_GetImageForRGB(self.handle, pData, nDataSize, byref(stFrameInfo), nMsec)

    # ch:获取一帧BGR数据，此函数为查询式获取，每次调用查询内部缓存有无数据，有数据则获取数据，无数据返回错误码
    # en:Get one frame of BGR data, this function is using query to get data query whether the internal cache has data,
    # get data if there has, return error code if no data
    def MV_CC_GetImageForBGR(self, pData, nDataSize, stFrameInfo, nMsec):
        MvCamCtrldll.MV_CC_GetImageForBGR.argtype = (c_void_p, c_void_p, c_uint, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetImageForBGR.restype = c_uint
        # C原型:int MV_CC_GetImageForBGR(IN void* handle, IN OUT unsigned char * pData , IN unsigned int nDataSize,
        #                               IN OUT MV_FRAME_OUT_INFO_EX* pstFrameInfo, int nMsec);
        return MvCamCtrldll.MV_CC_GetImageForBGR(self.handle, pData, nDataSize, byref(stFrameInfo), nMsec)

    # ch:使用内部缓存获取一帧图片（与MV_CC_Display不能同时使用）
    # en:Get a frame of an image using an internal cache(Cannot be used together with the interface of MV_CC_Display)
    def MV_CC_GetImageBuffer(self, stFrame, nMsec):
        MvCamCtrldll.MV_CC_GetImageBuffer.argtype = (c_void_p, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetImageBuffer.restype = c_uint
        # C原型:int MV_CC_GetImageBuffer(IN void* handle, OUT MV_FRAME_OUT* pstFrame, IN unsigned int nMsec);
        return MvCamCtrldll.MV_CC_GetImageBuffer(self.handle, byref(stFrame), nMsec)

    # ch:释放图像缓存（与MV_CC_GetImageBuffer配套使用）
    # en:Free image buffer(this interface can free image buffer, used with MV_CC_GetImageBuffer)
    def MV_CC_FreeImageBuffer(self, stFrame):
        MvCamCtrldll.MV_CC_FreeImageBuffer.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FreeImageBuffer.restype = c_uint
        # C原型:int MV_CC_FreeImageBuffer(IN void* handle, IN MV_FRAME_OUT* pstFrame);
        return MvCamCtrldll.MV_CC_FreeImageBuffer(self.handle, byref(stFrame))

    # ch:采用超时机制获取一帧图片，SDK内部等待直到有数据时返回
    # en:Timeout mechanism is used to get image, and the SDK waits inside until the data is returned
    def MV_CC_GetOneFrameTimeout(self, pData, nDataSize, stFrameInfo, nMsec=1000):
        MvCamCtrldll.MV_CC_GetOneFrameTimeout.argtype = (c_void_p, c_void_p, c_uint, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetOneFrameTimeout.restype = c_uint
        # C原型:int MV_CC_GetOneFrameTimeout(void* handle, unsigned char * pData , unsigned int nDataSize,
        #                                    MV_FRAME_OUT_INFO_EX* pFrameInfo, unsigned int nMsec)
        return MvCamCtrldll.MV_CC_GetOneFrameTimeout(self.handle, pData, nDataSize, byref(stFrameInfo), nMsec)

    # ch:清除取流数据缓存 | en:if Image buffers has retrieved the data，Clear them
    def MV_CC_ClearImageBuffer(self):
        MvCamCtrldll.MV_CC_ClearImageBuffer.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_ClearImageBuffer.restype = c_uint
        # C原型:int MV_CC_ClearImageBuffer(IN void* handle);
        return MvCamCtrldll.MV_CC_ClearImageBuffer(self.handle)

    # ch:获取当前图像缓存区的有效图像个数 | en: Get the number of valid images in the current image buffer
    def MV_CC_GetValidImageNum(self, nValidImageNum):
        MvCamCtrldll.MV_CC_GetValidImageNum.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetValidImageNum.restype = c_uint
        # C原型:int MV_CC_GetValidImageNum(IN void* handle, OUT unsigned int *pnValidImageNum);
        return MvCamCtrldll.MV_CC_GetValidImageNum(self.handle, byref(nValidImageNum))

    # ch:显示一帧图像
    # en:Display one frame image,the maximum resolution supported is 16384 * 163840
    def MV_CC_DisplayOneFrame(self, stDisplayInfo):
        MvCamCtrldll.MV_CC_DisplayOneFrame.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DisplayOneFrame.restype = c_uint
        # C原型:int MV_CC_DisplayOneFrame(IN void* handle, IN MV_DISPLAY_FRAME_INFO* pstDisplayInfo);
        return MvCamCtrldll.MV_CC_DisplayOneFrame(self.handle, byref(stDisplayInfo))

    # ch:显示一帧图像, 支持RGB8_Packed，BGR8_Packed，Mono8三种像素格式的渲染宽高大小至int类型
    # en:Get a frame of an image using an internal cache
    #    This API support rendering in three pixel formats:RGB8_Packed,BGR8_Packed and Mono8,width and height to int.
    def MV_CC_DisplayOneFrameEx(self, hWnd, stDisplayInfo):
        MvCamCtrldll.MV_CC_DisplayOneFrameEx.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DisplayOneFrameEx.restype = c_uint
        # C原型:int MV_CC_DisplayOneFrameEx(IN void* handle, IN void* hWnd, IN MV_DISPLAY_FRAME_INFO_EX* pstDisplayInfo);
        return MvCamCtrldll.MV_CC_DisplayOneFrameEx(self.handle, hWnd, byref(stDisplayInfo))

    # ch:设置SDK内部图像缓存节点个数，大于等于1，在抓图前调用
    # en:Set the number of the internal image cache nodes in SDK, Greater than or equal to 1,
    # to be called before the capture
    def MV_CC_SetImageNodeNum(self, nNum):
        MvCamCtrldll.MV_CC_SetImageNodeNum.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetImageNodeNum.restype = c_uint
        # C原型:int MV_CC_SetImageNodeNum(IN void* handle, unsigned int nNum);
        return MvCamCtrldll.MV_CC_SetImageNodeNum(self.handle, c_uint(nNum))

    # ch:设置取流策略 | en:Set Grab Strategy
    def MV_CC_SetGrabStrategy(self, enGrabStrategy):
        MvCamCtrldll.MV_CC_SetGrabStrategy.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetGrabStrategy.restype = c_uint
        # C原型:int MV_CC_SetGrabStrategy(IN void* handle, IN MV_GRAB_STRATEGY enGrabStrategy);
        return MvCamCtrldll.MV_CC_SetGrabStrategy(self.handle, c_uint(enGrabStrategy))

    # ch:设置输出缓存个数（只有在MV_GrabStrategy_LatestImages策略下才有效，范围：1-ImageNodeNum）
    # en:Set The Size of Output Queue(Only work under the strategy of MV_GrabStrategy_LatestImages，rang：1-ImageNodeNum)
    def MV_CC_SetOutputQueueSize(self, nOutputQueueSize):
        MvCamCtrldll.MV_CC_SetOutputQueueSize.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetOutputQueueSize.restype = c_uint
        # C原型:int MV_CC_SetOutputQueueSize(IN void* handle, IN unsigned int nOutputQueueSize);
        return MvCamCtrldll.MV_CC_SetOutputQueueSize(self.handle, nOutputQueueSize)

    # ch:获取设备信息，取流之前调用 | en:Get device information
    def MV_CC_GetDeviceInfo(self, stDevInfo):
        MvCamCtrldll.MV_CC_GetDeviceInfo.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetDeviceInfo.restype = c_uint
        # C原型:int MV_CC_GetDeviceInfo(IN void * handle, IN OUT MV_CC_DEVICE_INFO* pstDevInfo);
        return MvCamCtrldll.MV_CC_GetDeviceInfo(self.handle, byref(stDevInfo))

    # ch:获取各种类型的信息 | en:Get various type of information
    def MV_CC_GetAllMatchInfo(self, stInfo):
        MvCamCtrldll.MV_CC_GetAllMatchInfo.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetAllMatchInfo.restype = c_uint
        # C原型:int MV_CC_GetAllMatchInfo(IN void* handle, IN OUT MV_ALL_MATCH_INFO* pstInfo);
        return MvCamCtrldll.MV_CC_GetAllMatchInfo(self.handle, byref(stInfo))

    '''
    Part2 ch: 相机属性万能配置接口 | en: Camera attribute nodes universal interface 
    '''
    # ch:获取Integer属性值 | en:Get Integer value
    def MV_CC_GetIntValueEx(self, strKey, stIntValue):
        MvCamCtrldll.MV_CC_GetIntValueEx.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetIntValueEx.restype = c_uint
        # C原型:int MV_CC_GetIntValueEx(IN void* handle,IN const char* strKey,OUT MVCC_INTVALUE_EX *pstIntValue);
        return MvCamCtrldll.MV_CC_GetIntValueEx(self.handle, strKey.encode('ascii'), byref(stIntValue))

    # ch:设置Integer型属性值 | en:Set Integer value
    def MV_CC_SetIntValueEx(self, strKey, nValue):
        MvCamCtrldll.MV_CC_SetIntValueEx.argtype = (c_void_p, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetIntValueEx.restype = c_uint
        # C原型:int MV_CC_SetIntValueEx(IN void* handle,IN const char* strKey,IN int64_t nValue);
        return MvCamCtrldll.MV_CC_SetIntValueEx(self.handle, strKey.encode('ascii'), c_uint(nValue))

    # ch:获取Integer型属性值 | en:Get Integer value
    def MV_CC_GetIntValue(self, strKey, stIntValue):
        MvCamCtrldll.MV_CC_GetIntValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetIntValue.restype = c_uint
        # C原型:int MV_CC_GetIntValue(void* handle,char* strKey,MVCC_INTVALUE *pIntValue)
        return MvCamCtrldll.MV_CC_GetIntValue(self.handle, strKey.encode('ascii'), byref(stIntValue))

    # ch:设置Integer型属性值 | en:Set Integer value
    def MV_CC_SetIntValue(self, strKey, nValue):
        MvCamCtrldll.MV_CC_SetIntValue.argtype = (c_void_p, c_void_p, c_uint32)
        MvCamCtrldll.MV_CC_SetIntValue.restype = c_uint
        # C原型:int MV_CC_SetIntValue(void* handle, char* strKey, unsigned int nValue)
        return MvCamCtrldll.MV_CC_SetIntValue(self.handle, strKey.encode('ascii'), c_uint32(nValue))

    # ch:获取Enum属性值 | en:Get Enum value
    def MV_CC_GetEnumValue(self, strKey, stEnumValue):
        MvCamCtrldll.MV_CC_GetEnumValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetEnumValue.restype = c_uint
        # C原型:int MV_CC_GetEnumValue(void* handle,char* strKey,MVCC_ENUMVALUE *pEnumValue)
        return MvCamCtrldll.MV_CC_GetEnumValue(self.handle, strKey.encode('ascii'), byref(stEnumValue))

    # ch:设置Enum型属性值 | en:Set Enum value
    def MV_CC_SetEnumValue(self, strKey, nValue):
        MvCamCtrldll.MV_CC_SetEnumValue.argtype = (c_void_p, c_void_p, c_uint32)
        MvCamCtrldll.MV_CC_SetEnumValue.restype = c_uint
        # C原型:int MV_CC_SetEnumValue(void* handle,char* strKey,unsigned int nValue)
        return MvCamCtrldll.MV_CC_SetEnumValue(self.handle, strKey.encode('ascii'), c_uint32(nValue))

    # ch:获取Enum型节点指定值的符号 | en: Get the symbolic of the specified value of the Enum type node
    def MV_CC_GetEnumEntrySymbolic(self, strKey, stEnumEntry):
        MvCamCtrldll.MV_CC_GetEnumEntrySymbolic.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetEnumEntrySymbolic.restype = c_uint
        # C原型:int MV_CC_GetEnumEntrySymbolic(IN void* handle,IN const char* strKey,
        #                                     IN OUT MVCC_ENUMENTRY* pstEnumEntry);
        return MvCamCtrldll.MV_CC_GetEnumEntrySymbolic(self.handle, strKey.encode('ascii'), byref(stEnumEntry))

    # ch:设置Enum型属性值 | en:Set Enum value
    def MV_CC_SetEnumValueByString(self, strKey, sValue):
        MvCamCtrldll.MV_CC_SetEnumValueByString.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetEnumValueByString.restype = c_uint
        # C原型:int MV_CC_SetEnumValueByString(void* handle,char* strKey,char* sValue)
        return MvCamCtrldll.MV_CC_SetEnumValueByString(self.handle, strKey.encode('ascii'), sValue.encode('ascii'))

    # ch:获取Float型属性值 | en:Get Float value
    def MV_CC_GetFloatValue(self, strKey, stFloatValue):
        MvCamCtrldll.MV_CC_GetFloatValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetFloatValue.restype = c_uint
        # C原型:int MV_CC_GetFloatValue(void* handle,char* strKey,MVCC_FLOATVALUE *pFloatValue)
        return MvCamCtrldll.MV_CC_GetFloatValue(self.handle, strKey.encode('ascii'), byref(stFloatValue))

    # ch:设置Float型属性值 | en:Set float value
    def MV_CC_SetFloatValue(self, strKey, fValue):
        MvCamCtrldll.MV_CC_SetFloatValue.argtype = (c_void_p, c_void_p, c_float)
        MvCamCtrldll.MV_CC_SetFloatValue.restype = c_uint
        # C原型:int MV_CC_SetFloatValue(void* handle,char* strKey,float fValue)
        return MvCamCtrldll.MV_CC_SetFloatValue(self.handle, strKey.encode('ascii'), c_float(fValue))

    # ch:获取Boolean型属性值 | en:Get Boolean value
    def MV_CC_GetBoolValue(self, strKey, BoolValue):
        MvCamCtrldll.MV_CC_GetBoolValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetBoolValue.restype = c_uint
        # C原型:int MV_CC_GetBoolValue(void* handle,char* strKey,bool *pBoolValue)
        return MvCamCtrldll.MV_CC_GetBoolValue(self.handle, strKey.encode('ascii'), byref(BoolValue))

    # ch:设置Boolean型属性值 | en:Set Boolean value
    def MV_CC_SetBoolValue(self, strKey, bValue):
        MvCamCtrldll.MV_CC_SetBoolValue.argtype = (c_void_p, c_void_p, c_bool)
        MvCamCtrldll.MV_CC_SetBoolValue.restype = c_uint
        # C原型:int MV_CC_SetBoolValue(void* handle,char* strKey,bool bValue)
        return MvCamCtrldll.MV_CC_SetBoolValue(self.handle, strKey.encode('ascii'), bValue)

    # ch:获取String型属性值 | en:Get String value
    def MV_CC_GetStringValue(self, strKey, StringValue):
        MvCamCtrldll.MV_CC_GetStringValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetStringValue.restype = c_uint
        # C原型:int MV_CC_GetStringValue(void* handle,char* strKey,MVCC_STRINGVALUE *pStringValue)
        return MvCamCtrldll.MV_CC_GetStringValue(self.handle, strKey.encode('ascii'), byref(StringValue))

    # ch:设置String型属性值 | en:Set String value
    def MV_CC_SetStringValue(self, strKey, sValue):
        MvCamCtrldll.MV_CC_SetStringValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetStringValue.restype = c_uint
        # C原型:int MV_CC_SetStringValue(void* handle,char* strKey,char * sValue)
        return MvCamCtrldll.MV_CC_SetStringValue(self.handle, strKey.encode('ascii'), sValue.encode('ascii'))

    # ch:设置Command型属性值 | en:Send Command
    def MV_CC_SetCommandValue(self, strKey):
        MvCamCtrldll.MV_CC_SetCommandValue.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetCommandValue.restype = c_uint
        # C原型:int MV_CC_SetCommandValue(void* handle,char* strKey)
        return MvCamCtrldll.MV_CC_SetCommandValue(self.handle, strKey.encode('ascii'))

    # ch:读内存 | en:Read Memory
    def MV_CC_ReadMemory(self, pBuffer, nAddress, nLength):
        MvCamCtrldll.MV_CC_ReadMemory.argtype = (c_void_p, c_void_p, c_uint, c_uint)
        MvCamCtrldll.MV_CC_ReadMemory.restype = c_uint
        # C原型:int MV_CC_ReadMemory(IN void* handle , void *pBuffer, int64_t nAddress, int64_t nLength);
        return MvCamCtrldll.MV_CC_ReadMemory(self.handle, pBuffer, c_uint(nAddress), nLength)

    # ch:写内存 | en:Write Memory
    def MV_CC_WriteMemory(self, pBuffer, nAddress, nLength):
        MvCamCtrldll.MV_CC_WriteMemory.argtype = (c_void_p, c_void_p, c_uint, c_uint)
        MvCamCtrldll.MV_CC_WriteMemory.restype = c_uint
        # C原型:int MV_CC_WriteMemory(IN void* handle, const void *pBuffer, int64_t nAddress, int64_t nLength);
        return MvCamCtrldll.MV_CC_WriteMemory(self.handle, pBuffer, c_uint(nAddress), nLength)

    # ch:清除GenICam节点缓存 | en:Invalidate GenICam Nodes
    def MV_CC_InvalidateNodes(self):
        MvCamCtrldll.MV_CC_InvalidateNodes.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_InvalidateNodes.restype = c_uint
        # C原型:int MV_CC_InvalidateNodes(IN void* handle);
        return MvCamCtrldll.MV_CC_InvalidateNodes(self.handle)

    # ch:获取设备属性树XML | en:Get camera feature tree XML
    def MV_XML_GetGenICamXML(self, pData, nDataSize, pnDataLen):
        MvCamCtrldll.MV_XML_GetGenICamXML.argtype = (c_void_p, c_void_p, c_uint, c_void_p)
        MvCamCtrldll.MV_XML_GetGenICamXML.restype = c_uint
        # C原型:int MV_XML_GetGenICamXML(IN void* handle, IN OUT unsigned char* pData,
        #                               IN unsigned int nDataSize, OUT unsigned int* pnDataLen);
        return MvCamCtrldll.MV_XML_GetGenICamXML(self.handle, pData, c_uint(nDataSize), byref(pnDataLen))

    # ch:获得当前节点的访问模式 | en:Get Access mode of cur node
    def MV_XML_GetNodeAccessMode(self, strName, penAccessMode):
        MvCamCtrldll.MV_XML_GetNodeAccessMode.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_XML_GetNodeAccessMode.restype = c_uint
        # C原型:int MV_XML_GetNodeAccessMode(IN void* handle,
        #                                   IN const char * strName, OUT MV_XML_AccessMode *penAccessMode);
        return MvCamCtrldll.MV_XML_GetNodeAccessMode(self.handle, strName.encode('ascii'), byref(penAccessMode))

    # ch:获得当前节点的类型 | en:Get Interface Type of cur node
    def MV_XML_GetNodeInterfaceType(self, strName, penInterfaceType):
        MvCamCtrldll.MV_XML_GetNodeInterfaceType.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_XML_GetNodeInterfaceType.restype = c_uint
        # C原型:int MV_XML_GetNodeInterfaceType(IN void* handle,
        #                                      IN const char * strName, OUT MV_XML_InterfaceType *penInterfaceType);
        return MvCamCtrldll.MV_XML_GetNodeInterfaceType(self.handle, strName.encode('ascii'), byref(penInterfaceType))

    # ch:保存设备属性 | en:Save camera feature
    def MV_CC_FeatureSave(self, strFileName):
        MvCamCtrldll.MV_CC_FeatureSave.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FeatureSave.restype = c_uint
        # C原型:int MV_CC_FeatureSave(void* handle, char* pFileName)
        return MvCamCtrldll.MV_CC_FeatureSave(self.handle, strFileName.encode('ascii'))

    # ch:导入设备属性 | en:Load camera feature
    def MV_CC_FeatureLoad(self, strFileName):
        MvCamCtrldll.MV_CC_FeatureLoad.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FeatureLoad.restype = c_uint
        # C原型:int MV_CC_FeatureLoad(void* handle, char* pFileName)
        return MvCamCtrldll.MV_CC_FeatureLoad(self.handle, strFileName.encode('ascii'))

    # ch:从设备读取文件 | en:Read the file from the camera
    def MV_CC_FileAccessRead(self, stFileAccess):
        MvCamCtrldll.MV_CC_FileAccessRead.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessRead.restype = c_uint
        # C原型:int MV_CC_FileAccessRead(void* handle, MV_CC_FILE_ACCESS * pstFileAccess)
        return MvCamCtrldll.MV_CC_FileAccessRead(self.handle, byref(stFileAccess))

    # ch:从设备读取文件,文件是Data数据 | en:Read the file from the camera
    def MV_CC_FileAccessReadEx(self, stFileAccessEx):
        MvCamCtrldll.MV_CC_FileAccessReadEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessReadEx.restype = c_uint
        # C原型:int MV_CC_FileAccessReadEx(IN void* handle, IN OUT MV_CC_FILE_ACCESS_EX * pstFileAccessEx)
        return MvCamCtrldll.MV_CC_FileAccessReadEx(self.handle, byref(stFileAccessEx))

    # ch:将文件写入设备 | en:Write the file to camera
    def MV_CC_FileAccessWrite(self, stFileAccess):
        MvCamCtrldll.MV_CC_FileAccessWrite.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessWrite.restype = c_uint
        # C原型:int MV_CC_FileAccessWrite(void* handle, MV_CC_FILE_ACCESS * pstFileAccess)
        return MvCamCtrldll.MV_CC_FileAccessWrite(self.handle, byref(stFileAccess))

    # ch:将文件写入设备,参数是文件data | en:Write the file to camera
    def MV_CC_FileAccessWriteEx(self, stFileAccessEx):
        MvCamCtrldll.MV_CC_FileAccessWriteEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessWriteEx.restype = c_uint
        # C原型:int MV_CC_FileAccessWriteEx(IN void* handle, IN MV_CC_FILE_ACCESS_EX * pstFileAccessEx)
        return MvCamCtrldll.MV_CC_FileAccessWriteEx(self.handle, byref(stFileAccessEx))

    # ch:获取文件存取进度 | en:Get File Access Progress
    def MV_CC_GetFileAccessProgress(self, stFileAccessProgress):
        MvCamCtrldll.MV_CC_GetFileAccessProgress.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetFileAccessProgress.restype = c_uint
        # C原型:int MV_CC_GetFileAccessProgress(void* handle, MV_CC_FILE_ACCESS_PROGRESS * pstFileAccessProgress)
        return MvCamCtrldll.MV_CC_GetFileAccessProgress(self.handle, byref(stFileAccessProgress))

    ''' Part3 ch: 相机升级 | en: Camera upgrade '''

    # ch:设备本地升级 | en: Device Local Upgrade
    def MV_CC_LocalUpgrade(self, strFilePathName):
        MvCamCtrldll.MV_CC_LocalUpgrade.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_LocalUpgrade.restype = c_uint
        # C原型:int MV_CC_LocalUpgrade(IN void* handle, const void* strFilePathName);
        return MvCamCtrldll.MV_CC_LocalUpgrade(self.handle, strFilePathName.encode('ascii'))

    # ch:获取升级进度 | en: Get Upgrade Progress
    def MV_CC_GetUpgradeProcess(self, nProcess):
        MvCamCtrldll.MV_CC_GetUpgradeProcess.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetUpgradeProcess.restype = c_uint
        # C原型:int MV_CC_GetUpgradeProcess(IN void* handle, unsigned int* pnProcess);
        return MvCamCtrldll.MV_CC_GetUpgradeProcess(self.handle, byref(nProcess))

    ''' Part4  ch: 注册异常回调和事件接口 | en: Enrol abnormal callbacks and event interface '''

    # ch:注册异常消息回调 | en:Register Exception Message CallBack, call after open device
    def MV_CC_RegisterExceptionCallBack(self, ExceptionCallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterExceptionCallBack.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterExceptionCallBack.restype = c_uint
        # C原型:int MV_CC_RegisterExceptionCallBack(void* handle,
        #                                          void(* cbException)(unsigned int nMsgType, void* pUser),void* pUser)
        return MvCamCtrldll.MV_CC_RegisterExceptionCallBack(self.handle, ExceptionCallBackFun, pUser)

    # ch:注册全部事件回调，在打开设备之后调用 | en:Register event callback, which is called after the device is opened
    def MV_CC_RegisterAllEventCallBack(self, EventCallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterAllEventCallBack.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterAllEventCallBack.restype = c_uint
        # C原型:int MV_CC_RegisterAllEventCallBack(void* handle,
        #                       void(__stdcall* cbEvent)(MV_EVENT_OUT_INFO * pEventInfo, void* pUser), void* pUser);
        return MvCamCtrldll.MV_CC_RegisterAllEventCallBack(self.handle, EventCallBackFun, pUser)

    # ch:注册单个事件回调，在打开设备之后调用 | en:Register single event callback, which is called after the device is opened
    def MV_CC_RegisterEventCallBackEx(self, pEventName, EventCallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterEventCallBackEx.argtype = (c_void_p, c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterEventCallBackEx.restype = c_uint
        # C原型:int MV_CC_RegisterEventCallBackEx(void* handle, char* pEventName,
        #                                     void(* cbEvent)(MV_EVENT_OUT_INFO * pEventInfo, void* pUser),void* pUser)
        return MvCamCtrldll.MV_CC_RegisterEventCallBackEx(self.handle, pEventName.encode('ascii'), EventCallBackFun,
                                                          pUser)

    '''Part5 ch: 仅GigE设备支持的接口 | en: Only support GigE interface '''

    # ch:设置枚举超时时间，仅支持GigE协议，范围 0-UINT_MAX | en：Set enumerate device timeout,only GigE support
    # 在调用MV_CC_EnumDevices等枚举接口前使用该接口，可设置枚举GIGE设备的网卡最大超时时间（默认100ms）,来加快枚举GIGE设备的速度
    # Before calling enum device interfaces,call MV_GIGE_SetEnumDevTimeout to set max timeout,
    # can reduce the maximum timeout to speed up the enumeration of GigE devices
    def MV_GIGE_SetEnumDevTimeout(self, nMilTimeout):
        MvCamCtrldll.MV_GIGE_SetEnumDevTimeout.argtype = (c_uint)
        MvCamCtrldll.MV_GIGE_SetEnumDevTimeout.restype = c_uint
        # C原型:int MV_GIGE_SetEnumDevTimeout(IN unsigned int nMilTimeout)
        return MvCamCtrldll.MV_GIGE_SetEnumDevTimeout(c_uint(nMilTimeout))

    # ch:强制修改IP | en：Force IP
    def MV_GIGE_ForceIpEx(self, nIP, nSubNetMask, nDefaultGateWay):
        MvCamCtrldll.MV_GIGE_ForceIpEx.argtype = (c_void_p, c_uint, c_uint, c_uint)
        MvCamCtrldll.MV_GIGE_ForceIpEx.restype = c_uint
        # C原型:int MV_GIGE_ForceIpEx(void* handle, unsigned int nIP,
        #                            unsigned int nSubNetMask, unsigned int nDefaultGateWay)
        return MvCamCtrldll.MV_GIGE_ForceIpEx(self.handle, c_uint(nIP), c_uint(nSubNetMask), c_uint(nDefaultGateWay))

    # ch:配置IP方式 | en: IP configuration method
    def MV_GIGE_SetIpConfig(self, nType):
        MvCamCtrldll.MV_GIGE_SetIpConfig.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetIpConfig.restype = c_uint
        # C原型:int MV_GIGE_SetIpConfig(void* handle, unsigned int nType)
        return MvCamCtrldll.MV_GIGE_SetIpConfig(self.handle, c_uint(nType))

    # ch:设置仅使用某种模式,type: MV_NET_TRANS_x，不设置时，默认优先使用driver
    # en: Set to use only one mode,type: MV_NET_TRANS_x. When do not set, priority is to use driver by default
    def MV_GIGE_SetNetTransMode(self, nType):
        MvCamCtrldll.MV_GIGE_SetNetTransMode.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetNetTransMode.restype = c_uint
        # C原型:int MV_GIGE_SetNetTransMode(IN void* handle, unsigned int nType);
        return MvCamCtrldll.MV_GIGE_SetNetTransMode(self.handle, c_uint(nType))

    # ch:获取网络传输信息 | en: Get net transmission information
    def MV_GIGE_GetNetTransInfo(self, pstInfo):
        MvCamCtrldll.MV_GIGE_GetNetTransInfo.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetNetTransInfo.restype = c_uint
        # C原型:int MV_GIGE_GetNetTransInfo(IN void* handle, MV_NETTRANS_INFO* pstInfo);
        return MvCamCtrldll.MV_GIGE_GetNetTransInfo(self.handle, byref(pstInfo))

    # ch:设置枚举命令的回复包类型 | en: Setting the ACK mode of devices Discovery
    def MV_GIGE_SetDiscoveryMode(self, nMode):
        MvCamCtrldll.MV_GIGE_SetDiscoveryMode.argtype = (c_uint)
        MvCamCtrldll.MV_GIGE_SetDiscoveryMode.restype = c_uint
        # C原型:int MV_GIGE_SetDiscoveryMode(unsigned int nMode);
        return MvCamCtrldll.MV_GIGE_SetDiscoveryMode(c_uint(nMode))

    # ch:设置GVSP取流超时时间| en: Set GVSP streaming timeout
    def MV_GIGE_SetGvspTimeout(self, nMillisec):
        MvCamCtrldll.MV_GIGE_SetGvspTimeout.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetGvspTimeout.restype = c_uint
        # C原型:int MV_GIGE_SetGvspTimeout(void* handle, unsigned int nMillisec);
        return MvCamCtrldll.MV_GIGE_SetGvspTimeout(self.handle, c_uint(nMillisec))

    # ch:获取GVSP取流超时时间 | en: Get GVSP streaming timeout
    def MV_GIGE_GetGvspTimeout(self, pnMillisec):
        MvCamCtrldll.MV_GIGE_GetGvspTimeout.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetGvspTimeout.restype = c_uint
        # C原型:int MV_GIGE_GetGvspTimeout(IN void* handle, unsigned int* pnMillisec);
        return MvCamCtrldll.MV_GIGE_GetGvspTimeout(self.handle, byref(pnMillisec))

    # ch:设置GVCP命令超时时间| en: Set GVCP cammand timeout
    def MV_GIGE_SetGvcpTimeout(self, nMillisec):
        MvCamCtrldll.MV_GIGE_SetGvcpTimeout.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetGvcpTimeout.restype = c_uint
        # C原型:int MV_GIGE_SetGvcpTimeout(void* handle, unsigned int nMillisec);
        return MvCamCtrldll.MV_GIGE_SetGvcpTimeout(self.handle, c_uint(nMillisec))

    # ch:获取GVCP命令超时时间 | en: Get GVCP cammand timeout
    def MV_GIGE_GetGvcpTimeout(self, pnMillisec):
        MvCamCtrldll.MV_GIGE_GetGvcpTimeout.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetGvcpTimeout.restype = c_uint
        # C原型:int MV_GIGE_GetGvcpTimeout(IN void* handle, unsigned int* pnMillisec);
        return MvCamCtrldll.MV_GIGE_GetGvcpTimeout(self.handle, byref(pnMillisec))

    # ch:设置重传GVCP命令次数| en: Set the number of retry GVCP cammand
    def MV_GIGE_SetRetryGvcpTimes(self, nRetryGvcpTimes):
        MvCamCtrldll.MV_GIGE_SetRetryGvcpTimes.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetRetryGvcpTimes.restype = c_uint
        # C原型:int MV_GIGE_SetRetryGvcpTimes(IN void* handle, unsigned int nRetryGvcpTimes);
        return MvCamCtrldll.MV_GIGE_SetRetryGvcpTimes(self.handle, c_uint(nRetryGvcpTimes))

    # ch:获取重传GVCP命令次数| en: Get the number of retry GVCP cammand
    def MV_GIGE_GetRetryGvcpTimes(self, pnRetryGvcpTimes):
        MvCamCtrldll.MV_GIGE_GetRetryGvcpTimes.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetRetryGvcpTimes.restype = c_uint
        # C原型:int MV_GIGE_GetRetryGvcpTimes(IN void* handle, unsigned int* pnRetryGvcpTimes);
        return MvCamCtrldll.MV_GIGE_GetRetryGvcpTimes(self.handle, byref(pnRetryGvcpTimes))

    # ch:获取网络最佳包大小 | en:Get the optimal Packet Size, Only support GigE Camera
    def MV_CC_GetOptimalPacketSize(self):
        MvCamCtrldll.MV_CC_GetOptimalPacketSize.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_GetOptimalPacketSize.restype = c_uint
        # C原型:int __stdcall MV_CC_GetOptimalPacketSize(void* handle);
        return MvCamCtrldll.MV_CC_GetOptimalPacketSize(self.handle)

    # ch:设置是否打开重发包支持，及重发包设置| en: Set whethe to enable resend, and set resend
    def MV_GIGE_SetResend(self, bEnable, nMaxResendPercent=10, nResendTimeout=50):
        MvCamCtrldll.MV_GIGE_SetResend.argtype = (c_void_p, c_uint, c_uint, c_uint)
        MvCamCtrldll.MV_GIGE_SetResend.restype = c_uint
        # C原型:int  MV_GIGE_SetResend(void* handle, unsigned int bEnable,
        # unsigned int nMaxResendPercent = 10, unsigned int nResendTimeout = 50);
        return MvCamCtrldll.MV_GIGE_SetResend(self.handle, c_uint(bEnable), c_uint(nMaxResendPercent),
                                              c_uint(nResendTimeout))

    # ch:设置重传命令最大尝试次数 | en: set the max resend retry times
    def MV_GIGE_SetResendMaxRetryTimes(self, nRetryTimes):
        MvCamCtrldll.MV_GIGE_SetResendMaxRetryTimes.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetResendMaxRetryTimes.restype = c_uint
        # C原型:int MV_GIGE_SetResendMaxRetryTimes(void* handle, unsigned int nRetryTimes);
        return MvCamCtrldll.MV_GIGE_SetResendMaxRetryTimes(self.handle, c_uint(nRetryTimes))

    # ch:获取重传命令最大尝试次数 | en: get the max resend retry times
    def MV_GIGE_GetResendMaxRetryTimes(self, nRetryTimes):
        MvCamCtrldll.MV_GIGE_GetResendMaxRetryTimes.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetResendMaxRetryTimes.restype = c_uint
        # C原型:int MV_GIGE_GetResendMaxRetryTimes(void* handle, unsigned int* pnRetryTimes);
        return MvCamCtrldll.MV_GIGE_GetResendMaxRetryTimes(self.handle, byref(nRetryTimes))

    # ch:设置同一重传包多次请求之间的时间间隔 | en: set time interval between same resend requests
    def MV_GIGE_SetResendTimeInterval(self, nMillisec):
        MvCamCtrldll.MV_GIGE_SetResendTimeInterval.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetResendTimeInterval.restype = c_uint
        # C原型:int MV_GIGE_SetResendTimeInterval(void* handle, unsigned int nMillisec)
        return MvCamCtrldll.MV_GIGE_SetResendTimeInterval(self.handle, c_uint(nMillisec))

    # ch:获取同一重传包多次请求之间的时间间隔 | en: get time interval between same resend requests
    def MV_GIGE_GetResendTimeInterval(self, nMillisec):
        MvCamCtrldll.MV_GIGE_GetResendTimeInterval.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetResendTimeInterval.restype = c_uint
        # C原型:int MV_GIGE_GetResendTimeInterval(void* handle, unsigned int* pnMillisec)
        return MvCamCtrldll.MV_GIGE_GetResendTimeInterval(self.handle, byref(nMillisec))

    # ch:设置传输模式，可以为单播模式、组播模式等 |en:Set transmission type,Unicast or Multicast
    def MV_GIGE_SetTransmissionType(self, stTransmissionType):
        MvCamCtrldll.MV_GIGE_SetTransmissionType.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_SetTransmissionType.restype = c_uint
        # C原型:int MV_GIGE_SetTransmissionType(void* handle, MV_TRANSMISSION_TYPE * pstTransmissionType)
        return MvCamCtrldll.MV_GIGE_SetTransmissionType(self.handle, byref(stTransmissionType))

    # ch:发出动作命令 | en:Issue Action Command
    def MV_GIGE_IssueActionCommand(self, pstActionCmdInfo, pstActionCmdResults):
        MvCamCtrldll.MV_GIGE_IssueActionCommand.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_IssueActionCommand.restype = c_uint
        # C原型:int  MV_GIGE_IssueActionCommand(IN MV_ACTION_CMD_INFO* pstActionCmdInfo,
        # OUT MV_ACTION_CMD_RESULT_LIST* pstActionCmdResults);
        return MvCamCtrldll.MV_GIGE_IssueActionCommand(byref(pstActionCmdInfo), byref(pstActionCmdResults))

    # ch:获取组播状态 | en:Get Multicast Status
    def MV_GIGE_GetMulticastStatus(self, pstDevInfo, pbStatus):
        MvCamCtrldll.MV_GIGE_GetMulticastStatus.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetMulticastStatus.restype = c_uint
        # C原型:int MV_GIGE_GetMulticastStatus(IN MV_CC_DEVICE_INFO* pstDevInfo, OUT bool* pbStatus);
        return MvCamCtrldll.MV_GIGE_GetMulticastStatus(byref(pstDevInfo), byref(pbStatus))

    ''' Part6 ch: 仅CameraLink 设备支持的接口 | en: Only support camlink device interface'''

    # ch:获取串口信息列表| en: Get serial port information list
    def MV_CAML_GetSerialPortList(self, stSerialPortList):
        MvCamCtrldll.MV_CAML_GetSerialPortList.argtype = c_void_p
        MvCamCtrldll.MV_CAML_GetSerialPortList.restype = c_uint
        # C原型:int __stdcall MV_CAML_GetSerialPortList(IN OUT MV_CAML_SERIAL_PORT_LIST* pstSerialPortList);
        return MvCamCtrldll.MV_CAML_GetSerialPortList(byref(stSerialPortList))

    # ch:设置指定串口，camera link仅在该串口下枚举| en: Set the specified enumeration serial port
    def MV_CAML_SetEnumSerialPorts(self, stSerialPortList):
        MvCamCtrldll.MV_CAML_SetEnumSerialPorts.argtype = c_void_p
        MvCamCtrldll.MV_CAML_SetEnumSerialPorts.restype = c_uint
        # C原型:int __stdcall MV_CAML_SetEnumSerialPorts(IN MV_CAML_SERIAL_PORT_LIST* pstSerialPortList);
        return MvCamCtrldll.MV_CAML_SetEnumSerialPorts(byref(stSerialPortList))

    # ch:设置设备波特率| en: Set device bauderate using one of the CL_BAUDRATE_XXXX value
    def MV_CAML_SetDeviceBaudrate(self, nBaudrate):
        MvCamCtrldll.MV_CAML_SetDeviceBaudrate.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CAML_SetDeviceBaudrate.restype = c_uint
        # C原型:int MV_CAML_SetDeviceBaudrate(IN void* handle, unsigned int nBaudrate);
        return MvCamCtrldll.MV_CAML_SetDeviceBaudrate(self.handle, c_uint(nBaudrate))

    # ch:获取设备波特率 | en:Returns the current device bauderate, using one of the CL_BAUDRATE_XXXX value
    def MV_CAML_GetDeviceBaudrate(self, pnCurrentBaudrate):
        MvCamCtrldll.MV_CAML_GetDeviceBaudrate.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CAML_GetDeviceBaudrate.restype = c_uint
        # C原型:int MV_CAML_GetDeviceBaudrate(IN void* handle,unsigned int* pnCurrentBaudrate);
        return MvCamCtrldll.MV_CAML_GetDeviceBaudrate(self.handle, byref(pnCurrentBaudrate))

    # ch:获取设备与主机间连接支持的波特率 | en:Returns supported bauderates of the combined device and host interface
    def MV_CAML_GetSupportBaudrates(self, pnBaudrateAblity):
        MvCamCtrldll.MV_CAML_GetSupportBaudrates.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CAML_GetSupportBaudrates.restype = c_uint
        # C原型:int MV_CAML_GetSupportBaudrates(IN void* handle,unsigned int* pnBaudrateAblity);
        return MvCamCtrldll.MV_CAML_GetSupportBaudrates(self.handle, byref(pnBaudrateAblity))

    # ch:设置串口操作等待时长 | en: Sets the timeout for operations on the serial port
    def MV_CAML_SetGenCPTimeOut(self, nMillisec):
        MvCamCtrldll.MV_CAML_SetGenCPTimeOut.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CAML_SetGenCPTimeOut.restype = c_uint
        # C原型:int MV_CAML_SetGenCPTimeOut(IN void* handle, unsigned int nMillisec);
        return MvCamCtrldll.MV_CAML_SetGenCPTimeOut(self.handle, c_uint(nMillisec))

    ''' Part7 ch: 仅U3V设备支持的接口 | en: Only support U3V device interface '''

    # ch:设置U3V的传输包大小 | en: Set transfer size of U3V device
    def MV_USB_SetTransferSize(self, nTransferSize):
        MvCamCtrldll.MV_USB_SetTransferSize.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetTransferSize.restype = c_uint
        # C原型:int MV_USB_SetTransferSize(IN void* handle, unsigned int nTransferSize);
        return MvCamCtrldll.MV_USB_SetTransferSize(self.handle, c_uint(nTransferSize))

    # ch:获取U3V的传输包大小 | en:Get transfer size of U3V device
    def MV_USB_GetTransferSize(self, pnTransferSize):
        MvCamCtrldll.MV_USB_GetTransferSize.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_GetTransferSize.restype = c_uint
        # C原型:int MV_USB_GetTransferSize(IN void* handle, unsigned int* pnTransferSize);
        return MvCamCtrldll.MV_USB_GetTransferSize(self.handle, byref(pnTransferSize))

    # ch:设置U3V的传输通道个数 | en: Set transfer ways of U3V device
    def MV_USB_SetTransferWays(self, nTransferWays):
        MvCamCtrldll.MV_USB_SetTransferWays.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetTransferWays.restype = c_uint
        # C原型:int MV_USB_SetTransferWays(IN void* handle, unsigned int nTransferWays);
        return MvCamCtrldll.MV_USB_SetTransferWays(self.handle, c_uint(nTransferWays))

    # ch:获取U3V的传输通道个数 | en:Get transfer ways of U3V device
    def MV_USB_GetTransferWays(self, pnTransferWays):
        MvCamCtrldll.MV_USB_GetTransferWays.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_GetTransferWays.restype = c_uint
        # C原型:int MV_USB_GetTransferWays(IN void* handle, unsigned int* pnTransferWays);
        return MvCamCtrldll.MV_USB_GetTransferWays(self.handle, byref(pnTransferWays))

    # ch:注册流异常消息回调，在打开设备之后调用（只支持U3V相机）
    # en: Register the stream exception callback, which is called after the device is opened.
    # Only the U3V camera is supported
    def MV_USB_RegisterStreamExceptionCallBack(self, CallBackFun, pUser):
        MvCamCtrldll.MV_USB_RegisterStreamExceptionCallBack.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_RegisterStreamExceptionCallBack.restype = c_uint
        # C原型:int MV_USB_RegisterStreamExceptionCallBack(
        # void* handle,
        # void(__stdcall* cbException)(MV_CC_STREAM_EXCEPTION_TYPE enExceptionType, void* pUser),
        # void* pUser);
        return MvCamCtrldll.MV_USB_RegisterStreamExceptionCallBack(self.handle, CallBackFun, pUser)

    # ch:设置U3V的事件缓存节点个数 | en: Set the number of U3V device event cache nodes
    def MV_USB_SetEventNodeNum(self, nEventNodeNum):
        MvCamCtrldll.MV_USB_SetEventNodeNum.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetEventNodeNum.restype = c_uint
        # C原型:int MV_USB_SetEventNodeNum(IN void* handle, unsigned int nEventNodeNum)
        return MvCamCtrldll.MV_USB_SetEventNodeNum(self.handle, c_uint(nEventNodeNum))

    # ch:设置U3V的同步读写超时时间,范围为0 ~ UINT_MAX(最小值包含0，最大值根据操作系统位数决定) | en: Set Sync timeout
    def MV_USB_SetSyncTimeOut(self, nMills):
        MvCamCtrldll.MV_USB_SetSyncTimeOut.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetSyncTimeOut.restype = c_uint
        # C原型:int MV_USB_SetSyncTimeOut(IN void* handle, unsigned int nMills);
        return MvCamCtrldll.MV_USB_SetSyncTimeOut(self.handle, c_uint(nMills))

    # ch:获取U3V相机同步读写超时时间 | en: Get Sync timeout
    def MV_USB_GetSyncTimeOut(self, nMills):
        MvCamCtrldll.MV_USB_GetSyncTimeOut.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_GetSyncTimeOut.restype = c_uint
        # C原型:int MV_USB_GetSyncTimeOut(IN void* handle, unsigned int* pnMills);
        return MvCamCtrldll.MV_USB_GetSyncTimeOut(self.handle, byref(nMills))

    ''' Part8 ch: GenTL相关接口 | en: GenTL related interface '''

    # ch:通过GenTL枚举Interfaces | en:Enumerate Interfaces with GenTL
    def MV_CC_EnumInterfacesByGenTL(stIFList, strGenTLPath):
        MvCamCtrldll.MV_CC_EnumInterfacesByGenTL.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EnumInterfacesByGenTL.restype = c_uint
        # C原型:int MV_CC_EnumInterfacesByGenTL(IN OUT MV_GENTL_IF_INFO_LIST* pstIFList, IN const char * strGenTLPath);
        return MvCamCtrldll.MV_CC_EnumInterfacesByGenTL(byref(stIFList), strGenTLPath.encode('ascii'))

    # ch:通过GenTL Interface枚举设备 | en:Enumerate Devices with GenTL interface
    def MV_CC_EnumDevicesByGenTL(stIFInfo, stDevList):
        MvCamCtrldll.MV_CC_EnumDevicesByGenTL.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EnumDevicesByGenTL.restype = c_uint
        # C原型:int MV_CC_EnumDevicesByGenTL(IN MV_GENTL_IF_INFO* pstIFInfo, IN OUT MV_GENTL_DEV_INFO_LIST* pstDevList);
        return MvCamCtrldll.MV_CC_EnumDevicesByGenTL(stIFInfo, byref(stDevList))

    # ch:卸载cti库 | en: Unload cti library
    @staticmethod
    def MV_CC_UnloadGenTLLibrary(GenTLPath):
        MvCamCtrldll.MV_CC_UnloadGenTLLibrary.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_UnloadGenTLLibrary.restype = c_uint
        # C原型:int MV_CC_UnloadGenTLLibrary(IN const char * pGenTLPath);
        return MvCamCtrldll.MV_CC_UnloadGenTLLibrary(GenTLPath.encode('ascii'))

    # ch:通过GenTL设备信息创建设备句柄 | en:Create Device Handle with GenTL Device Info
    def MV_CC_CreateHandleByGenTL(self, stDevInfo):
        MvCamCtrldll.MV_CC_CreateHandleByGenTL.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_CreateHandleByGenTL.restype = c_uint
        # C原型:int MV_CC_CreateHandleByGenTL(OUT void ** handle, IN const MV_GENTL_DEV_INFO* pstDevInfo);
        return MvCamCtrldll.MV_CC_CreateHandleByGenTL(byref(self.handle), byref(stDevInfo))

    ''' Part9 ch: 图像保存、格式转换等相关接口 | en: Related image save and format convert interface '''

    # ch:保存图片，支持Bmp和Jpeg | en:Save image, support Bmp and Jpeg.
    def MV_CC_SaveImageEx2(self, stSaveParam):
        MvCamCtrldll.MV_CC_SaveImageEx2.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageEx2.restype = c_uint
        # C原型:int MV_CC_SaveImageEx2(void* handle, MV_SAVE_IMAGE_PARAM_EX* pSaveParam)
        return MvCamCtrldll.MV_CC_SaveImageEx2(self.handle, byref(stSaveParam))

    # ch:保存图片，支持Bmp和Jpeg MV_CC_SaveImageEx3比MV_CC_SaveImageEx2 支持图像大小到Int
    # en:Save image, support Bmp and Jpeg.this API support the parameter nWidth nHeight to unsigned int.
    def MV_CC_SaveImageEx3(self, stSaveParam):
        MvCamCtrldll.MV_CC_SaveImageEx3.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageEx3.restype = c_uint
        # C原型:int MV_CC_SaveImageEx3(IN void* handle, MV_SAVE_IMAGE_PARAM_EX3* pstSaveParam)
        return MvCamCtrldll.MV_CC_SaveImageEx3(self.handle, byref(stSaveParam))

    # ch:保存图像到文件 | en:Save the image file
    def MV_CC_SaveImageToFile(self, stSaveFileParam):
        MvCamCtrldll.MV_CC_SaveImageToFile.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageToFile.restype = c_uint
        # C原型:int MV_CC_SaveImageToFile(IN void* handle, MV_SAVE_IMG_TO_FILE_PARAM* pstSaveFileParam);
        return MvCamCtrldll.MV_CC_SaveImageToFile(self.handle, byref(stSaveFileParam))

    # ch:保存图像到文件,支持保存的图像长乘宽乘像素大小至UINT_MAX, 其中MV_CC_SaveImageToFile支持最大至USHRT_MAX
    # en:Save the image file,Comparing with the API MV_CC_SaveImageToFile,
    # this API support the parameter nWidth * nHeight * pixelsize to UINT_MAX.
    def MV_CC_SaveImageToFileEx(self, stSaveFileParam):
        MvCamCtrldll.MV_CC_SaveImageToFileEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageToFileEx.restype = c_uint
        # C原型:int MV_CC_SaveImageToFileEx(IN void* handle,  MV_SAVE_IMAGE_TO_FILE_PARAM_EX* pstSaveFileParam);
        return MvCamCtrldll.MV_CC_SaveImageToFileEx(self.handle, byref(stSaveFileParam))

    # ch:保存3D点云数据，支持PLY、CSV和OBJ三种格式 | en:Save 3D point data, support PLY、CSV and OBJ
    def MV_CC_SavePointCloudData(self, stPointDataParam):
        MvCamCtrldll.MV_CC_SavePointCloudData.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SavePointCloudData.restype = c_uint
        # C原型:int MV_CC_SavePointCloudData(IN void* handle, MV_SAVE_POINT_CLOUD_PARAM* pstPointDataParam);
        return MvCamCtrldll.MV_CC_SavePointCloudData(self.handle, byref(stPointDataParam))

    # ch:图像旋转 | en: Rotate image
    def MV_CC_RotateImage(self, stRotateParam):
        MvCamCtrldll.MV_CC_RotateImage.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RotateImage.restype = c_uint
        # C原型:int MV_CC_RotateImage(IN void* handle, IN OUT MV_CC_ROTATE_IMAGE_PARAM* pstRotateParam);
        return MvCamCtrldll.MV_CC_RotateImage(self.handle, byref(stRotateParam))

    # ch:图像翻转 | en:Flip image
    def MV_CC_FlipImage(self, stFlipParam):
        MvCamCtrldll.MV_CC_FlipImage.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FlipImage.restype = c_uint
        # C原型:int MV_CC_FlipImage(IN void* handle, IN OUT MV_CC_FLIP_IMAGE_PARAM* pstFlipParam);
        return MvCamCtrldll.MV_CC_FlipImage(self.handle, byref(stFlipParam))

    # ch:像素格式转换 | en:Pixel format conversion
    def MV_CC_ConvertPixelType(self, stConvertParam):
        MvCamCtrldll.MV_CC_ConvertPixelType.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ConvertPixelType.restype = c_uint
        # C原型:int MV_CC_ConvertPixelType(void* handle, MV_CC_PIXEL_CONVERT_PARAM* pstCvtParam)
        return MvCamCtrldll.MV_CC_ConvertPixelType(self.handle, byref(stConvertParam))

    # ch:像素格式转换,接口支持转换的图像长乘宽乘像素大小至UINT_MAX
    # en:Pixel format conversion,comparing with the API MV_CC_ConvertPixelType,
    # this API support the parameter nWidth * nHeight * pixelsize to UINT_MAX.
    def MV_CC_ConvertPixelTypeEx(self, stConvertParam):
        MvCamCtrldll.MV_CC_ConvertPixelTypeEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ConvertPixelTypeEx.restype = c_uint
        # C原型:int MV_CC_ConvertPixelTypeEx(IN void* handle, IN OUT MV_CC_PIXEL_CONVERT_PARAM_EX* pstCvtParam);
        return MvCamCtrldll.MV_CC_ConvertPixelTypeEx(self.handle, byref(stConvertParam))

    # ch:插值算法类型设置 | en:Interpolation algorithm type setting
    def MV_CC_SetBayerCvtQuality(self, nBayerCvtQuality):
        MvCamCtrldll.MV_CC_SetBayerCvtQuality.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetBayerCvtQuality.restype = c_uint
        # C原型:int MV_CC_SetBayerCvtQuality(IN void* handle, IN unsigned int nBayerCvtQuality);
        return MvCamCtrldll.MV_CC_SetBayerCvtQuality(self.handle, c_uint(nBayerCvtQuality))

    # ch:插值算法平滑使能设置 | en: Filter type of the bell interpolation quality algorithm setting
    def MV_CC_SetBayerFilterEnable(self, bFilterEnable):
        MvCamCtrldll.MV_CC_SetBayerFilterEnable.argtype = (c_void_p, c_bool)
        MvCamCtrldll.MV_CC_SetBayerFilterEnable.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerFilterEnable(IN void* handle, IN bool bFilterEnable);
        return MvCamCtrldll.MV_CC_SetBayerFilterEnable(self.handle, c_bool(bFilterEnable))

    # ch:设置Bayer格式的Gamma值 | en: Set Gamma value
    def MV_CC_SetBayerGammaValue(self, fBayerGammaValue):
        MvCamCtrldll.MV_CC_SetBayerGammaValue.argtype = (c_void_p, c_float)
        MvCamCtrldll.MV_CC_SetBayerGammaValue.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerGammaValue(IN void* handle, IN float fBayerGammaValue);
        return MvCamCtrldll.MV_CC_SetBayerGammaValue(self.handle, c_float(fBayerGammaValue))

    # ch:设置Mono8/bayer格式的Gamma值 | en:Set Gamma value
    def MV_CC_SetGammaValue(self, enSrcPixelType, fGammaValue):
        MvCamCtrldll.MV_CC_SetGammaValue.argtype = (c_void_p, c_int, c_float)
        MvCamCtrldll.MV_CC_SetGammaValue.restype = c_uint
        # C原型:int MV_CC_SetGammaValue(IN void* handle, enum MvGvspPixelType enSrcPixelType, IN float fGammaValue);
        return MvCamCtrldll.MV_CC_SetGammaValue(self.handle, c_int(enSrcPixelType), c_float(fGammaValue))

    # ch：设置Bayer格式的Gamma信息 | en: Set Gamma param
    def MV_CC_SetBayerGammaParam(self, stGammaParam):
        MvCamCtrldll.MV_CC_SetBayerGammaParam.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetBayerGammaParam.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerGammaParam(IN void* handle, IN MV_CC_GAMMA_PARAM* pstGammaParam);
        return MvCamCtrldll.MV_CC_SetBayerGammaParam(self.handle, byref(stGammaParam))

    # ch:设置Bayer格式的CCM使能和矩阵，量化系数默认1024 | en:Set CCM param,Scale default 1024
    def MV_CC_SetBayerCCMParam(self, stCCMParam):
        MvCamCtrldll.MV_CC_SetBayerCCMParam.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetBayerCCMParam.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerCCMParam(IN void* handle, IN MV_CC_CCM_PARAM* pstCCMParam);
        return MvCamCtrldll.MV_CC_SetBayerCCMParam(self.handle, byref(stCCMParam))

    # ch:设置Bayer格式的CCM使能和矩阵 | en:Set CCM param
    def MV_CC_SetBayerCCMParamEx(self, stCCMParam):
        MvCamCtrldll.MV_CC_SetBayerCCMParamEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetBayerCCMParamEx.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerCCMParamEx(IN void* handle, IN MV_CC_CCM_PARAM_EX* pstCCMParam);
        return MvCamCtrldll.MV_CC_SetBayerCCMParamEx(self.handle, byref(stCCMParam))

    # ch:图像对比度调节 | en:Adjust image contrast
    def MV_CC_ImageContrast(self, stConstrastParam):
        MvCamCtrldll.MV_CC_ImageContrast.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ImageContrast.restype = c_uint
        # C原型：int __stdcall MV_CC_ImageContrast(IN void* handle, IN OUT MV_CC_CONTRAST_PARAM* pstContrastParam);
        return MvCamCtrldll.MV_CC_ImageContrast(self.handle, byref(stConstrastParam))

    # ch:无损解码 | en:High Bandwidth Decode
    def MV_CC_HBDecode(self, stDecodeParam):
        MvCamCtrldll.MV_CC_HB_Decode.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_HB_Decode.restype = c_uint
        # C原型：int __stdcall MV_CC_HB_Decode(IN void* handle, IN OUT MV_CC_HB_DECODE_PARAM* pstDecodeParam);
        return MvCamCtrldll.MV_CC_HB_Decode(self.handle, byref(stDecodeParam))

    # ch:在图像上绘制矩形框辅助线 | en:Draw Rect Auxiliary Line
    def MV_CC_DrawRect(self, stRectInfo):
        MvCamCtrldll.MV_CC_DrawRect.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DrawRect.restype = c_uint
        # C原型: int __stdcall MV_CC_DrawRect(IN void* handle, IN MVCC_RECT_INFO* pRectInfo);
        return MvCamCtrldll.MV_CC_DrawRect(self.handle, byref(stRectInfo))

    # ch:在图像上绘制圆形辅助线 | en:Draw Circle Auxiliary Line
    def MV_CC_DrawCircle(self, stCircleInfo):
        MvCamCtrldll.MV_CC_DrawCircle.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DrawCircle.restype = c_uint
        # C原型: int __stdcall MV_CC_DrawCircle(IN void* handle, IN MVCC_CIRCLE_INFO* pCircleInfo);
        return MvCamCtrldll.MV_CC_DrawCircle(self.handle, byref(stCircleInfo))

    # ch:在图像上绘制线条 | en:Draw Line Auxiliary Line
    def MV_CC_DrawLines(self, stLineInfo):
        MvCamCtrldll.MV_CC_DrawLines.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DrawLines.restype = c_uint
        # C原型: int __stdcall MV_CC_DrawLines(IN void* handle, IN MVCC_LINES_INFO* pLinesInfo);
        return MvCamCtrldll.MV_CC_DrawLines(self.handle, byref(stLineInfo))

    # ch:开始录像 | en:Start Record
    def MV_CC_StartRecord(self, stRecordParam):
        MvCamCtrldll.MV_CC_StartRecord.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_StartRecord.restype = c_uint
        # C原型:int __stdcall MV_CC_StartRecord(IN void* handle, IN MV_CC_RECORD_PARAM* pstRecordParam);
        return MvCamCtrldll.MV_CC_StartRecord(self.handle, byref(stRecordParam))

    # ch: 输入录像数据 | en:Input RAW data to Record
    def MV_CC_InputOneFrame(self, stInputFrameInfo):
        MvCamCtrldll.MV_CC_InputOneFrame.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_InputOneFrame.restype = c_uint
        # C原型：int __stdcall MV_CC_InputOneFrame(IN void* handle, IN MV_CC_INPUT_FRAME_INFO * pstInputFrameInfo);
        return MvCamCtrldll.MV_CC_InputOneFrame(self.handle, byref(stInputFrameInfo))

    # ch:停止录像 | en:Stop Record
    def MV_CC_StopRecord(self):
        MvCamCtrldll.MV_CC_StopRecord.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_StopRecord.restype = c_uint
        # C原型：int __stdcall MV_CC_StopRecord(IN void* handle);
        return MvCamCtrldll.MV_CC_StopRecord(self.handle)

    # ch:打开获取或设置相机参数的GUI界面 | en:Open the GUI interface for getting or setting camera parameters
    def MV_CC_OpenParamsGUI(self):
        MvCamCtrldll.MV_CC_OpenParamsGUI.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_OpenParamsGUI.restype = c_uint
        # C原型: __stdcall MV_CC_OpenParamsGUI(IN void* handle);
        return MvCamCtrldll.MV_CC_OpenParamsGUI(self.handle)

    # ch:重构图像(用于分时曝光功能) | en:Reconstruct Image(For time-division exposure function)
    def MV_CC_ReconstructImage(self, stReconstructParam):
        MvCamCtrldll.MV_CC_ReconstructImage.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ReconstructImage.restype = c_uint
        # C原型：int __stdcall MV_CC_ReconstructImage(IN void* handle, IN OUT MV_RECONSTRUCT_IMAGE_PARAM* pstReconstructParam);
        return MvCamCtrldll.MV_CC_ReconstructImage(self.handle, byref(stReconstructParam))


===== .//MvImport/MvErrorDefine_const.py =====
#!/usr/bin/env python
# -*- coding: utf-8 -*-

MV_OK                                        = 0x00000000  # < \~chinese 成功，无错误             \~english Successed, no error

# 通用错误码定义:范围0x80000000-0x800000FF
MV_E_HANDLE                                  = 0x80000000  # < \~chinese 错误或无效的句柄         \~english Error or invalid handle
MV_E_SUPPORT                                 = 0x80000001  # < \~chinese 不支持的功能             \~english Not supported function
MV_E_BUFOVER                                 = 0x80000002  # < \~chinese 缓存已满                 \~english Buffer overflow
MV_E_CALLORDER                               = 0x80000003  # < \~chinese 函数调用顺序错误         \~english Function calling order error
MV_E_PARAMETER                               = 0x80000004  # < \~chinese 错误的参数               \~english Incorrect parameter
MV_E_RESOURCE                                = 0x80000006  # < \~chinese 资源申请失败             \~english Applying resource failed
MV_E_NODATA                                  = 0x80000007  # < \~chinese 无数据                   \~english No data
MV_E_PRECONDITION                            = 0x80000008  # < \~chinese 前置条件有误，或运行环境已发生变化       \~english Precondition error, or running environment changed
MV_E_VERSION                                 = 0x80000009  # < \~chinese 版本不匹配               \~english Version mismatches
MV_E_NOENOUGH_BUF                            = 0x8000000A  # < \~chinese 传入的内存空间不足       \~english Insufficient memory
MV_E_ABNORMAL_IMAGE                          = 0x8000000B  # < \~chinese 异常图像，可能是丢包导致图像不完整       \~english Abnormal image, maybe incomplete image because of lost packet
MV_E_LOAD_LIBRARY                            = 0x8000000C  # < \~chinese 动态导入DLL失败          \~english Load library failed
MV_E_NOOUTBUF                                = 0x8000000D  # < \~chinese 没有可输出的缓存         \~english No Avaliable Buffer
MV_E_UNKNOW                                  = 0x800000FF  # < \~chinese 未知的错误               \~english Unknown error

# GenICam系列错误:范围0x80000100-0x800001FF
MV_E_GC_GENERIC                              = 0x80000100  # < \~chinese 通用错误                 \~english General error
MV_E_GC_ARGUMENT                             = 0x80000101  # < \~chinese 参数非法                 \~english Illegal parameters
MV_E_GC_RANGE                                = 0x80000102  # < \~chinese 值超出范围               \~english The value is out of range
MV_E_GC_PROPERTY                             = 0x80000103  # < \~chinese 属性                     \~english Property
MV_E_GC_RUNTIME                              = 0x80000104  # < \~chinese 运行环境有问题           \~english Running environment error
MV_E_GC_LOGICAL                              = 0x80000105  # < \~chinese 逻辑错误                 \~english Logical error
MV_E_GC_ACCESS                               = 0x80000106  # < \~chinese 节点访问条件有误         \~english Node accessing condition error
MV_E_GC_TIMEOUT                              = 0x80000107  # < \~chinese 超时                     \~english Timeout
MV_E_GC_DYNAMICCAST                          = 0x80000108  # < \~chinese 转换异常                 \~english Transformation exception
MV_E_GC_UNKNOW                               = 0x800001FF  # < \~chinese GenICam未知错误          \~english GenICam unknown error

# GigE_STATUS对应的错误码:范围0x80000200-0x800002FF
MV_E_NOT_IMPLEMENTED                         = 0x80000200  # < \~chinese 命令不被设备支持         \~english The command is not supported by device
MV_E_INVALID_ADDRESS                         = 0x80000201  # < \~chinese 访问的目标地址不存在     \~english The target address being accessed does not exist
MV_E_WRITE_PROTECT                           = 0x80000202  # < \~chinese 目标地址不可写           \~english The target address is not writable
MV_E_ACCESS_DENIED                           = 0x80000203  # < \~chinese 设备无访问权限           \~english No permission
MV_E_BUSY                                    = 0x80000204  # < \~chinese 设备忙，或网络断开       \~english Device is busy, or network disconnected
MV_E_PACKET                                  = 0x80000205  # < \~chinese 网络包数据错误           \~english Network data packet error
MV_E_NETER                                   = 0x80000206  # < \~chinese 网络相关错误             \~english Network error
MV_E_KEY_VERIFICATION                        = 0x8000020F  # < \~chinese 秘钥校验错误              \~english SwitchKey error
MV_E_IP_CONFLICT                             = 0x80000221  # < \~chinese 设备IP冲突               \~english Device IP conflict

# USB_STATUS对应的错误码:范围0x80000300-0x800003FF
MV_E_USB_READ                                = 0x80000300  # < \~chinese 读usb出错               \~english Reading USB error
MV_E_USB_WRITE                               = 0x80000301  # < \~chinese 写usb出错               \~english Writing USB error
MV_E_USB_DEVICE                              = 0x80000302  # < \~chinese 设备异常                \~english Device exception
MV_E_USB_GENICAM                             = 0x80000303  # < \~chinese GenICam相关错误         \~english GenICam error
MV_E_USB_BANDWIDTH                           = 0x80000304  # < \~chinese 带宽不足  该错误码新增   \~english Insufficient bandwidth, this error code is newly added
MV_E_USB_DRIVER                              = 0x80000305  # < \~chinese 驱动不匹配或者未装驱动   \~english Driver mismatch or unmounted drive
MV_E_USB_UNKNOW                              = 0x800003FF  # < \~chinese USB未知的错误           \~english USB unknown error

# 升级时对应的错误码:范围0x80000400-0x800004FF
MV_E_UPG_FILE_MISMATCH                       = 0x80000400  # < \~chinese 升级固件不匹配           \~english Firmware mismatches
MV_E_UPG_LANGUSGE_MISMATCH                   = 0x80000401  # < \~chinese 升级固件语言不匹配       \~english Firmware language mismatches
MV_E_UPG_CONFLICT                            = 0x80000402  # < \~chinese 升级冲突（设备已经在升级了再次请求升级即返回此错误）   \~english Upgrading conflicted (repeated upgrading requests during device upgrade)
MV_E_UPG_INNER_ERR                           = 0x80000403  # < \~chinese 升级时设备内部出现错误   \~english Camera internal error during upgrade
MV_E_UPG_UNKNOW                              = 0x800004FF  # < \~chinese 升级时未知错误          \~english Unknown error during upgrade


===== .//MvImport/PixelType_header.py =====
# -*- coding: utf-8 -*-
from ctypes import *

PixelType_Gvsp_BGR12_Packed = 36700187
PixelType_Gvsp_COORD3D_DEPTH_PLUS_MASK = -2112094207
PixelType_Gvsp_RGB10V1_Packed = 35651612
PixelType_Gvsp_BayerRG12_Packed = 17563691
PixelType_Gvsp_RGB12_Planar = 36700195
PixelType_Gvsp_YUV411_Packed = 34340894
PixelType_Gvsp_YUV444_Packed = 35127328
PixelType_Gvsp_BGR10_Packed = 36700185
PixelType_Gvsp_YCBCR422_8 = 34603067
PixelType_Gvsp_YCBCR709_422_8 = 34603073
PixelType_Gvsp_RGB12_Packed = 36700186
PixelType_Gvsp_Coord3D_ABC32f_Planar = 39846081
PixelType_Gvsp_Mono8_Signed = 17301506
PixelType_Gvsp_YUV422_YUYV_Packed = 34603058
PixelType_Gvsp_Mono4p = 17039417
PixelType_Gvsp_BayerGR12_Packed = 17563690
PixelType_Gvsp_Coord3D_ABC32 = -2107625471
PixelType_Gvsp_Coord3D_AB32f = -2109722622
PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY = 34340930
PixelType_Gvsp_YCBCR709_422_8_CBYCRY = 34603077
PixelType_Gvsp_Coord3D_AB32 = -2109722621
PixelType_Gvsp_YCBCR601_422_8_CBYCRY = 34603076
PixelType_Gvsp_YCBCR709_8_CBYCR = 35127360
PixelType_Gvsp_Coord3D_AC32f = 36176066
PixelType_Gvsp_YCBCR8_CBYCR = 35127354
PixelType_Gvsp_YCBCR411_8_CBYYCRYY = 34340924
PixelType_Gvsp_Coord3D_ABC32f = 39846080
PixelType_Gvsp_YUV422_Packed = 34603039
PixelType_Gvsp_Coord3D_ABC16 = 36700345
PixelType_Gvsp_RGB10_Planar = 36700194
PixelType_Gvsp_RGB8_Planar = 35127329
PixelType_Gvsp_RGB10_Packed = 36700184
PixelType_Gvsp_Coord3D_C32 = -2128596986
PixelType_Gvsp_RGB16_Packed = 36700211
PixelType_Gvsp_YCBCR422_8_CBYCRY = 34603075
PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY = 34340927
PixelType_Gvsp_BGRA8_Packed = 35651607
PixelType_Gvsp_Jpeg = -2145910783
PixelType_Gvsp_YCBCR601_422_8 = 34603070
PixelType_Gvsp_Coord3D_C32f = 18874559
PixelType_Gvsp_BayerGB12_Packed = 17563692
PixelType_Gvsp_BayerRG16 = 17825839
PixelType_Gvsp_BayerGB10_Packed = 17563688
PixelType_Gvsp_RGB12V1_Packed = 35913780
PixelType_Gvsp_RGB16_Planar = 36700196
PixelType_Gvsp_BGR565_Packed = 34603062
PixelType_Gvsp_Mono16 = 17825799
PixelType_Gvsp_BayerBG10 = 17825807
PixelType_Gvsp_Coord3D_AC32f_64 = 37748930
PixelType_Gvsp_RGBA8_Packed = 35651606
PixelType_Gvsp_Mono12 = 17825797
PixelType_Gvsp_Coord3D_A32f = 18874557
PixelType_Gvsp_YCBCR601_8_CBYCR = 35127357
PixelType_Gvsp_BayerGB16 = 17825840
PixelType_Gvsp_Coord3D_AC32 = -2109722620
PixelType_Gvsp_BayerBG16 = 17825841
PixelType_Gvsp_Coord3D_AC32f_Planar = 37748931
PixelType_Gvsp_BayerBG10_Packed = 17563689
PixelType_Gvsp_RGB8_Packed = 35127316
PixelType_Gvsp_BGR8_Packed = 35127317
PixelType_Gvsp_BayerGR16 = 17825838
PixelType_Gvsp_BayerGR10_Packed = 17563686
PixelType_Gvsp_Mono8 = 17301505
PixelType_Gvsp_Mono14 = 17825829
PixelType_Gvsp_BayerGB10 = 17825806
PixelType_Gvsp_Undefined = -1
PixelType_Gvsp_BayerRG8 = 17301513
PixelType_Gvsp_BayerGB12 = 17825810
PixelType_Gvsp_Mono12_Packed = 17563654
PixelType_Gvsp_BayerBG8 = 17301515
PixelType_Gvsp_BayerBG12_Packed = 17563693
PixelType_Gvsp_Mono1p = 16842807
PixelType_Gvsp_Mono2p = 16908344
PixelType_Gvsp_RGB565_Packed = 34603061
PixelType_Gvsp_RGB10V2_Packed = 35651613
PixelType_Gvsp_BayerRG12 = 17825809
PixelType_Gvsp_Mono10_Packed = 17563652
PixelType_Gvsp_BayerGR8 = 17301512
PixelType_Gvsp_BayerGB8 = 17301514
PixelType_Gvsp_BayerGR12 = 17825808
PixelType_Gvsp_BayerGR10 = 17825804
PixelType_Gvsp_BayerRG10 = 17825805
PixelType_Gvsp_BayerBG12 = 17825811
PixelType_Gvsp_Coord3D_A32 = -2128596987
PixelType_Gvsp_Mono10 = 17825795
PixelType_Gvsp_BayerRG10_Packed = 17563687
PixelType_Gvsp_YUV420SP_NV12 = 34373633
PixelType_Gvsp_YUV420SP_NV21 = 34373634
PixelType_Gvsp_Coord3D_C16 = 17825976
PixelType_Gvsp_HB_Mono8 = -2130182143
PixelType_Gvsp_HB_Mono10 = -2129657853
PixelType_Gvsp_HB_Mono10_Packed = -2129919996
PixelType_Gvsp_HB_Mono12 = -2129657851
PixelType_Gvsp_HB_Mono12_Packed = -2129919994
PixelType_Gvsp_HB_Mono16 = -2129657849
PixelType_Gvsp_HB_BayerGR8 = -2130182136
PixelType_Gvsp_HB_BayerRG8 = -2130182135
PixelType_Gvsp_HB_BayerGB8 = -2130182134
PixelType_Gvsp_HB_BayerBG8 = -2130182133
PixelType_Gvsp_HB_BayerRBGG8 = -2130182074
PixelType_Gvsp_HB_BayerGR10 = -2129657844
PixelType_Gvsp_HB_BayerRG10 = -2129657843
PixelType_Gvsp_HB_BayerGB10 = -2129657842
PixelType_Gvsp_HB_BayerBG10 = -2129657841
PixelType_Gvsp_HB_BayerGR12 = -2129657840
PixelType_Gvsp_HB_BayerRG12 = -2129657839
PixelType_Gvsp_HB_BayerGB12 = -2129657838
PixelType_Gvsp_HB_BayerBG12 = -2129657837
PixelType_Gvsp_HB_BayerGR10_Packed = -2129919962
PixelType_Gvsp_HB_BayerRG10_Packed = -2129919961
PixelType_Gvsp_HB_BayerGB10_Packed = -2129919960
PixelType_Gvsp_HB_BayerBG10_Packed = -2129919959
PixelType_Gvsp_HB_BayerGR12_Packed = -2129919958
PixelType_Gvsp_HB_BayerRG12_Packed = -2129919957
PixelType_Gvsp_HB_BayerGB12_Packed = -2129919956
PixelType_Gvsp_HB_BayerBG12_Packed = -2129919955
PixelType_Gvsp_HB_YUV422_Packed = -2112880609
PixelType_Gvsp_HB_YUV422_YUYV_Packed = -2112880590
PixelType_Gvsp_HB_RGB8_Packed = -2112356332
PixelType_Gvsp_HB_BGR8_Packed = -2112356331
PixelType_Gvsp_HB_RGBA8_Packed = -2111832042
PixelType_Gvsp_HB_BGRA8_Packed = -2111832041
PixelType_Gvsp_HB_RGB16_Packed = -2110783437
PixelType_Gvsp_HB_BGR16_Packed = -2110783413
PixelType_Gvsp_HB_RGBA16_Packed = -2109734812
PixelType_Gvsp_HB_BGRA16_Packed = -2109734831

__all__ = ['PixelType_Gvsp_BayerRG8',
           'PixelType_Gvsp_YCBCR422_8',
           'PixelType_Gvsp_Coord3D_ABC32',
           'PixelType_Gvsp_Coord3D_AB32f',
           'PixelType_Gvsp_COORD3D_DEPTH_PLUS_MASK',
           'PixelType_Gvsp_RGB10_Packed',
           'PixelType_Gvsp_RGB10V1_Packed',
           'PixelType_Gvsp_RGB8_Planar',
           'PixelType_Gvsp_RGBA8_Packed',
           'PixelType_Gvsp_RGB8_Packed',
           'PixelType_Gvsp_BayerBG12',
           'PixelType_Gvsp_Coord3D_AC32f_Planar',
           'PixelType_Gvsp_BayerBG10_Packed',
           'PixelType_Gvsp_YCBCR709_422_8_CBYCRY',
           'PixelType_Gvsp_Coord3D_A32f',
           'PixelType_Gvsp_YUV411_Packed',
           'PixelType_Gvsp_BayerBG12_Packed',
           'PixelType_Gvsp_RGB16_Packed',
           'PixelType_Gvsp_BayerRG12',
           'PixelType_Gvsp_BayerRG10',
           'PixelType_Gvsp_BayerRG16',
           'PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY',
           'PixelType_Gvsp_BayerGB12_Packed',
           'PixelType_Gvsp_Coord3D_AC32f',
           'PixelType_Gvsp_BayerRG12_Packed',
           'PixelType_Gvsp_Coord3D_AB32',
           'PixelType_Gvsp_BGR12_Packed',
           'PixelType_Gvsp_BayerGR10_Packed',
           'PixelType_Gvsp_Coord3D_AC32',
           'PixelType_Gvsp_RGB12_Planar',
           'PixelType_Gvsp_YCBCR709_422_8',
           'PixelType_Gvsp_BGR8_Packed',
           'PixelType_Gvsp_Jpeg',
           'PixelType_Gvsp_Coord3D_AC32f_64',
           'PixelType_Gvsp_YUV422_Packed',
           'PixelType_Gvsp_Mono8_Signed',
           'PixelType_Gvsp_BayerBG10',
           'PixelType_Gvsp_BayerBG16',
           'PixelType_Gvsp_BayerGR8',
           'PixelType_Gvsp_RGB16_Planar',
           'PixelType_Gvsp_Mono4p',
           'PixelType_Gvsp_BayerRG10_Packed',
           'PixelType_Gvsp_Mono8',
           'PixelType_Gvsp_BayerGR16',
           'PixelType_Gvsp_BayerGR10',
           'PixelType_Gvsp_BGRA8_Packed',
           'PixelType_Gvsp_BayerGR12',
           'PixelType_Gvsp_Mono12_Packed',
           'PixelType_Gvsp_YCBCR709_8_CBYCR',
           'PixelType_Gvsp_Coord3D_A32',
           'PixelType_Gvsp_YCBCR601_422_8',
           'PixelType_Gvsp_Coord3D_C32',
           'PixelType_Gvsp_YCBCR411_8_CBYYCRYY',
           'PixelType_Gvsp_Undefined',
           'PixelType_Gvsp_BayerGR12_Packed',
           'PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY',
           'PixelType_Gvsp_RGB10_Planar',
           'PixelType_Gvsp_BayerGB16',
           'PixelType_Gvsp_BayerGB10',
           'PixelType_Gvsp_BayerGB12',
           'PixelType_Gvsp_BGR565_Packed',
           'PixelType_Gvsp_Mono1p',
           'PixelType_Gvsp_Coord3D_ABC16',
           'PixelType_Gvsp_YUV444_Packed',
           'PixelType_Gvsp_YUV422_YUYV_Packed',
           'PixelType_Gvsp_BayerBG8',
           'PixelType_Gvsp_Coord3D_C32f',
           'PixelType_Gvsp_BGR10_Packed',
           'PixelType_Gvsp_BayerGB10_Packed',
           'PixelType_Gvsp_Coord3D_ABC32f_Planar',
           'PixelType_Gvsp_Coord3D_ABC32f',
           'PixelType_Gvsp_YCBCR422_8_CBYCRY',
           'PixelType_Gvsp_RGB12_Packed',
           'PixelType_Gvsp_Mono12',
           'PixelType_Gvsp_Mono10',
           'PixelType_Gvsp_Mono16',
           'PixelType_Gvsp_Mono2p',
           'PixelType_Gvsp_Mono14',
           'PixelType_Gvsp_RGB10V2_Packed',
           'PixelType_Gvsp_RGB12V1_Packed',
           'PixelType_Gvsp_Mono10_Packed',
           'PixelType_Gvsp_YCBCR601_8_CBYCR',
           'PixelType_Gvsp_BayerGB8',
           'PixelType_Gvsp_YCBCR8_CBYCR',
           'PixelType_Gvsp_RGB565_Packed',
           'PixelType_Gvsp_YCBCR601_422_8_CBYCRY',
           'PixelType_Gvsp_YUV420SP_NV12',
           'PixelType_Gvsp_YUV420SP_NV21',
           'PixelType_Gvsp_Coord3D_C16',
           'PixelType_Gvsp_HB_Mono8',
           'PixelType_Gvsp_HB_Mono10',
           'PixelType_Gvsp_HB_Mono10_Packed',
           'PixelType_Gvsp_HB_Mono12',
           'PixelType_Gvsp_HB_Mono12_Packed',
           'PixelType_Gvsp_HB_Mono16',
           'PixelType_Gvsp_HB_BayerGR8',
           'PixelType_Gvsp_HB_BayerRG8',
           'PixelType_Gvsp_HB_BayerGB8',
           'PixelType_Gvsp_HB_BayerBG8',
           'PixelType_Gvsp_HB_BayerRBGG8',
           'PixelType_Gvsp_HB_BayerGR10',
           'PixelType_Gvsp_HB_BayerRG10',
           'PixelType_Gvsp_HB_BayerGB10',
           'PixelType_Gvsp_HB_BayerBG10',
           'PixelType_Gvsp_HB_BayerGR12',
           'PixelType_Gvsp_HB_BayerRG12',
           'PixelType_Gvsp_HB_BayerGB12',
           'PixelType_Gvsp_HB_BayerBG12',
           'PixelType_Gvsp_HB_BayerGR10_Packed',
           'PixelType_Gvsp_HB_BayerRG10_Packed',
           'PixelType_Gvsp_HB_BayerGB10_Packed',
           'PixelType_Gvsp_HB_BayerBG10_Packed',
           'PixelType_Gvsp_HB_BayerGR12_Packed',
           'PixelType_Gvsp_HB_BayerRG12_Packed',
           'PixelType_Gvsp_HB_BayerGB12_Packed',
           'PixelType_Gvsp_HB_BayerBG12_Packed',
           'PixelType_Gvsp_HB_YUV422_Packed',
           'PixelType_Gvsp_HB_YUV422_YUYV_Packed',
           'PixelType_Gvsp_HB_RGB8_Packed',
           'PixelType_Gvsp_HB_BGR8_Packed',
           'PixelType_Gvsp_HB_RGBA8_Packed',
           'PixelType_Gvsp_HB_BGRA8_Packed',
           'PixelType_Gvsp_HB_RGB16_Packed',
           'PixelType_Gvsp_HB_BGR16_Packed',
           'PixelType_Gvsp_HB_RGBA16_Packed',
           'PixelType_Gvsp_HB_BGRA16_Packed']


===== .//ParametrizeCamera_FileAccess/ParametrizeCamera_FileAccess.py =====
# -- coding: utf-8 --

import time
import sys
import threading
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

# 为ProgressThread线程定义一个函数
def progress_thread(cam=0, nMode=0):
    stFileAccessProgress = MV_CC_FILE_ACCESS_PROGRESS()
    memset(byref(stFileAccessProgress), 0, sizeof(stFileAccessProgress))
    while True:
        #ch:获取文件存取进度 |en:Get progress of file access
        ret = cam.MV_CC_GetFileAccessProgress(stFileAccessProgress)
        print ("State = [%x],Completed = [%d],Total = [%d]" % (ret, stFileAccessProgress.nCompleted, stFileAccessProgress.nTotal))
        if (ret != MV_OK or (stFileAccessProgress.nCompleted != 0 and stFileAccessProgress.nCompleted == stFileAccessProgress.nTotal)):
            print('press a key to continue.')
            break

# 为FileAccessThread线程定义一个函数
def file_access_thread(cam=0, nMode=0):
    stFileAccess = MV_CC_FILE_ACCESS()
    memset(byref(stFileAccess), 0, sizeof(stFileAccess))
    stFileAccess.pUserFileName = 'UserSet1.bin'.encode('ascii')
    stFileAccess.pDevFileName = 'UserSet1'.encode('ascii')
    if 1 == nMode:
        #ch:读模式 |en:Read mode
        ret = cam.MV_CC_FileAccessRead(stFileAccess)
        if MV_OK != ret:
            print ("file access read fail ret [0x%x]\n" % ret)
    elif 2 == nMode:
        #ch:写模式 |en:Write mode
        ret = cam.MV_CC_FileAccessWrite(stFileAccess)
        if MV_OK != ret:
            print ("file access write fail ret [0x%x]\n" % ret)

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = MV_GIGE_DEVICE | MV_USB_DEVICE
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no Device!")
        sys.exit()

    print ("find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()
    
    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()

    #ch:读模式 |en:Read mode
    print ("read to file.")
    print('press a key to start.')
    msvcrt.getch()

    try:
        hReadThreadHandle = threading.Thread(target=file_access_thread, args=(cam, 1))
        hReadThreadHandle.start()
        time.sleep(0.005)
        hProgress1ThreadHandle = threading.Thread(target=progress_thread, args=(cam, 1))
        hProgress1ThreadHandle.start()
    except:
        print ("error: unable to start thread")

    print ("waiting.")
    msvcrt.getch()

    hReadThreadHandle.join()
    hProgress1ThreadHandle.join()

    #ch:写模式 |en:Write mode
    print ("write from file.")
    print('press a key to start.')
    msvcrt.getch()

    try:
        hWriteThreadHandle = threading.Thread(target=file_access_thread, args=(cam, 2))
        hWriteThreadHandle.start()
        time.sleep(0.005)
        hProgress2ThreadHandle = threading.Thread(target=progress_thread, args=(cam, 2))
        hProgress2ThreadHandle.start()
    except:
        print ("error: unable to start thread")

    print ("waiting.")
    msvcrt.getch()

    hWriteThreadHandle.join()
    hProgress2ThreadHandle.join()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()


===== .//ParametrizeCamera_LoadAndSave/ParametrizeCamera_LoadAndSave.py =====
# -- coding: utf-8 --

import sys

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = MV_GIGE_DEVICE | MV_USB_DEVICE
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()
    
    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()

    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()

    print ("start export the camera properties to the file")
    print ("wait......")

    #ch:将相机属性导出到文件中 | en:Export the camera properties to the file
    ret = cam.MV_CC_FeatureSave("FeatureFile.mfs")
    if MV_OK != ret:
        print ("save feature fail! ret [0x%x]" % ret)
    print ("finish export the camera properties to the file")

    print ("start import the camera properties from the file")
    print ("wait......")

    #ch:从文件中导入相机属性 | en:Import the camera properties from the file
    ret = cam.MV_CC_FeatureLoad("FeatureFile.mfs")
    if MV_OK != ret:
        print ("load feature fail! ret [0x%x]" % ret)
    print ("finish import the camera properties from the file")

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()



===== .//Recording/Recording.py =====
# -- coding: utf-8 --

import sys
import threading
import msvcrt

from ctypes import *

sys.path.append("../MvImport")
from MvCameraControl_class import *

g_bExit = False

# 为线程定义一个函数
def work_thread(cam=0, pData=0, nDataSize=0):
    stOutFrame = MV_FRAME_OUT()  
    memset(byref(stOutFrame), 0, sizeof(stOutFrame))

    stInputFrameInfo = MV_CC_INPUT_FRAME_INFO()
    memset(byref(stInputFrameInfo), 0 ,sizeof(MV_CC_INPUT_FRAME_INFO))
    while True:
        ret = cam.MV_CC_GetImageBuffer(stOutFrame, 1000)
        if None != stOutFrame.pBufAddr and 0 == ret:
            print ("get one frame: Width[%d], Height[%d], nFrameNum[%d]"  % (stOutFrame.stFrameInfo.nWidth, stOutFrame.stFrameInfo.nHeight, stOutFrame.stFrameInfo.nFrameNum))
            stInputFrameInfo.pData = cast(stOutFrame.pBufAddr, POINTER(c_ubyte))
            stInputFrameInfo.nDataLen = stOutFrame.stFrameInfo.nFrameLen
            # ch:输入一帧数据到录像接口 | en:Input a frame of data to the video interface
            ret = cam.MV_CC_InputOneFrame(stInputFrameInfo)
            if ret != 0:
                print ("input one frame fail! nRet [0x%x]" % ret)
            nRet = cam.MV_CC_FreeImageBuffer(stOutFrame)
        else:
            print ("no data[0x%x]" % ret)
        if g_bExit == True:
                break

if __name__ == "__main__":

    # ch:初始化SDK | en: initialize SDK
    MvCamera.MV_CC_Initialize()

    deviceList = MV_CC_DEVICE_INFO_LIST()
    tlayerType = (MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE
                  | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE)
    
    # ch:枚举设备 | en:Enum device
    ret = MvCamera.MV_CC_EnumDevices(tlayerType, deviceList)
    if ret != 0:
        print ("enum devices fail! ret[0x%x]" % ret)
        sys.exit()

    if deviceList.nDeviceNum == 0:
        print ("find no device!")
        sys.exit()

    print ("Find %d devices!" % deviceList.nDeviceNum)

    for i in range(0, deviceList.nDeviceNum):
        mvcc_dev_info = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO)).contents
        if mvcc_dev_info.nTLayerType == MV_GIGE_DEVICE or mvcc_dev_info.nTLayerType == MV_GENTL_GIGE_DEVICE:
            print ("\ngige device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stGigEInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            nip1 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0xff000000) >> 24)
            nip2 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x00ff0000) >> 16)
            nip3 = ((mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x0000ff00) >> 8)
            nip4 = (mvcc_dev_info.SpecialInfo.stGigEInfo.nCurrentIp & 0x000000ff)
            print ("current ip: %d.%d.%d.%d\n" % (nip1, nip2, nip3, nip4))
        elif mvcc_dev_info.nTLayerType == MV_USB_DEVICE:
            print ("\nu3v device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stUsb3VInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CAMERALINK_DEVICE:
            print ("\nCML device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCMLInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_CXP_DEVICE:
            print ("\nCXP device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stCXPInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)
        elif mvcc_dev_info.nTLayerType == MV_GENTL_XOF_DEVICE:
            print ("\nXoF device: [%d]" % i)
            strModeName = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chModelName:
                if per == 0:
                    break
                strModeName = strModeName + chr(per)
            print ("device model name: %s" % strModeName)

            strSerialNumber = ""
            for per in mvcc_dev_info.SpecialInfo.stXoFInfo.chSerialNumber:
                if per == 0:
                    break
                strSerialNumber = strSerialNumber + chr(per)
            print ("user serial number: %s" % strSerialNumber)

    nConnectionNum = input("please input the number of the device to connect:")

    if int(nConnectionNum) >= deviceList.nDeviceNum:
        print ("intput error!")
        sys.exit()

    # ch:创建相机实例 | en:Creat Camera Object
    cam = MvCamera()
    
    # ch:选择设备并创建句柄 | en:Select device and create handle
    stDeviceList = cast(deviceList.pDeviceInfo[int(nConnectionNum)], POINTER(MV_CC_DEVICE_INFO)).contents

    ret = cam.MV_CC_CreateHandle(stDeviceList)
    if ret != 0:
        print ("create handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:打开设备 | en:Open device
    ret = cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0)
    if ret != 0:
        print ("open device fail! ret[0x%x]" % ret)
        sys.exit()
    
    # ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)
    if stDeviceList.nTLayerType == MV_GIGE_DEVICE or stDeviceList.nTLayerType == MV_GENTL_GIGE_DEVICE:
        nPacketSize = cam.MV_CC_GetOptimalPacketSize()
        if int(nPacketSize) > 0:
            ret = cam.MV_CC_SetIntValue("GevSCPSPacketSize",nPacketSize)
            if ret != 0:
                print ("Warning: Set Packet Size fail! ret[0x%x]" % ret)
        else:
            print ("Warning: Get Packet Size fail! ret[0x%x]" % nPacketSize)

    stBool = c_bool(False)
    ret =cam.MV_CC_GetBoolValue("AcquisitionFrameRateEnable", stBool)
    if ret != 0:
        print ("get AcquisitionFrameRateEnable fail! ret[0x%x]" % ret)

    # ch:设置触发模式为off | en:Set trigger mode as off
    ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
    if ret != 0:
        print ("set trigger mode fail! ret[0x%x]" % ret)
        sys.exit()

    stParam =  MVCC_INTVALUE()
    memset(byref(stParam), 0, sizeof(MVCC_INTVALUE))
    stRecordPar = MV_CC_RECORD_PARAM()
    memset(byref(stRecordPar), 0, sizeof(MV_CC_RECORD_PARAM))
    # ch:获取图像高度 | en:Get the width of the image
    ret = cam.MV_CC_GetIntValue("Width", stParam)
    if ret != 0: 
        print ("get width fail! nRet [0x%x]" % ret)
        sys.exit()
    stRecordPar.nWidth = stParam.nCurValue

    # ch:获取图像高度 | en:Get the height of the image
    ret = cam.MV_CC_GetIntValue("Height", stParam)
    if ret != 0: 
        print ("get height fail! nRet [0x%x]"% ret)
        sys.exit()
    stRecordPar.nHeight = stParam.nCurValue

    # ch:获取图像像素 | en:Get the pixelFormat of the image
    stEnumValue = MVCC_ENUMVALUE()
    memset(byref(stEnumValue), 0 ,sizeof(MVCC_ENUMVALUE))
    ret = cam.MV_CC_GetEnumValue("PixelFormat", stEnumValue)
    if ret != 0: 
        print ("get PixelFormat fail! nRet [0x%x]" % ret)
        sys.exit()
    stRecordPar.enPixelType = MvGvspPixelType(stEnumValue.nCurValue)

    # ch:获取图像帧率 | en:Get the resultingFrameRate of the image
    stFloatValue = MVCC_FLOATVALUE()
    memset(byref(stFloatValue), 0 ,sizeof(MVCC_FLOATVALUE))
    ret = cam.MV_CC_GetFloatValue("ResultingFrameRate", stFloatValue)
    if ret != 0: 
        print ("get ResultingFrameRate value fail! nRet [0x%x]" % ret)
        sys.exit()
    stRecordPar.fFrameRate = stFloatValue.fCurValue

    # ch:录像结构体赋值 | en:Video structure assignment
    stRecordPar.nBitRate = 1000
    stRecordPar.enRecordFmtType = MV_FormatType_AVI
    stRecordPar.strFilePath= 'Recording.avi'.encode('ascii')

    # ch:开始录像 | en:Start Recording
    nRet = cam.MV_CC_StartRecord(stRecordPar)
    if ret != 0: 
        print ("Start Record fail! nRet [0x%x]\n", nRet)
        sys.exit()

    # ch:开始取流 | en:Start grab image
    ret = cam.MV_CC_StartGrabbing()
    if ret != 0:
        print ("start grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    try:
        hThreadHandle = threading.Thread(target=work_thread, args=(cam, None, None))
        hThreadHandle.start()
    except:
        print ("error: unable to start thread")
        
    print ("press a key to stop grabbing.")
    msvcrt.getch()

    g_bExit = True
    hThreadHandle.join()

    # ch:停止取流 | en:Stop grab image
    ret = cam.MV_CC_StopGrabbing()
    if ret != 0:
        print ("stop grabbing fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:停止录像 | en:Stop recording
    ret = cam.MV_CC_StopRecord()
    if ret != 0:
        print ("stop Record fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:关闭设备 | Close device
    ret = cam.MV_CC_CloseDevice()
    if ret != 0:
        print ("close deivce fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:销毁句柄 | Destroy handle
    ret = cam.MV_CC_DestroyHandle()
    if ret != 0:
        print ("destroy handle fail! ret[0x%x]" % ret)
        sys.exit()

    # ch:反初始化SDK | en: finalize SDK
    MvCamera.MV_CC_Finalize()



